<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Flink状态管理_StateAPI</title>
    <url>/article/Flink%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-StateAPI/</url>
    <content><![CDATA[<h1 id="Flink的状态"><a href="#Flink的状态" class="headerlink" title="Flink的状态"></a>Flink的状态</h1><p>何为状态（state）：可以理解成在计算的过程中产生的数据、变量等等等等，例如我们做词频计数时，单词的数量就是状态，每当对已经统计的数量进行更新时，这个更新就是状态的更新</p>
<p>Flink 天生可以对数据进行状态计算，且提供了几种由Flink托管的状态</p>
<p>Flink应用程序的状态通常是在本地进行，这么做为了提高吞吐量以及降低延迟，Flink应用程序一般都将状态存储在JVM堆内存中。</p>
<p>通过状态快照，Flink可以提供<code>可容错</code>的、<code>可精确到一次</code>的计算语义。</p>
<p>Flink会在程序执行时获取并保存分布式流处理管道（Pipeline）中的所有的状态以及整个作业图中 算子获取到数据时的状态。</p>
<p>Flink提供了不同的状态机制，用于指定状态的存储方式和存储位置，按照是否由Flink进行管理分为以下两类</p>
<table>
<thead>
<tr>
<th></th>
<th>托管状态(Managed State)</th>
<th>原生状态(Raw State)</th>
</tr>
</thead>
<tbody><tr>
<td>管理方式</td>
<td>由 Flink Runtime 自动管理、会自动存储与恢复状态、Flink对齐进行了优化</td>
<td>由用户自行管理、需要用户自行序列化</td>
</tr>
<tr>
<td>数据结构</td>
<td>ValueState、ListState、MapState ……..</td>
<td>Byte[]   自己实现</td>
</tr>
<tr>
<td>使用场景</td>
<td>绝大多数用它就够</td>
<td>左边那位用不了的时候才考虑</td>
</tr>
</tbody></table>
<span id="more"></span>
<h2 id="Maneged-State"><a href="#Maneged-State" class="headerlink" title="Maneged State"></a>Maneged State</h2><p>Managed State由Flink Runtime管理，自动存储，自动恢复，在内存上有做优化</p>
<p>根据数据集是否要按照Key进行分区，由将状态分为 Keyed State 和 Operator State（也有人叫Non-Keyed State，一回事）</p>
<table>
<thead>
<tr>
<th></th>
<th>Keyed State</th>
<th>Operator State</th>
</tr>
</thead>
<tbody><tr>
<td>适用算子</td>
<td>只适用于<code>KeyesStream</code>上的算子</td>
<td>可用于所有算子</td>
</tr>
<tr>
<td>状态分配</td>
<td>每个<code>Key</code>对应一个状态</td>
<td>一个算子的一个<code>子任务</code>对应一个状态</td>
</tr>
<tr>
<td>创建和扩展方式</td>
<td>重写Rich Function，通过里面的<code>RuntimeContext</code>去访问</td>
<td>实现<code>ChckopintedFunction</code>等结构接口</td>
</tr>
<tr>
<td>横向扩展</td>
<td>状态将随着Key在多个算子之间迁移</td>
<td>状态的分配方式多样</td>
</tr>
<tr>
<td>支持的数据结构</td>
<td>ValueState、ListState、MapState…….</td>
<td>ListState、BroadcastState…..</td>
</tr>
</tbody></table>
<p>(表格来自知乎@PP鲁)</p>
<h3 id="KeyedState"><a href="#KeyedState" class="headerlink" title="KeyedState"></a>KeyedState</h3><p>Keyed State 区分<code>不同的Key</code>的数据进行状态存储和管理，每个Key对应一个状态对象</p>
<p>通过keyBy()算子会将数据流进行状态分区，Keyed State被进一步组织成Keyed Groups</p>
<p>一个Keyed Groups包含<code>多个Key</code>的状态，是用于重新分配Keyed State的原子单位&#96;</p>
<h4 id="支持的数据类型"><a href="#支持的数据类型" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h4><ul>
<li><p>ValueState<T>：保存一个具体的<code>值</code>，可以对其进行更新查询，该值与数据数据的Key对应，可以使用update(T)方法更新值，value()方法获取值,clear()清除值</T></p>
</li>
<li><p>ListState<T>：保存一个数据<code>列表</code>，通过add(T)或addAll(List<T>)向列表添加数据；可以使用gat()方法得到一个可迭代的(Iterable<T>)，可用于遍历列表；可使用update(List<T>)覆盖更新列表</T></T></T></T></p>
</li>
<li><p>ReducingState<T>:保存一个<code>聚合</code>的单值，可以通过add(T)添加元素，但添加元素时，做的操作则是将该元素丢给用户自定义的ReduceFunction，然后将ReduseFunction的返回结果用于更新状态报错的单值，所以与前者不同的是，前者保存的是一个集合，而ReducingState保存的是一聚合结果</T></p>
</li>
<li><p>AggregatingState&lt;IN,OUT&gt;:保存一个<code>聚合</code>的单值，与前者不同，它允许状态的聚合结果与添加到状态的<code>元素不同</code>，同样适用add添加，原理与前者一样。</p>
</li>
<li><p>MapState&lt;UK,UV&gt;:保存为一个<code>键值对</code>数据,可以使用put(UK,UV)&#x2F; putAll(Map&lt;UK,UV&gt;)方法添加&#x2F;更新数据到状态，也可使用gey(UK)获取相应的数据</p>
</li>
</ul>
<p>上面几个数据类型均可使用clear()方法清除状态</p>
<h4 id="以ValueState举例"><a href="#以ValueState举例" class="headerlink" title="以ValueState举例"></a>以ValueState举例</h4><p>相同Key达到两次，求出其平均值，抛给下游并清空状态</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.<span class="type">RichFlatMapFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.&#123;<span class="type">ValueState</span>, <span class="type">ValueStateDescriptor</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.<span class="type">Configuration</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.<span class="type">Collector</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    env.setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> dataStream = env.fromElements(</span><br><span class="line">      (<span class="number">1</span>,<span class="number">3</span>),</span><br><span class="line">      (<span class="number">2</span>,<span class="number">5</span>),</span><br><span class="line">      (<span class="number">1</span>,<span class="number">7</span>),</span><br><span class="line">      (<span class="number">2</span>,<span class="number">3</span>),</span><br><span class="line">      (<span class="number">1</span>,<span class="number">2</span>)     <span class="comment">//最后这条数据由于不足2 ，不会被计数</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    dataStream</span><br><span class="line">      .keyBy(_._1)</span><br><span class="line">      .flatMap(<span class="keyword">new</span> <span class="type">MyFlatMapFunction</span>())</span><br><span class="line">      .print()</span><br><span class="line"></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自定义一个FlatMap</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFlatMapFunction</span> <span class="keyword">extends</span> <span class="title">RichFlatMapFunction</span>[(<span class="type">Int</span>,<span class="type">Int</span>),(<span class="type">Int</span>,<span class="type">Int</span>)] </span>&#123;</span><br><span class="line">  <span class="comment">//声明个变量，用于存放状态</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> sum:<span class="type">ValueState</span>[(<span class="type">Int</span>,<span class="type">Int</span>)] = _</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//从上下文拿到状态</span></span><br><span class="line">    <span class="keyword">this</span>.sum = getRuntimeContext.getState(    <span class="comment">//getRuntimeContext可以得到该函数实例的上下文信息</span></span><br><span class="line">      <span class="comment">//ValueState 使用ValueStateDescriptor 创建</span></span><br><span class="line">      <span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[(<span class="type">Int</span>,<span class="type">Int</span>)](<span class="string">&quot;score&quot;</span>,createTypeInformation[(<span class="type">Int</span>,<span class="type">Int</span>)])</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>(in: (<span class="type">Int</span>,<span class="type">Int</span>), collector: <span class="type">Collector</span>[(<span class="type">Int</span>,<span class="type">Int</span>)]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//先通过value()方法得到状态值</span></span><br><span class="line">    <span class="keyword">val</span> stateValue= sum.value()</span><br><span class="line">    <span class="comment">//初始化，如果状态值为空，就创建一个初始值，否者使用状态值</span></span><br><span class="line">    <span class="keyword">val</span> currentSum = <span class="keyword">if</span> (stateValue != <span class="literal">null</span>) stateValue <span class="keyword">else</span> (<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">    <span class="comment">//(计数，求和)</span></span><br><span class="line">    <span class="keyword">val</span> newSum = (currentSum._1 + <span class="number">1</span> , currentSum._2 + in._2)</span><br><span class="line">    <span class="comment">//使用update()方法更新状态</span></span><br><span class="line">    <span class="keyword">this</span>.sum.update(newSum)</span><br><span class="line">    <span class="comment">//如果计数器达到2，将平均值丢出去并清空状态</span></span><br><span class="line">    <span class="keyword">if</span>(newSum._1 &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">      collector.collect((in._1 , newSum._2 / newSum._1))</span><br><span class="line">      <span class="keyword">this</span>.sum.clear()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1,5)</span><br><span class="line">(2,4)</span><br></pre></td></tr></table></figure>

<h4 id="再以MapState举例"><a href="#再以MapState举例" class="headerlink" title="再以MapState举例"></a>再以MapState举例</h4><p>使用MapState保存中间结果，计算分组的和</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.<span class="type">RichFlatMapFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.state.&#123;<span class="type">MapState</span>, <span class="type">MapStateDescriptor</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.configuration.<span class="type">Configuration</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.<span class="type">Collector</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]):<span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    env.setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> dataStream = env.fromElements(</span><br><span class="line">      (<span class="string">&quot;Java&quot;</span>,<span class="number">1</span>),</span><br><span class="line">      (<span class="string">&quot;Python&quot;</span>,<span class="number">3</span>),</span><br><span class="line">      (<span class="string">&quot;Java&quot;</span>,<span class="number">2</span>),</span><br><span class="line">      (<span class="string">&quot;Scala&quot;</span>,<span class="number">2</span>),</span><br><span class="line">      (<span class="string">&quot;Python&quot;</span>,<span class="number">1</span>),</span><br><span class="line">      (<span class="string">&quot;Java&quot;</span>,<span class="number">1</span>),</span><br><span class="line">      (<span class="string">&quot;Scala&quot;</span>,<span class="number">2</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    dataStream</span><br><span class="line">      .keyBy(_._1)        <span class="comment">//keyBy分组</span></span><br><span class="line">      <span class="comment">//MapState还是要从上下文获取，所以还需要实现一个富函数</span></span><br><span class="line">      .flatMap(<span class="keyword">new</span> <span class="type">MyFlatMapFunc</span>)</span><br><span class="line">      .print(<span class="string">&quot;求和&quot;</span>)</span><br><span class="line"></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFlatMapFunc</span> <span class="keyword">extends</span> <span class="title">RichFlatMapFunction</span>[(<span class="type">String</span>,<span class="type">Int</span>),(<span class="type">String</span>,<span class="type">Int</span>)] </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> state:<span class="type">MapState</span>[<span class="type">String</span>, <span class="type">Int</span>] = _</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过生命周期函数获取MapState</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">open</span></span>(parameters: <span class="type">Configuration</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//创建描述器</span></span><br><span class="line">    <span class="keyword">val</span> stateDesc = <span class="keyword">new</span> <span class="type">MapStateDescriptor</span>[<span class="type">String</span>,<span class="type">Int</span>](</span><br><span class="line">      <span class="string">&quot;sumMap&quot;</span>,</span><br><span class="line">      classOf[<span class="type">String</span>],</span><br><span class="line">      classOf[<span class="type">Int</span>]</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">//传入描述器得到状态</span></span><br><span class="line">    <span class="keyword">this</span>.state = getRuntimeContext.getMapState(stateDesc)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//使用MapState获取历史结果</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>(in: (<span class="type">String</span>, <span class="type">Int</span>), collector: <span class="type">Collector</span>[(<span class="type">String</span>, <span class="type">Int</span>)]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//获取新数据的key</span></span><br><span class="line">    <span class="keyword">val</span> key:<span class="type">String</span> = in._1</span><br><span class="line">    <span class="comment">//通过get(UK)去State中拿历史结果</span></span><br><span class="line">    <span class="keyword">val</span> stateValue: <span class="type">Int</span> = <span class="keyword">this</span>.state.get(key)</span><br><span class="line">    <span class="comment">//通过put(UK,UV)添加/更新数据到</span></span><br><span class="line">    <span class="keyword">this</span>.state.put(key,stateValue + in._2)</span><br><span class="line"></span><br><span class="line">    collector.collect((key,<span class="keyword">this</span>.state.get(key)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">求和&gt; (Java,1)</span><br><span class="line">求和&gt; (Python,3)</span><br><span class="line">求和&gt; (Java,3)</span><br><span class="line">求和&gt; (Scala,2)</span><br><span class="line">求和&gt; (Python,4)</span><br><span class="line">求和&gt; (Java,4)</span><br><span class="line">求和&gt; (Scala,4)</span><br></pre></td></tr></table></figure>

<h3 id="Operator-State"><a href="#Operator-State" class="headerlink" title="Operator State"></a>Operator State</h3><p>与Keyed State不同，Operator State不局限于Keyed算子，所有流入算子的数据都可访问和更新该状态</p>
<p>Flink应用程序的状态的问都是在本地进行，为了保证数据的可恢复性，使用CheckPoint机制将状态数据持久化到存储空间上（具体后面写文章讲），主要逻辑主要有两项，一是将算子任务班底内存数据在CheckPoint时写硬盘（称为snapshot），二是在Flink应用初始化或重启时将永久化的数据读取通过一定逻辑处理后变为算子的本地内存数据（称为restore）。在次过程中，Flink并不能保证数据百分百的一致</p>
<p>为了实现这两个步骤，Flink提供了最为基础的CheckpointedFunction接口类。</p>
<p><img data-src="/../../image/Flink%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86-StateAPI/CheckpointedFunction%E6%8E%A5%E5%8F%A3%E7%B1%BB.png" alt="CheckpointedFunction接口类"></p>
<h4 id="支持的数据类型-1"><a href="#支持的数据类型-1" class="headerlink" title="支持的数据类型"></a>支持的数据类型</h4><p>Operator State支持的数据类型有三种</p>
<ul>
<li><p>ListState</p>
</li>
<li><p>UnionListState</p>
</li>
<li><p>BroadcastState</p>
</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>Operator State常被用在Source或Sink等算子上，用来保存流入数据的偏移量或对输出数据做缓存，以保证Flink应用的Exactly-Once语义。</p>
<p>这里我们来看一个Flink官方提供的Sink案例以了解CheckpointedFunction的工作原理。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BufferingSink需要继承SinkFunction以实现其Sink功能，同时也要继承CheckpointedFunction接口类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BufferingSink</span>(<span class="params">threshold: <span class="type">Int</span> = 0</span>)</span></span><br><span class="line">  <span class="keyword">extends</span> <span class="type">SinkFunction</span>[(<span class="type">String</span>, <span class="type">Int</span>)]</span><br><span class="line">    <span class="keyword">with</span> <span class="type">CheckpointedFunction</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Operator List State句柄</span></span><br><span class="line">  <span class="meta">@transient</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> checkpointedState: <span class="type">ListState</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = _</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本地缓存</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> bufferedElements = <span class="type">ListBuffer</span>[(<span class="type">String</span>, <span class="type">Int</span>)]()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Sink的核心处理逻辑，将上游数据value输出到外部系统</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">invoke</span></span>(value: (<span class="type">String</span>, <span class="type">Int</span>), context: <span class="type">Context</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 先将上游数据缓存到本地的缓存</span></span><br><span class="line">    bufferedElements += value</span><br><span class="line">    <span class="comment">// 当本地缓存大小到达阈值时，将本地缓存输出到外部系统</span></span><br><span class="line">    <span class="keyword">if</span> (bufferedElements.size == threshold) &#123;</span><br><span class="line">      <span class="keyword">for</span> (element &lt;- bufferedElements) &#123;</span><br><span class="line">        <span class="comment">// send it to the sink</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 清空本地缓存</span></span><br><span class="line">      bufferedElements.clear()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写CheckpointedFunction中的snapshotState</span></span><br><span class="line">  <span class="comment">// 将本地缓存snapshot保存到存储上</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">snapshotState</span></span>(context: <span class="type">FunctionSnapshotContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 将之前的Checkpoint清理</span></span><br><span class="line">    checkpointedState.clear()</span><br><span class="line">    <span class="comment">// 将最新的数据写到状态中</span></span><br><span class="line">    <span class="keyword">for</span> (element &lt;- bufferedElements) &#123;</span><br><span class="line">      checkpointedState.add(element)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重写CheckpointedFunction中的initializeState</span></span><br><span class="line">  <span class="comment">// 初始化状态</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">initializeState</span></span>(context: <span class="type">FunctionInitializationContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 注册ListStateDescriptor</span></span><br><span class="line">    <span class="keyword">val</span> descriptor = <span class="keyword">new</span> <span class="type">ListStateDescriptor</span>[(<span class="type">String</span>, <span class="type">Int</span>)](</span><br><span class="line">      <span class="string">&quot;buffered-elements&quot;</span>,</span><br><span class="line">      <span class="type">TypeInformation</span>.of(<span class="keyword">new</span> <span class="type">TypeHint</span>[(<span class="type">String</span>, <span class="type">Int</span>)]() &#123;&#125;)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从FunctionInitializationContext中获取OperatorStateStore，进而获取ListState</span></span><br><span class="line">    checkpointedState = context.getOperatorStateStore.getListState(descriptor)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是作业重启，读取存储中的状态数据并填充到本地缓存中</span></span><br><span class="line">    <span class="keyword">if</span>(context.isRestored) &#123;</span><br><span class="line">      <span class="keyword">for</span>(element &lt;- checkpointedState.get()) &#123;</span><br><span class="line">        bufferedElements += element</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Raw-State"><a href="#Raw-State" class="headerlink" title="Raw State"></a>Raw State</h2><p>所有的Raw State<code>都是Operator State</code></p>
<p>Raw State这需要用户自己去管理，需要自己序列化，Flink不知道State内的数据是什么结构，用户最终需要把它序列化成可存储的数据结构</p>
<blockquote>
<p>后续补上</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记分享</category>
      </categories>
      <tags>
        <tag>Flink</tag>
        <tag>状态</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink数据分流与合流</title>
    <url>/article/Flink%E6%95%B0%E6%8D%AE%E5%88%86%E6%B5%81%E4%B8%8E%E5%90%88%E6%B5%81/</url>
    <content><![CDATA[<h1 id="数据分流"><a href="#数据分流" class="headerlink" title="数据分流"></a>数据分流</h1><p>流数据就像车流，每辆车可不一定都去往同一个目的地，所以，现实中我们可能要对数据进行分流</p>
<p>分流后，数据被分成了主流(我这么叫，不知道有没有错)与侧边流，常常提到的Flink侧边流大致就是这个概念</p>
<span id="more"></span>

<p>大概长这样</p>
<p><img data-src="/../image/Flink%E6%95%B0%E6%8D%AE%E5%88%86%E6%B5%81%E4%B8%8E%E5%90%88%E6%B5%81/%E6%95%B0%E6%8D%AE%E5%88%86%E6%B5%81.png" alt="数据分流"></p>
<p>通常我们使用一定的条件限制侧边流的数据，不然一模一样也没意义是吧</p>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>我将模拟一个班级学生的成绩，将不及格（&lt;60分）的同学的数据通过侧边流输出，其余同学则照常使用主流输出</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.<span class="type">ProcessFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.<span class="type">Collector</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//个人比较喜欢使用自定义的类型</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Score</span>(<span class="params">name:<span class="type">String</span>,<span class="type">Score</span>:<span class="type">Float</span></span>)</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    env.setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> dataStream = env.fromElements(</span><br><span class="line">      (<span class="string">&quot;李二狗&quot;</span>,<span class="number">86.5</span>f),</span><br><span class="line">      (<span class="string">&quot;张三猫&quot;</span>,<span class="number">95.0</span>f),</span><br><span class="line">      (<span class="string">&quot;刘四牛&quot;</span>,<span class="number">55.5</span>f)</span><br><span class="line">    ).map(d =&gt; &#123;<span class="type">Score</span>(d._1, d._2)&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在分流前，我们要为每个侧边流定义一个outputTag，不让它不知道从哪出去</span></span><br><span class="line">    <span class="keyword">val</span> noPassTag = <span class="keyword">new</span> <span class="type">OutputTag</span>[<span class="type">Score</span>](<span class="string">&quot;noPass&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 然后开始正式的分流</span></span><br><span class="line"><span class="comment">      * 使用process方法实现分流</span></span><br><span class="line"><span class="comment">      * 传入org.apache.flink.streaming.api.functions.ProcessFunction的实例</span></span><br><span class="line"><span class="comment">      * 第一个是输入的数据类型，第二个是输出的数据类型</span></span><br><span class="line"><span class="comment">      * */</span></span><br><span class="line">    <span class="keyword">val</span> scoreStream = dataStream</span><br><span class="line">      .process(<span class="keyword">new</span> <span class="type">ProcessFunction</span>[<span class="type">Score</span>,<span class="type">Score</span>] &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement</span></span>(value: <span class="type">Score</span>, ctx: <span class="type">ProcessFunction</span>[<span class="type">Score</span>, <span class="type">Score</span>]#<span class="type">Context</span>, out: <span class="type">Collector</span>[<span class="type">Score</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">          <span class="comment">//使用if判断条件</span></span><br><span class="line">          <span class="keyword">if</span>(value.<span class="type">Score</span> &lt; <span class="number">60</span>)&#123;              <span class="comment">//不及格的走这，留下来叫家长。。。。</span></span><br><span class="line">            ctx.output(noPassTag,value)      <span class="comment">//刚刚的标签派上用场了</span></span><br><span class="line">          &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            out.collect(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用侧边流的数据</span></span><br><span class="line">    scoreStream.getSideOutput(noPassTag)</span><br><span class="line">      .print(<span class="string">&quot;不及格&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主流输出</span></span><br><span class="line">    scoreStream</span><br><span class="line">      .print(<span class="string">&quot;及格&quot;</span>)</span><br><span class="line">      </span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">及格&gt; Score(李二狗,86.5)</span><br><span class="line">及格&gt; Score(张三猫,95.0)</span><br><span class="line">不及格&gt; Score(刘四牛,55.5)</span><br></pre></td></tr></table></figure>

<h1 id="数据合流"><a href="#数据合流" class="headerlink" title="数据合流"></a>数据合流</h1><blockquote>
<p>先讲一句：Flink中所有的数据合流操作，都<code>无法保证数据的顺序</code></p>
</blockquote>
<p>就像车流，有分就有合</p>
<p>数据的合流分为两种，如下：</p>
<h3 id="Union-聚合-简单粗暴"><a href="#Union-聚合-简单粗暴" class="headerlink" title="Union(聚合) - 简单粗暴"></a>Union(聚合) - 简单粗暴</h3><p>直接交汇<code>多个</code>流，需要求两个流数据<code>类型相同</code></p>
<p>数据<code>不会去重</code>，若与自己聚合，每个元素将出现两次</p>
<p><img data-src="/../image/Flink%E6%95%B0%E6%8D%AE%E5%88%86%E6%B5%81%E4%B8%8E%E5%90%88%E6%B5%81/Union.png" alt="Union"></p>
<h4 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    env.setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stream1 = env.fromCollection(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line">    <span class="keyword">val</span> stream2 = env.fromCollection(<span class="type">List</span>(<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    stream1</span><br><span class="line">      .union(stream2)     <span class="comment">//dataStream:DataStream</span></span><br><span class="line">      .print()</span><br><span class="line"></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="Connect-连接-灵活"><a href="#Connect-连接-灵活" class="headerlink" title="Connect(连接) - 灵活"></a>Connect(连接) - 灵活</h3><p>Connect可以连接<code>两个</code>数据<code>类型不同</code>的数据流</p>
<p>但要注意：</p>
<ul>
<li><p>返回的将不再是DataStream，而是<code>ConnectedStream</code></p>
</li>
<li><p>ConnectedStream就<code>只能使用</code>map、flatMap，process，keyBy算子</p>
</li>
<li><p>Connect<code>只能连接两个流</code>，而union可以是多个流</p>
</li>
</ul>
<p><img data-src="/../image/Flink%E6%95%B0%E6%8D%AE%E5%88%86%E6%B5%81%E4%B8%8E%E5%90%88%E6%B5%81/Connect.png" alt="Connect"></p>
<h4 id="举个例子-2"><a href="#举个例子-2" class="headerlink" title="举个例子"></a>举个例子</h4><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.functions.co.<span class="type">CoMapFunction</span></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.scala._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">    env.setParallelism(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stream1 = env.fromCollection(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line">    <span class="keyword">val</span> stream2 = env.fromCollection(<span class="type">List</span>(<span class="string">&quot;6&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;8&quot;</span>))</span><br><span class="line"></span><br><span class="line">    stream1</span><br><span class="line">      .connect(stream2)</span><br><span class="line">      .map(<span class="keyword">new</span> <span class="type">MyCoMapFunction</span>)     <span class="comment">//注意，这里的Map不能像之前一样直接使用lambda函数了</span></span><br><span class="line">    .print()</span><br><span class="line">      </span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们实现一个 CoMapFunction</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* org.apache.flink.streaming.api.functions.co.CoMapFunction</span></span><br><span class="line"><span class="comment">* IN1 第一个流的输入（也就是被连接的那个）</span></span><br><span class="line"><span class="comment">* IN2 第二个流的输入（也就是用来连接的那个）</span></span><br><span class="line"><span class="comment">* OUT CoMapFunction实例的输出</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCoMapFunction</span> <span class="keyword">extends</span> <span class="title">CoMapFunction</span>[<span class="type">Int</span>,<span class="type">String</span>,<span class="type">Int</span>] </span>&#123;</span><br><span class="line">  <span class="comment">//处理第一个流的数据</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">map1</span></span>(value: <span class="type">Int</span>): <span class="type">Int</span> = value</span><br><span class="line">  <span class="comment">//处理第二个流的数据</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">map2</span></span>(value: <span class="type">String</span>): <span class="type">Int</span> = value.toInt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">6</span><br><span class="line">2</span><br><span class="line">7</span><br><span class="line">3</span><br><span class="line">8</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记分享</category>
      </categories>
      <tags>
        <tag>Flink</tag>
        <tag>侧边流</tag>
        <tag>流合并</tag>
      </tags>
  </entry>
  <entry>
    <title>GO语言快速上手</title>
    <url>/article/GO%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[<blockquote>
<p>本笔记仅适用与已经熟练掌握一门及以上编程语言者快速掌握GO语言</p>
</blockquote>
<p>GO语言是由Google支持的开源编程语言。它易于学习，适合团队使用</p>
<span id="more"></span>

<h1 id="准备动作"><a href="#准备动作" class="headerlink" title="准备动作"></a>准备动作</h1><h2 id="安装GO环境"><a href="#安装GO环境" class="headerlink" title="安装GO环境"></a>安装GO环境</h2><p>下载GO并解压</p>
<p><a href="https://golang.google.cn/dl/">https://golang.google.cn/dl/</a></p>
<p><img data-src="/../image/GO%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/image-20220811125403160.png" alt="image-20220811125403160"></p>
<blockquote>
<p>我的操作系统是Linux，Windows有所区别</p>
</blockquote>
<p>修改环境变量</p>
<p><code>底部添加</code></p>
<p><img data-src="/../image/GO%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/image-20220831160236477.png" alt="image-20220831160236477"></p>
<p>生效，并验证是否能够现实版本</p>
<p><img data-src="/../image/GO%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/image-20220811125555134.png" alt="image-20220811125555134"></p>
<h2 id="安装VSCode插件"><a href="#安装VSCode插件" class="headerlink" title="安装VSCode插件"></a>安装VSCode插件</h2><p><img data-src="/../image/GO%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/image-20220811125632371.png" alt="image-20220811125632371"></p>
<h2 id="解决插件项目TimeOutwent"><a href="#解决插件项目TimeOutwent" class="headerlink" title="解决插件项目TimeOutwent"></a>解决插件项目TimeOutwent</h2><p>go是来着Google的，由于某种因数影响，我们不能直接访问默认源proxy.golang.org</p>
<p>中国大陆唯一可用的代理源为 goproxy.cn</p>
<p>所以我们要修改默认的源</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 控制台执行</span></span><br><span class="line">go <span class="built_in">env</span> -w GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure>

<h2 id="修改GO命令行module功能的启用"><a href="#修改GO命令行module功能的启用" class="headerlink" title="修改GO命令行module功能的启用"></a>修改GO命令行module功能的启用</h2><p>什么作用先别管，我后面会说</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 控制台执行</span></span><br><span class="line">go <span class="built_in">env</span> -w GO111MODULE=auto</span><br></pre></td></tr></table></figure>



<h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><h2 id="使用VSCode创建项目"><a href="#使用VSCode创建项目" class="headerlink" title="使用VSCode创建项目"></a>使用VSCode创建项目</h2><p>创建空文件夹并使用vsc打开</p>
<img data-src="../image/GO语言快速上手/image-20220811130907980.png" alt="image-20220811130907980" style="zoom:80%;">

<p>创建hello.go</p>
<p><img data-src="/../image/GO%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/image-20220811130959836.png" alt="image-20220811130959836"></p>
<p>点击右下键Install All</p>
<p><img data-src="/../image/GO%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/image-20220811131027053.png" alt="image-20220811131027053"></p>
<p>直到你看到它</p>
<p><img data-src="/../image/GO%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/image-20220811131239409.png" alt="image-20220811131239409"></p>
<p>现在所有的工具包都安装成功了</p>
<h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><p>打开hello.go，并编辑它</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*定义包名，表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。*/</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">/*导包，fmt 包实现了格式化 IO（输入/输出）的函数*/</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义函数，main与Java Scala一致，是程序的入口，如果每个名为Init的函数，则最先执行它*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;     <span class="comment">/*&#123;不能单独在一行上*/</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Hello World!!!&quot;</span>) <span class="comment">/*与Scala类似*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="如何跑起来"><a href="#如何跑起来" class="headerlink" title="如何跑起来"></a>如何跑起来</h2><h3 id="1-使用VSCode"><a href="#1-使用VSCode" class="headerlink" title="1.使用VSCode"></a>1.使用VSCode</h3><p><img data-src="/../image/GO%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/image-20220811132837147.png" alt="image-20220811132837147"></p>
<p><img data-src="/../image/GO%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/image-20220811132947262.png" alt="image-20220811132947262"></p>
<h3 id="2-使用命令行编译后运行"><a href="#2-使用命令行编译后运行" class="headerlink" title="2.使用命令行编译后运行"></a>2.使用命令行编译后运行</h3><p>在hello.go文件所在目录下</p>
<p><img data-src="/../image/GO%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/image-20220811133055504.png" alt="image-20220811133055504"></p>
<blockquote>
<p>Linux 系统环境下 GO命令行将编译后结果生成一个可执行二进制文件。</p>
<p>Windows 则会是.exe文件</p>
</blockquote>
<h1 id="一些理论"><a href="#一些理论" class="headerlink" title="一些理论"></a>一些理论</h1><h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><table>
<thead>
<tr>
<th>break</th>
<th>default</th>
<th>func</th>
<th>interface</th>
<th>select</th>
</tr>
</thead>
<tbody><tr>
<td>case</td>
<td>defer</td>
<td>go</td>
<td>map</td>
<td>struct</td>
</tr>
<tr>
<td>chan</td>
<td>else</td>
<td>goto</td>
<td>package</td>
<td>switch</td>
</tr>
<tr>
<td>const</td>
<td>fallthrough</td>
<td>if</td>
<td>range</td>
<td>type</td>
</tr>
<tr>
<td>continue</td>
<td>for</td>
<td>import</td>
<td>return</td>
<td>var</td>
</tr>
</tbody></table>
<h2 id="自带标识符"><a href="#自带标识符" class="headerlink" title="自带标识符"></a>自带标识符</h2><table>
<thead>
<tr>
<th>append</th>
<th>bool</th>
<th>byte</th>
<th>cap</th>
<th>close</th>
<th>complex</th>
<th>complex64</th>
<th>complex128</th>
<th>uint16</th>
</tr>
</thead>
<tbody><tr>
<td>copy</td>
<td>false</td>
<td>float32</td>
<td>float64</td>
<td>imag</td>
<td>int</td>
<td>int8</td>
<td>int16</td>
<td>uint32</td>
</tr>
<tr>
<td>int32</td>
<td>int64</td>
<td>iota</td>
<td>len</td>
<td>make</td>
<td>new</td>
<td>nil</td>
<td>panic</td>
<td>uint64</td>
</tr>
<tr>
<td>print</td>
<td>println</td>
<td>real</td>
<td>recover</td>
<td>string</td>
<td>true</td>
<td>uint</td>
<td>uint8</td>
<td>uintptr</td>
</tr>
</tbody></table>
<p>GO语言中，变量，函数，类等等程序实体不允许与自带标识符同名</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote>
<p><code>部分来源菜鸟教程</code><a href="https://m.runoob.com/go/go-data-types.html">https://m.runoob.com/go/go-data-types.html</a></p>
</blockquote>
<table>
<thead>
<tr>
<th>序号</th>
<th>类型和描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>布尔型</strong> 布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool &#x3D; true。</td>
</tr>
<tr>
<td>2</td>
<td><strong>数字类型</strong> 整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。</td>
</tr>
<tr>
<td>3</td>
<td><strong>字符串类型:</strong> 字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。</td>
</tr>
<tr>
<td>4</td>
<td><strong>派生类型:</strong> 包括： (a) 指针类型（Pointer）(b) 数组类型 (c) 结构化类型(struct) (d) Channel 类型 (e) 函数类型 (f) 切片类型 (g) 接口类型（interface） (h) Map 类型</td>
</tr>
</tbody></table>
<h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>Go 也有基于架构的类型，例如：int、uint 和 uintptr。</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>类型和描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>uint8</strong> 无符号 8 位整型 (0 到 255)</td>
</tr>
<tr>
<td>2</td>
<td><strong>uint16</strong> 无符号 16 位整型 (0 到 65535)</td>
</tr>
<tr>
<td>3</td>
<td><strong>uint32</strong> 无符号 32 位整型 (0 到 4294967295)</td>
</tr>
<tr>
<td>4</td>
<td><strong>uint64</strong> 无符号 64 位整型 (0 到 18446744073709551615)</td>
</tr>
<tr>
<td>5</td>
<td><strong>int8</strong> 有符号 8 位整型 (-128 到 127)</td>
</tr>
<tr>
<td>6</td>
<td><strong>int16</strong> 有符号 16 位整型 (-32768 到 32767)</td>
</tr>
<tr>
<td>7</td>
<td><strong>int32</strong> 有符号 32 位整型 (-2147483648 到 2147483647)</td>
</tr>
<tr>
<td>8</td>
<td><strong>int64</strong> 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</td>
</tr>
</tbody></table>
<h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><table>
<thead>
<tr>
<th>序号</th>
<th>类型和描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>float32</strong> IEEE-754 32位浮点型数</td>
</tr>
<tr>
<td>2</td>
<td><strong>float64</strong> IEEE-754 64位浮点型数</td>
</tr>
<tr>
<td>3</td>
<td><strong>complex64</strong> 32 位实数和虚数</td>
</tr>
<tr>
<td>4</td>
<td><strong>complex128</strong> 64 位实数和虚数</td>
</tr>
</tbody></table>
<hr>
<h3 id="其他数字类型"><a href="#其他数字类型" class="headerlink" title="其他数字类型"></a>其他数字类型</h3><p>以下列出了其他更多的数字类型：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>类型和描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>byte</strong> 类似 uint8</td>
</tr>
<tr>
<td>2</td>
<td><strong>rune</strong> 类似 int32</td>
</tr>
<tr>
<td>3</td>
<td><strong>uint</strong> 32 或 64 位</td>
</tr>
<tr>
<td>4</td>
<td><strong>int</strong> 与 uint 一样大小</td>
</tr>
<tr>
<td>5</td>
<td><strong>uintptr</strong> 无符号整型，用于存放一个指针</td>
</tr>
</tbody></table>
<h3 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h3><table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>byte&#x2F;utf8</td>
<td>1</td>
<td>单个UTF-8字符</td>
</tr>
<tr>
<td>rune</td>
<td>4</td>
<td>单个unicode字符</td>
</tr>
</tbody></table>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p>GO语言大小写敏感</p>
</li>
<li><p>在G语言中，给程序实体命名，不得使用@、$、%以及自带标识符与保留字</p>
</li>
<li><p>函数实体命名第一个字符必须是字母或_，不能是数字</p>
</li>
<li><p>只有package 名为 main 的包才被允许拥有main方法，一个可执行程序有且只有一个main包</p>
</li>
<li><p>import 只能导入非main包</p>
</li>
<li><p>GO语言无需像C或Java必须以;结尾</p>
</li>
</ul>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> 123</span></span><br><span class="line"><span class="comment"> 456</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>声明一个变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="type">float32</span> = <span class="number">12</span> + <span class="number">13</span>  <span class="comment">//var 变量名 类型 [= 表达式]  或 var 变量名 = 表达式   (将自动推断类型)</span></span><br></pre></td></tr></table></figure>

<p>批量声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	a <span class="type">int</span> = <span class="number">12</span></span><br><span class="line">	b <span class="type">string</span></span><br><span class="line">	c <span class="type">float32</span></span><br><span class="line">	d <span class="type">float64</span></span><br><span class="line">	e [<span class="number">5</span>]<span class="type">int</span> <span class="comment">//数组，后面说</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a,b,c = <span class="number">10</span>,<span class="number">20</span>,<span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">var</span> e,f,g <span class="type">int</span></span><br></pre></td></tr></table></figure>

<p>简短的声明方法（又叫初始化声明）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">10</span> + <span class="number">13</span>  <span class="comment">//将被自动推断类型，只能用于函数体内(局部变量)</span></span><br></pre></td></tr></table></figure>

<p>为什么叫初始化声明，因为如果该变量被声明过，则会<code>抛出异常</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span></span><br><span class="line">a := <span class="number">10</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">no new variables on left side of :=</span><br></pre></td></tr></table></figure>

<p><code>局部变量必须被使用</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a declared but not used</span><br></pre></td></tr></table></figure>

<h3 id="匿名变量"><a href="#匿名变量" class="headerlink" title="匿名变量"></a>匿名变量</h3><p>有的函数会返回多个值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span></span> (<span class="type">int</span>,<span class="type">int</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>,<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在GO中，你可以使用匿名变量接受它，然后不使用，匿名函数是不消耗内存的，这样就相当于丢弃了其中一个返回值，而不需要消耗额外的资源</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a, _ ：= test()   <span class="comment">//丢弃1</span></span><br><span class="line">_, b ：= test()   <span class="comment">//丢弃2</span></span><br></pre></td></tr></table></figure>

<h2 id="GO语言的多重赋值"><a href="#GO语言的多重赋值" class="headerlink" title="GO语言的多重赋值"></a>GO语言的多重赋值</h2><p>之前要交换a,b值我们要使用中间变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> tmp = a</span><br><span class="line">a = b</span><br><span class="line">b = tmp</span><br></pre></td></tr></table></figure>

<p>或是使用算法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line">a = a ^ b</span><br><span class="line">b = b ^ a</span><br><span class="line">a = a ^ b</span><br></pre></td></tr></table></figure>

<p>在GO语言，你这些都不要,你只需要</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">20</span></span><br><span class="line">a, b = b, a</span><br></pre></td></tr></table></figure>

<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>声明(联系变量)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> b <span class="type">int64</span></span><br><span class="line"><span class="keyword">const</span> c,d,e = <span class="number">10</span>,<span class="number">20</span>,<span class="string">&quot;abc&quot;</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	a = <span class="number">10</span></span><br><span class="line">    b <span class="type">int</span>	</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="常量的枚举"><a href="#常量的枚举" class="headerlink" title="常量的枚举"></a>常量的枚举</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		a = <span class="number">10</span></span><br><span class="line">		b = <span class="string">&quot;c会学我&quot;</span></span><br><span class="line">		c</span><br><span class="line">	)</span><br><span class="line">	fmt.Println(a, b, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10 c会学我 c会学我</span><br></pre></td></tr></table></figure>

<p>以这种方式定义的常量，若无初始值和类型，则会与上一个<code>非空</code>的常量值相同</p>
<h3 id="iota常量"><a href="#iota常量" class="headerlink" title="iota常量"></a>iota常量</h3><p>iota常量初始值为了，每出现一个const常量，iota常量会被编译器自增1（但程序无法修改它）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">const</span> (</span><br><span class="line">		a = <span class="literal">iota</span></span><br><span class="line">		b = <span class="literal">iota</span></span><br><span class="line">		c = <span class="string">&quot;不一定要赋值才会自增&quot;</span></span><br><span class="line">		d = <span class="literal">iota</span></span><br><span class="line">	)</span><br><span class="line">	fmt.Println(a, b, c, d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 1 不一定要赋值才会自增 3</span><br></pre></td></tr></table></figure>

<p><code>iota只能在常量声明时出现，不能直接用，例如放在Println方法内</code></p>
<h2 id="类型别名与定义新的类型定义"><a href="#类型别名与定义新的类型定义" class="headerlink" title="类型别名与定义新的类型定义"></a>类型别名与定义新的类型定义</h2><p>取一个类型别名</p>
<p>别名就像一个外号，都是同一个人</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> String = <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="type">string</span> = <span class="string">&quot;aa&quot;</span></span><br><span class="line">	<span class="keyword">var</span> b String = <span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure>

<p>定义个新类</p>
<p>再来一个新的一个人，只不过这两个一样</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> String <span class="type">string</span></span><br><span class="line">	<span class="keyword">var</span> a <span class="type">string</span> = <span class="string">&quot;aa&quot;</span></span><br><span class="line">	<span class="keyword">var</span> b String = <span class="string">&quot;bb&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在Go 1.9之前，没有别名，定义新类的方法是 type 新类型名 &#x3D; 类型名</p>
<p>与现在取别名一致</p>
</blockquote>
<blockquote>
<p>类型别名在编译后将去除，因为别名与原名是同一个东西，GO只会保留原先的</p>
</blockquote>
<blockquote>
<p>别名主要作用还是用于解决程序兼容性的问题</p>
</blockquote>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><blockquote>
<p>恕我 + - * &#x2F; &#x3D;&#x3D; &gt;&#x3D; &lt;&#x3D; !&#x3D; &lt; &gt; | || &amp; &amp;&amp; ！&gt;&gt; &lt;&lt; <code>忽略</code> 这些与其他语言一致,将写不常见的</p>
</blockquote>
<p>若 a &#x3D;&#x3D; 1;b &#x3D;&#x3D; 2</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>++</td>
<td>自增</td>
<td>a ++  结果 2</td>
</tr>
<tr>
<td>–</td>
<td>自减</td>
<td>a – 结果 0</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>相加后赋值</td>
<td></td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>相减后赋值</td>
<td></td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>相乘后赋值</td>
<td></td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>相除后赋值</td>
<td></td>
</tr>
<tr>
<td>&lt;&lt;&#x3D; | &gt;&gt;&#x3D;</td>
<td>位移后赋值</td>
<td></td>
</tr>
<tr>
<td>&amp;&#x3D;</td>
<td>按位与后赋值</td>
<td></td>
</tr>
<tr>
<td>^&#x3D;</td>
<td>按位异或后赋值</td>
<td></td>
</tr>
<tr>
<td>! &#x3D;  (连起来)</td>
<td>按位或后赋值</td>
<td></td>
</tr>
<tr>
<td>&amp;</td>
<td>也可是输出存储地址</td>
<td>&amp;a</td>
</tr>
<tr>
<td>*</td>
<td>也可是表指针变量</td>
<td>*a</td>
</tr>
</tbody></table>
<h2 id="优先级（由上往下，从大到小）"><a href="#优先级（由上往下，从大到小）" class="headerlink" title="优先级（由上往下，从大到小）"></a>优先级（由上往下，从大到小）</h2><table>
<thead>
<tr>
<th align="center">运算符</th>
</tr>
</thead>
<tbody><tr>
<td align="center">^ !</td>
</tr>
<tr>
<td align="center">&#x2F; * % &lt;&lt; &gt;&gt; &amp; &amp;^</td>
</tr>
<tr>
<td align="center">+ - | ^</td>
</tr>
<tr>
<td align="center">&#x3D;&#x3D; !&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D; &gt;&#x3D; &lt;&#x3D; 以及其他xx后赋值</td>
</tr>
<tr>
<td align="center">&lt;-</td>
</tr>
<tr>
<td align="center">&amp;&amp;</td>
</tr>
<tr>
<td align="center">||</td>
</tr>
</tbody></table>
<h1 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h1><h2 id="IF语句（不多赘述）"><a href="#IF语句（不多赘述）" class="headerlink" title="IF语句（不多赘述）"></a>IF语句（不多赘述）</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="literal">false</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">			<span class="comment">/**/</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="number">1</span>+<span class="number">1</span> == <span class="number">3</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;不可能，绝对不可能&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/**/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SWITCH语句（不多赘述）"><a href="#SWITCH语句（不多赘述）" class="headerlink" title="SWITCH语句（不多赘述）"></a>SWITCH语句（不多赘述）</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> score = <span class="number">90</span></span><br><span class="line"><span class="keyword">var</span> msg <span class="type">string</span></span><br><span class="line"><span class="keyword">switch</span> &#123; <span class="comment">//相当于  switch true  你也可以使用switch xxx csae 1 这种</span></span><br><span class="line"><span class="keyword">case</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">    msg = <span class="string">&quot;优秀&quot;</span></span><br><span class="line"><span class="keyword">case</span> score &gt;= <span class="number">75</span> &amp;&amp; score &lt; <span class="number">90</span>:</span><br><span class="line">    msg = <span class="string">&quot;良好&quot;</span></span><br><span class="line"><span class="keyword">case</span> score &gt;= <span class="number">60</span> &amp;&amp; score &lt; <span class="number">75</span>:</span><br><span class="line">    msg = <span class="string">&quot;及格&quot;</span></span><br><span class="line"><span class="keyword">case</span> score &lt; <span class="number">60</span>:</span><br><span class="line">    msg = <span class="string">&quot;不及格&quot;</span></span><br><span class="line"><span class="keyword">default</span>: <span class="comment">//都不满足</span></span><br><span class="line">    msg = <span class="string">&quot;无数据&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h2><p>类似SWITCH语句，不一样的是SELECT会随机执行<code>一个</code>满足条件的case，如果一个都没有，就会将其堵塞，直到有满足条件的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		ch1 &lt;- <span class="number">100</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		num2 := &lt;-ch2</span><br><span class="line">		fmt.Println(num2)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> num1 := &lt;-ch1: <span class="comment">//读取channel数据</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;ch1中的数据是:&quot;</span>, num1)</span><br><span class="line">	<span class="keyword">case</span> ch2 &lt;- <span class="string">&quot;201&quot;</span>: <span class="comment">//channel写入数据</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;ch2有数据写入&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">201</span><br><span class="line">ch2有数据写入</span><br></pre></td></tr></table></figure>

<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><blockquote>
<p>go语言没有while循环</p>
</blockquote>
<h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>语法类似JS</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= i; j++ &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot; %d * %d = %d&quot;</span>, j, i, j*i)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 * 1 = 1</span><br><span class="line">1 * 2 = 2 2 * 2 = 4</span><br><span class="line">1 * 3 = 3 2 * 3 = 6 3 * 3 = 9</span><br><span class="line">1 * 4 = 4 2 * 4 = 8 3 * 4 = 12 4 * 4 = 16</span><br><span class="line">1 * 5 = 5 2 * 5 = 10 3 * 5 = 15 4 * 5 = 20 5 * 5 = 25</span><br><span class="line">1 * 6 = 6 2 * 6 = 12 3 * 6 = 18 4 * 6 = 24 5 * 6 = 30 6 * 6 = 36</span><br><span class="line">1 * 7 = 7 2 * 7 = 14 3 * 7 = 21 4 * 7 = 28 5 * 7 = 35 6 * 7 = 42 7 * 7 = 49</span><br><span class="line">1 * 8 = 8 2 * 8 = 16 3 * 8 = 24 4 * 8 = 32 5 * 8 = 40 6 * 8 = 48 7 * 8 = 56 8 * 8 = 64</span><br><span class="line">1 * 9 = 9 2 * 9 = 18 3 * 9 = 27 4 * 9 = 36 5 * 9 = 45 6 * 9 = 54 7 * 9 = 63 8 * 9 = 72 9 * 9 = 81</span><br></pre></td></tr></table></figure>

<p><strong>遍历我后面讲</strong></p>
<h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h3><h4 id="break语句"><a href="#break语句" class="headerlink" title="break语句"></a>break语句</h4><p>结束循环(不多赘述)</p>
<h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>跳过这圈循环(不多赘述)</p>
<h4 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h4><p>无条件跳转到某一标签所在行</p>
<p>(CMD有类似的写法)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line">A:   <span class="comment">//标签</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;位置A&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> num == <span class="number">3</span> &#123;</span><br><span class="line">		<span class="keyword">goto</span> B   <span class="comment">//无条件跳转到标签A所在行</span></span><br><span class="line">	&#125;</span><br><span class="line">	num++</span><br><span class="line">	<span class="keyword">goto</span> A</span><br><span class="line">B:</span><br><span class="line">	fmt.Println(<span class="string">&quot;跳转到B&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">位置A</span><br><span class="line">位置A</span><br><span class="line">位置A</span><br><span class="line">位置A</span><br><span class="line">跳转到B</span><br></pre></td></tr></table></figure>

<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//func 函数名 (参数列表) (返回值列表) &#123;&#125;    || 若相邻参数数据类型一致，只需在最后一个指定类型即可</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span> <span class="params">(a,b <span class="type">int</span>, c ... <span class="type">string</span>)</span></span> (<span class="type">int</span>,<span class="type">string</span>)&#123;    <span class="comment">//c为不定长参数</span></span><br><span class="line">	<span class="keyword">return</span> a + b , <span class="string">&quot;&quot;</span>    <span class="comment">//不像Python返回一个列表，这是真真切切的两个值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实在GO语言中，函数也是一种类型，可以被保存在变量中（有点像Scala，只不过Scala函数不是类型）</p>
</blockquote>
<p>返回值列表不仅仅可以放返回数据类型，还可以带上名称</p>
<p>这时候返回值就是一个局部变量，最后只需一个return就可以自动将变量值返回</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(mySum(<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySum</span><span class="params">(num1 <span class="type">int</span>, num2 <span class="type">int</span>)</span></span> (sum <span class="type">int</span>) &#123;</span><br><span class="line">	sum = num1 + num2</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure>



<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>函数内定义的变量叫局部变量，局部变量仅作用与该函数题内，生命周期与该函数相同</p>
<p>函数外定义的叫全局变量，全局变量作用与整个包甚至外部包吗，所以之前与main函数相同</p>
<p>GO允许局部变量与某一全局变量同名，在局部变量所在的函数体内，局部变量优先级高于全局变量</p>
<p>意思作用于对常量，类型，函数皆适用</p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := <span class="function"><span class="keyword">func</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(msg)</span><br><span class="line">	&#125;</span><br><span class="line">	f(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<p>也可以这样用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">(msg <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">		fmt.Println(msg)</span><br><span class="line">	&#125;(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<blockquote>
<p>个人觉得没有Scala灵活</p>
</blockquote>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包严格意义上不算是函数，函数内部可执行的代码在函数定义时就被实现，且不会随程序的运行额发生改变，且一个函数通常只有一个实例</p>
<p>闭包在运行是可以有多个实例，不同的引用环境会生产多个实例</p>
<p>闭包在有些变成语言里面叫lambda表达式(熟悉了吧)</p>
<p>函数本身不具有记忆性，而与环境结合的闭包才具有记忆性(<code>下面有实验</code>)</p>
<p>函数是编译器静态的概念，闭包是运行期间的动态的概念</p>
<p>也不是所有的变成语言都支持闭包，闭包需依赖语言的以下特性</p>
<ul>
<li>函数是一等公民，及函数可以作为另一个函数的参数或返回值（高阶函数的概念），还可以作为一个变量的值</li>
<li>函数之间可以嵌套定义</li>
<li>支持匿名函数</li>
<li>可以捕获运行时上下文环境，并支持吧函数和环境组合成一个可调用的实体</li>
</ul>
<h3 id="对比实验（记忆性）"><a href="#对比实验（记忆性）" class="headerlink" title="对比实验（记忆性）"></a>对比实验（记忆性）</h3><p>无闭包</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">		fmt.Println(myAdd(i))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAdd</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	sum += num</span><br><span class="line">	<span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>闭包</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	f := myAdd()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">		fmt.Println(f(i)) <span class="comment">//每个小循环又是一个实例</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myAdd</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">//分开看  返回一个函数</span></span><br><span class="line">	sum := <span class="number">0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="comment">//返回一个匿名函数</span></span><br><span class="line">		sum += num</span><br><span class="line">		<span class="keyword">return</span> sum</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">10</span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>可变参数及可接受不确定的参数数量，当一个函数参数数量不确定，但确定参数的数据类型时，就可以使用可变参数</p>
<p>可变参数在GO中使用 <code>...</code> 表示</p>
<p><code>可变参数必须写在最后,且一个函数只能有一个可变参数</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	sum := mySum(<span class="number">10</span>, <span class="number">12</span>, <span class="number">15</span>)</span><br><span class="line">	fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySum</span><span class="params">(num ...<span class="type">int</span>)</span></span> (sum <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">for</span> _, n := <span class="keyword">range</span> num &#123; <span class="comment">//for index,value := range num  遍历我后面讲</span></span><br><span class="line">		sum += n</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">37</span><br></pre></td></tr></table></figure>

<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>递归，就是函数内部调用函数本身</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(factorial(<span class="number">3</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">factorial</span><span class="params">(n <span class="type">int</span>)</span></span> (<span class="type">int</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> n * factorial(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>一个保存了 另一个变量 的 内存地址 的 变量</p>
<h3 id="声明指针"><a href="#声明指针" class="headerlink" title="声明指针"></a>声明指针</h3><p>与声明变量极为类似</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a *<span class="type">int</span>   <span class="comment">//在数据类型前加*，数据类型是被指向变量的数据类型</span></span><br></pre></td></tr></table></figure>

<h3 id="如何给指针赋值"><a href="#如何给指针赋值" class="headerlink" title="如何给指针赋值"></a>如何给指针赋值</h3><p>还记得前面提到的运算符中<code>&amp;</code>符号还可以表示返回某个元素的内存地址吗？？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a *<span class="type">int</span>   <span class="comment">//在数据类型前加*，数据类型是被指向变量的数据类型</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">12</span></span><br><span class="line">a = &amp;num</span><br><span class="line"><span class="comment">//结合以往知识点，指针还可以这样声明(作用域：局部)</span></span><br><span class="line">a1 := &amp;num</span><br></pre></td></tr></table></figure>

<h3 id="空指针"><a href="#空指针" class="headerlink" title="空指针"></a>空指针</h3><p>但一个指针被声明但未被赋值，就是空指针</p>
<p>空指针值为<code>nil</code></p>
<h3 id="使用指针"><a href="#使用指针" class="headerlink" title="使用指针"></a>使用指针</h3><p>我前面也提到过，<code>*指针名</code>可以表示指针指向的变量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num := <span class="number">10</span></span><br><span class="line">	a := &amp;num</span><br><span class="line">	*a = <span class="number">12</span>   <span class="comment">//*指针名表示指针指向的变量,间接修改了变量</span></span><br><span class="line">	fmt.Println(*a)   <span class="comment">//指针也可作为参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure>

<h3 id="指针的指针"><a href="#指针的指针" class="headerlink" title="指针的指针"></a>指针的指针</h3><p>一个指针指向一个指向元素的指针</p>
<p>在使用的时候需要多个<code>*</code></p>
<p>例如</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	num := <span class="number">10</span></span><br><span class="line">	a := &amp;num</span><br><span class="line">	b := &amp;a</span><br><span class="line">	**b = <span class="number">12</span> <span class="comment">//分开看 * *b | **b ==&gt; *a ==&gt; num</span></span><br><span class="line">	fmt.Println(**b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure>

<p>指针的指针的指针同理，理解就行，我就不套娃了</p>
<h3 id="浅拷贝与深拷贝"><a href="#浅拷贝与深拷贝" class="headerlink" title="浅拷贝与深拷贝"></a>浅拷贝与深拷贝</h3><p>将<code>指针</code>赋值给别人叫<code>浅</code>拷贝</p>
<p>浅拷贝只复制了一份指向自己内存地址的指针，所以在修改副本的时候会影响真身</p>
<p>将<code>值</code>类型赋值给别人叫<code>深</code>拷贝</p>
<p>深拷贝值将内容复制给了一个新的内存位置，所以在修改副本时不改变真身</p>
<h1 id="容器-集合"><a href="#容器-集合" class="headerlink" title="容器(集合)"></a>容器(集合)</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var 数组名 [数组长度] 数据类型 &#123;[初始元素]&#125;    //一维简化</span><br><span class="line">var 数组名 [维度1长度][ [维度2长度] ... ] 数据类型 &#123; &#123;[维度1初始元素]&#125; , [&#123;[维度2初始元素]&#125;] ... &#125;</span><br></pre></td></tr></table></figure>

<p><code>数组长度的方括号不可省略</code></p>
<p>若不指定数据长度，可省略不写,GO将按照初始元素的数量指定数组长度,这种声明方法在Go中称为<code>切片</code></p>
<p>可以将数组长度写成<code>...</code>效果同上，只不过这次声明的是<code>数组</code></p>
<h3 id="长度"><a href="#长度" class="headerlink" title="长度"></a>长度</h3><p>长度使用只带len()函数获取</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数组中 长度与容量相同，使用GO语言有个cap()函数，在数组中，与len()结果相同，具体在下方遍历章节有实验</p>
</blockquote>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>可以使用[index]访问</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	fmt.Println(a[<span class="number">1</span>])</span><br><span class="line">	b := [<span class="number">2</span>][<span class="number">3</span>]<span class="type">int</span>&#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;&#125;</span><br><span class="line">	fmt.Println(b[<span class="number">1</span>][<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>GO中，通过声明一个未指定长度的数组来定义切片</p>
<p>虽然不定义长度，但容量还是有限</p>
<p><code>GO不支持负数下标</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	fmt.Println(a[:])   <span class="comment">//所有元素</span></span><br><span class="line">	fmt.Println(a[<span class="number">1</span>:])  <span class="comment">//下标为1到最后一个元素</span></span><br><span class="line">	fmt.Println(a[:<span class="number">3</span>])  <span class="comment">//起始元素到下标为3的元素(不包含)</span></span><br><span class="line">	fmt.Println(a[<span class="number">1</span>:<span class="number">3</span>]) <span class="comment">//下标为1到下标为3的元素(不包含)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1 2 3 4 5]</span><br><span class="line">[2 3 4 5]</span><br><span class="line">[1 2 3]</span><br><span class="line">[2 3]</span><br></pre></td></tr></table></figure>

<p>返回的切片不是数组，它只是数组的一种引用，<code>对切片的操作会映射到原数组上</code></p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">	<span class="comment">//方法1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">		fmt.Print(a[i], <span class="string">&quot; &quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;\n---------&quot;</span>)</span><br><span class="line">	<span class="comment">//方法2</span></span><br><span class="line">	<span class="comment">//indexd 或 value 可使用匿名变量丢弃 常写作 for _, value := range xxx</span></span><br><span class="line">	<span class="keyword">for</span> index, value := <span class="keyword">range</span> a &#123;</span><br><span class="line">		fmt.Print(<span class="string">&quot;i:&quot;</span>, index, <span class="string">&quot;;v:&quot;</span>, value, <span class="string">&quot; &quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;\n---------&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//多维(上面两种方法都行)</span></span><br><span class="line">	c := [<span class="number">3</span>][<span class="number">3</span>]<span class="type">int</span>&#123;</span><br><span class="line">		&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">		&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;,</span><br><span class="line">		&#123;<span class="number">7</span>, <span class="number">8</span>&#125;, <span class="comment">//需要,   //这里我故意留一个空，使得数组的一个元素每个初始值</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, v1 := <span class="keyword">range</span> c &#123;</span><br><span class="line">		<span class="keyword">for</span> _, v2 := <span class="keyword">range</span> v1 &#123;</span><br><span class="line">			fmt.Print(v2, <span class="string">&quot; &quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 2 3 </span><br><span class="line">---------</span><br><span class="line">i:0;v:1 i:1;v:2 i:2;v:3 </span><br><span class="line">---------</span><br><span class="line">1 2 3 4 5 6 7 8 0     //使用int类型的默认值0填充</span><br></pre></td></tr></table></figure>

<p>该语法同样适用于其他集合，包括<code>字符串</code></p>
<h3 id="修改数组"><a href="#修改数组" class="headerlink" title="修改数组"></a>修改数组</h3><h4 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h4><p>append()方法会返回一个在原<code>切片</code>的基础上追加了元素的<code>切片</code></p>
<p>使用append()方法向<code>切片</code>末尾追加一个或多个元素</p>
<blockquote>
<p>这里为什么是切片，结合之前的实验，以及数组特性，数组是定长的，数组空值会自动按数据类型默认值补齐，所以，理论上<code>无法追加</code>！！！</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">	a = <span class="built_in">append</span>(a, <span class="number">6</span>)           <span class="comment">//追加元素</span></span><br><span class="line">	a = <span class="built_in">append</span>(a, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>) <span class="comment">//追加多个元素</span></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1 2 3 4 5 6 7 8 9 10]</span><br></pre></td></tr></table></figure>

<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><blockquote>
<p>这里吐槽GO，切片的删除没有提供方法实现。切片元素的删除我分为两类</p>
</blockquote>
<ol>
<li>掐头去尾</li>
</ol>
<p>删除头尾可以直接使用下标进行切片操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	a = a[<span class="number">2</span>:]           <span class="comment">//去前两个</span></span><br><span class="line">	a = a[:<span class="built_in">len</span>(a)<span class="number">-2</span>]    <span class="comment">//去后两个</span></span><br><span class="line">	a = a[<span class="number">2</span> : <span class="built_in">len</span>(a)<span class="number">-2</span>] <span class="comment">//头尾都去两个</span></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[5]</span><br></pre></td></tr></table></figure>

<hr>

<ol start="2">
<li>去任意某个</li>
</ol>
<p>这就有点特殊，在此之前，先拓展一个方法 <code>...</code>,语法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">数组或切片...</span><br></pre></td></tr></table></figure>

<p>…在GO语言中的地位相当于Scala的_,是该语言的<code>语法糖</code></p>
<p>在GO语言中，<code>...</code>有两个意思，一为不定长，这在函数定义上提到过。二为打散某个集合再传递</p>
<p>GO语言无法直接拼接两个切片，append()方法添加多个元素必须传递在其不定长参数上，怎么办，只能打散再传递。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	a = <span class="built_in">append</span>(a[:<span class="number">5</span>], a[<span class="number">5</span>+<span class="number">1</span>:]...) <span class="comment">//去下标5</span></span><br><span class="line">	a = <span class="built_in">append</span>(a[:<span class="number">2</span>], a[<span class="number">4</span>+<span class="number">1</span>:]...) <span class="comment">//再去下标234</span></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1 2 7 8 9]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>事实证明，GO语言没Scala好用</p>
</blockquote>
<h4 id="复制元素"><a href="#复制元素" class="headerlink" title="复制元素"></a>复制元素</h4><p>copy()方法可以将一个切片的元素复制到另一个切片，由于上面提到的原因，所以数组还是不能使用copy()方法</p>
<p>copy()方法复制元素遵循如下规则</p>
<ul>
<li>复制的元素会放在原来的位置(1,2,3 替换了11，12，13)</li>
<li>要是被复制到的切片容量不足，那就只会复制能装得下的前几个(只复制1，2，3)</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">	b := []<span class="type">int</span>&#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>&#125;</span><br><span class="line">	count := <span class="built_in">copy</span>(b, a)    <span class="comment">//coty方法将返回复制的元素数量   //注意方向，这个写法是a-&gt;b</span></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	fmt.Println(count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1 2 3 4 5 6 7 8 9]</span><br><span class="line">[1 2 3 4 5 6 7 8 9 4 4 4]</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<h2 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h2><p>哈希表，键值对，数据结构我不多叙述</p>
<h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var 变量名 = map [key类型] value类型 &#123;[k1:v1, k2:v2 ....]&#125;              //不初始化，值为nil</span><br><span class="line">或</span><br><span class="line">var 变量名 = make (map [key类型] value类型)                             //不初始化，值非nil</span><br></pre></td></tr></table></figure>

<blockquote>
<p>[key类型] 不代表可省略，而是key类型需放在[]中</p>
</blockquote>
<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">		<span class="string">&quot;李二狗&quot;</span>: <span class="number">12</span>,</span><br><span class="line">		<span class="string">&quot;张三猫&quot;</span>: <span class="number">13</span>,     <span class="comment">//不可省略，</span></span><br><span class="line">	&#125;</span><br><span class="line">	a[<span class="string">&quot;李四牛&quot;</span>] = <span class="number">15</span></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map[张三猫:13 李二狗:12 李四牛:15]</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除可以使用delete()方法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">		<span class="string">&quot;李二狗&quot;</span>: <span class="number">12</span>,</span><br><span class="line">		<span class="string">&quot;张三猫&quot;</span>: <span class="number">13</span>, <span class="comment">//不可省略，</span></span><br><span class="line">	&#125;</span><br><span class="line">	a[<span class="string">&quot;李四牛&quot;</span>] = <span class="number">15</span></span><br><span class="line">	<span class="built_in">delete</span>(a, <span class="string">&quot;李四牛&quot;</span>) <span class="comment">//只能一个个来</span></span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map[张三猫:13 李二狗:12]</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">		<span class="string">&quot;李二狗&quot;</span>: <span class="number">12</span>,</span><br><span class="line">		<span class="string">&quot;张三猫&quot;</span>: <span class="number">13</span>, <span class="comment">//不可省略，</span></span><br><span class="line">	&#125;</span><br><span class="line">	a[<span class="string">&quot;李四牛&quot;</span>] = <span class="number">15</span></span><br><span class="line">	fmt.Println(a[<span class="string">&quot;李四牛&quot;</span>])</span><br><span class="line">	fmt.Println(a[<span class="string">&quot;王五虎&quot;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查不到将返回该值类型的默认值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">		<span class="string">&quot;李二狗&quot;</span>: <span class="number">12</span>,</span><br><span class="line">		<span class="string">&quot;张三猫&quot;</span>: <span class="number">13</span>,      <span class="comment">//不可省略，</span></span><br><span class="line">	&#125;</span><br><span class="line">	a[<span class="string">&quot;李四牛&quot;</span>] = <span class="number">15</span></span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> a &#123; <span class="comment">//v可省略</span></span><br><span class="line">		fmt.Println(k, v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">李二狗 12</span><br><span class="line">张三猫 13</span><br><span class="line">李四牛 15</span><br></pre></td></tr></table></figure>

<h1 id="常用包"><a href="#常用包" class="headerlink" title="常用包"></a>常用包</h1><blockquote>
<p>详见<a href="https://studygolang.com/pkgdoc">https://studygolang.com/pkgdoc</a></p>
<p>来源<a href="https://github.com/polaris1119/pkgdoc/">https://github.com/polaris1119/pkgdoc/</a></p>
</blockquote>
<ul>
<li><a href="https://studygolang.com/static/pkgdoc/pkg/strings.htm">strings(字符串处理)</a></li>
<li><a href="https://studygolang.com/static/pkgdoc/pkg/strconv.htm">strconv(数据类型装换)</a></li>
<li><a href="https://studygolang.com/static/pkgdoc/pkg/regexp.htm">regexp(正则表达式)</a></li>
<li><a href="https://studygolang.com/static/pkgdoc/pkg/time.htm">time(时间相关)</a></li>
<li><a href="https://studygolang.com/static/pkgdoc/pkg/math.htm">math(数学相关)</a></li>
</ul>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><p>准确来说，Go语言没有类的概念，不过却有struct(结构体)和interface(接口)</p>
<h2 id="结构体-Scala样例类阉割版"><a href="#结构体-Scala样例类阉割版" class="headerlink" title="结构体(Scala样例类阉割版)"></a>结构体(Scala样例类阉割版)</h2><p>单一数据类型已无法满足现实的开发需求，于是GO语言提供了结构体来单一复杂的数据类型</p>
<p>结构体由相同或不同类型的数据结构组成</p>
<p>使用结构体需注意</p>
<ul>
<li>结构体的名称在一个包类不能重复</li>
<li>结构体的属性，也叫字段，在一个结构体类是唯一的</li>
<li>在定义结构体时，同类型的结构体可以写同一行</li>
<li>结构体在被实例化后才会被分配内存</li>
<li>结构体是一个值类型，而不是指针，将结构体作为参数传递到函数中，在函数中进行修改，不影响结构体本身</li>
<li>结构体可以作为参数以及返回值，其指针也一样</li>
</ul>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123; <span class="comment">//定义结构体</span></span><br><span class="line">	name, color <span class="type">string</span></span><br><span class="line">	age         <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//实例化方法1：</span></span><br><span class="line">	<span class="keyword">var</span> huahua = Cat&#123;name: <span class="string">&quot;花花&quot;</span>, color: <span class="string">&quot;三花&quot;</span>, age: <span class="number">5</span>&#125; <span class="comment">//不一定要都指定，这和Scala不同</span></span><br><span class="line">	fmt.Println(huahua.name)                          <span class="comment">//调用参数</span></span><br><span class="line">	<span class="comment">//实例化方法2：后面再给参数赋值</span></span><br><span class="line">	<span class="keyword">var</span> mimi Cat <span class="comment">//注意没有等号   等同于 mimi := Cat&#123;&#125;</span></span><br><span class="line">	mimi.name = <span class="string">&quot;咪咪&quot;</span></span><br><span class="line">	fmt.Println(mimi.name)</span><br><span class="line">	fmt.Println(mimi.age) <span class="comment">//为赋值的参数值为该类型的初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">花花</span><br><span class="line">咪咪</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="匿名结构体与匿名字段"><a href="#匿名结构体与匿名字段" class="headerlink" title="匿名结构体与匿名字段"></a>匿名结构体与匿名字段</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	res := <span class="keyword">struct</span> &#123;     <span class="comment">//无需type</span></span><br><span class="line">		a <span class="type">int</span>           <span class="comment">//参数</span></span><br><span class="line">		<span class="type">float32</span>			<span class="comment">//匿名参数（会使用类型名作为参数名，一个结构体内一个类型只能有一个匿名参数）</span></span><br><span class="line">	&#125;&#123;<span class="number">12</span>,<span class="number">0.12</span>&#125;          <span class="comment">//初始化参数值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套-聚合和继承"><a href="#嵌套-聚合和继承" class="headerlink" title="嵌套(聚合和继承)"></a>嵌套(聚合和继承)</h3><p>Go貌似没有传统意义上的继承</p>
<p>不过我们可以使用嵌套实现，在一个结构体内嵌套一个结构体，被嵌套的结构体与外层结构体的关系:</p>
<ul>
<li>聚合关系：一个结构体是另一个结构体的属性</li>
<li>继承关系：被嵌套结构体与外层结构体是是父子关系</li>
</ul>
<blockquote>
<p>GO语言其实没有继承，所以无法实现其他语言的许多操作</p>
<p>例如不能给蓝猫结构体某个参数初始值</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">type</span> BlueCat <span class="keyword">struct</span> &#123;</span><br><span class="line">	Cat   <span class="comment">//匿名就行</span></span><br><span class="line">	color <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//实例1</span></span><br><span class="line">	tom := BlueCat&#123;Cat&#123;<span class="string">&quot;汤姆&quot;</span>, <span class="number">5</span>&#125;, <span class="string">&quot;蓝&quot;</span>&#125;</span><br><span class="line">	<span class="comment">//实例2</span></span><br><span class="line">	blue := BlueCat&#123;&#125;</span><br><span class="line">	blue.name = <span class="string">&quot;布鲁&quot;</span></span><br><span class="line">	blue.age = <span class="number">6</span></span><br><span class="line">	blue.color = <span class="string">&quot;蓝&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>方法本质上是函数，只不过方法与函数在逻辑上不同</p>
<p>函数属于包，被包调用；方法属于某一结构体，通过结构体变量类调用</p>
<p>方法在定义的时候语法与函数类似，不过要指定属于那个结构体</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func (变量名 结构体名) 方法名 (参数列表) 返回值列表 &#123;</span><br><span class="line">	方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GO语言不支持类，方法是为了实现一些类似于类的功能</p>
<p>同名的方法可以在多个结构体上定义，所以以函数不同，方法是可以重名的</p>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现一个方法，这时候相当于有个Cat类，类里面有个方法叫printInFO()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cat Cat)</span></span> printInFo() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s几年%d岁了&quot;</span>, cat.name, cat.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//实例化一个结构体</span></span><br><span class="line">	tom := Cat&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">5</span>&#125;</span><br><span class="line">	tom.printInFo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tom几年5岁了</span><br></pre></td></tr></table></figure>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>方法会随着结构体的’继承’而被继承</p>
<p>即其中一匿名字段实现了一个方法，那这个方法就会被继承到该结构体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“继承”</span></span><br><span class="line"><span class="keyword">type</span> BlueCat <span class="keyword">struct</span> &#123;</span><br><span class="line">	Cat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现一个方法，这时候相当于有个Cat类，类里面有个方法叫printInFO()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cat Cat)</span></span> printInFo() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s几年%d岁了&quot;</span>, cat.name, cat.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//实例化一个结构体</span></span><br><span class="line">	tom := BlueCat&#123;Cat&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line">	tom.printInFo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tom几年6岁了</span><br></pre></td></tr></table></figure>

<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>若一结构体内的一匿名字段实现了一个方法，但结构体也实现了一个同名方法，那这方法就会被重写</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“继承”</span></span><br><span class="line"><span class="keyword">type</span> BlueCat <span class="keyword">struct</span> &#123;</span><br><span class="line">	Cat</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现一个方法，这时候相当于有个Cat类，类里面有个方法叫printInFO()</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cat Cat)</span></span> printInFo() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s几年%d岁了&quot;</span>, cat.name, cat.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BlueCat再实现一个同名方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cat BlueCat)</span></span> printInFo() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s几年%d岁了,它是一中蓝色的猫&quot;</span>, cat.name, cat.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//实例化一个结构体</span></span><br><span class="line">	tom := BlueCat&#123;Cat&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">6</span>&#125;&#125;</span><br><span class="line">	tom.printInFo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tom几年6岁了,它是一中蓝色的猫</span><br></pre></td></tr></table></figure>

<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>在GO语言中，任何定义了接口中所有方法的结构体就自动隐式实现了接口</p>
<blockquote>
<p>总感觉违背的接口的一些定义,怪怪的</p>
</blockquote>
<h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type 接口名 interface &#123;</span><br><span class="line">	方法1([参数列表]) [返回值]</span><br><span class="line">	方法2([参数列表]) [返回值]</span><br><span class="line">	.....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Cat <span class="keyword">interface</span> &#123;</span><br><span class="line">	printInFo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//“继承”</span></span><br><span class="line"><span class="keyword">type</span> BlueCat <span class="keyword">struct</span> &#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BlueCat再实现一个同名方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cat BlueCat)</span></span> printInFo() &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s几年%d岁了,它是一中蓝色的猫&quot;</span>, cat.name, cat.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//实例化一个结构体</span></span><br><span class="line">	tom := BlueCat&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">7</span>&#125;</span><br><span class="line">	tom.printInFo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p>空接口中没有任何方法，任何结构体都可以实现该接口，空接口类似以于Java以及Scala的object</p>
<h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><h2 id="error"><a href="#error" class="headerlink" title="error"></a>error</h2><p>error错误，程序出现了不正常的情况，一般用于自定义一个函数或方法可能发生的异常，将其返回</p>
<p>error在GO语言中本质是一个接口，其中包含Error()方法，错误值存储在变量中，最后通过该发放返回，返回的错误必须是某个函数或方法的最后一个返回值</p>
<p>在GO语言中，通常判断函数或方法是否发生了错误，可以对比该方法或函数返回值的最后一个值是不是nil，如果是，则未发生错误</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myMath</span><span class="params">(num1 <span class="type">float32</span>, num2 <span class="type">float32</span>)</span></span> (<span class="type">float32</span>, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> num2 == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;除数为0&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> num1 / num2, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	res, err := myMath(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(res)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="panic"><a href="#panic" class="headerlink" title="panic"></a>panic</h2><p>恐慌，程序出现了无法处理的灾难级的错误，通常程序在遇到无法处理的问题且没被recover拦截，将抛出painc</p>
<p>panic()是一个内建函数，当程序运行到这时，程序将被中断运行</p>
<p>与error不同，panic通常用于报告致命错误，例如在数组越界时</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(n <span class="type">int</span>)</span></span> &#123; <span class="comment">//放在函数，骗过编译器</span></span><br><span class="line">	a := [<span class="number">3</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">	a[n] = <span class="number">12</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	myFunc(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GO语言就会抛出一个panic而不是error</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">panic: runtime error: index out of range [10] with length 3</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.myFunc(0xa)</span><br><span class="line">	/home/canyue/Desktop/GOProject/hello.go:6 +0x52</span><br><span class="line">main.main()</span><br><span class="line">	/home/canyue/Desktop/GOProject/hello.go:10 +0x1e</span><br></pre></td></tr></table></figure>

<p>对比error返回的消息，panic抛出了错误将更为详细，那是因为panic的工作流程有关</p>
<p>当一行代码发生panic,GO会立即停止该行代码，然后将控制权转移到所在的函数或方法，然后该函数或方法内的代码将立即停止，控制权立即转移到其调用者以及上级调用者，直到最初调用。在此期间，panic会搜集详细消息，最终抛出</p>
<p>panic本质是一个内建函数，使用我们其实可以随时调用panic使得一个程序陷入恐慌，然后停止运行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(n <span class="type">int</span>)</span></span> &#123; <span class="comment">//放在函数，骗过编译器</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">	<span class="built_in">panic</span>(<span class="string">&quot;手动出发恐慌&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;程序不在执行到此&quot;</span>) <span class="comment">//VSC提示   unreachable code  遥不可及的，不会执行到这</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	myFunc(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DAP server listening at: 127.0.0.1:36413</span><br><span class="line">hello</span><br><span class="line">panic: 手动出发恐慌</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">main.myFunc(0xa)</span><br><span class="line">	/home/canyue/Desktop/GOProject/hello.go:8 +0x7e</span><br><span class="line">main.main()</span><br><span class="line">	/home/canyue/Desktop/GOProject/hello.go:13 +0x1e</span><br></pre></td></tr></table></figure>

<h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>defer用于延迟一个函数或方法，具体为如果一各函数有多个defer语句，GO会先执行没有带defer分语句，直到最后运行到最后一个defer语句时，再<code>逆序</code>执行所有带defer的语句</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">	<span class="keyword">defer</span> fmt.Println(<span class="string">&quot;4&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	myFunc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>虽然defer语句是运行到最后一句在一块运行的，不过，如果defer语句中有传参，那参数则是事先在到达该句时先赋值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(num <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="built_in">println</span>(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	n := <span class="number">1</span></span><br><span class="line">	<span class="keyword">defer</span> myFunc(n)</span><br><span class="line">	n++</span><br><span class="line">	myFunc(n)</span><br><span class="line">	n++</span><br><span class="line">	<span class="keyword">defer</span> myFunc(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>GO语言与Java、Scala的异常处理上有很大的不同</p>
<blockquote>
<p>因为GO语言的作者在觉得，将异常控制流程混在一起(try…catch…finally)会使代码变得混乱</p>
</blockquote>
<p>在上面提到了程序在发生panic时会导致程序恐慌奔溃，其实我们可以拦截panic，具体如下</p>
<h3 id="recover"><a href="#recover" class="headerlink" title="recover"></a>recover</h3><p>recover()本质是一个内建函数，在执行它时，会捕获panic的异常消息，并让程序正常运行(出现panic的函数会方法除外),如果程序正常运行,则返回nil</p>
<blockquote>
<p>不过要注意，recover只能在defer延迟语句内执行才会生效,且放在可能会抛出panic的代码执行顺序之后</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">()</span></span> &#123; <span class="comment">//放在函数，骗过编译器</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">//defer 用于延迟一个函数或方法，通常这会写一个匿名函数</span></span><br><span class="line">		msg := <span class="built_in">recover</span>()</span><br><span class="line">		<span class="keyword">if</span> msg != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;发生paincm,消息:%s&quot;</span>, msg)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">/*除数5到0，0会抛出异常*/</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">5</span>; i &gt;= <span class="number">-5</span>; i-- &#123;</span><br><span class="line">		fmt.Println(<span class="number">10</span> / i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	myFunc()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">10</span><br><span class="line">发生paincm,消息:runtime error: integer divide by zero</span><br></pre></td></tr></table></figure>

<blockquote>
<p>导致panic的函数或方法将不会继续执行</p>
</blockquote>
<h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><h2 id="键盘输入"><a href="#键盘输入" class="headerlink" title="键盘输入"></a>键盘输入</h2><p>类似Python的input</p>
<p>只需向Scanln()方法传递若干个指针，即可实现</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	name := <span class="string">&quot;&quot;</span></span><br><span class="line">	age := <span class="number">0</span></span><br><span class="line">	fmt.Scanln(&amp;name, &amp;age)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s几年%d岁了\n&quot;</span>, name, age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">canyue@workstation-CanYue:~/Desktop/GOProject$ ./hello</span><br><span class="line">小明 12</span><br><span class="line">小明几年12岁了</span><br></pre></td></tr></table></figure>

<blockquote>
<p>每个输入之间使用[空格]隔开</p>
<p>VSC的非调试运行会出问题</p>
</blockquote>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>在文件系统上的IO操作</p>
<h3 id="查询文件信息"><a href="#查询文件信息" class="headerlink" title="查询文件信息"></a>查询文件信息</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//字符串表示路径</span></span><br><span class="line">	path := <span class="string">&quot;./hello.sol&quot;</span> <span class="comment">//支持相对、绝对路径</span></span><br><span class="line">	<span class="comment">//Go语言中，文件或目录使用fileStat类型表示</span></span><br><span class="line">	stat, <span class="type">error</span> := os.Stat(path) <span class="comment">//通过os包中的stat返回两个数据，一是文件的消息，二是错误(前面提到过)</span></span><br><span class="line">	<span class="keyword">if</span> <span class="type">error</span> == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;数据类型: %T \n&quot;</span>, stat)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;文件名：%s \n&quot;</span>, stat.Name())</span><br><span class="line">		fmt.Printf(<span class="string">&quot;是否是一个目录:%t \n&quot;</span>, stat.IsDir())</span><br><span class="line">		fmt.Printf(<span class="string">&quot;文件权限：%s \n&quot;</span>, stat.Mode())</span><br><span class="line">		fmt.Printf(<span class="string">&quot;文件最后修改时间：%s \n&quot;</span>, stat.ModTime())</span><br><span class="line">		fmt.Printf(<span class="string">&quot;文件大小：%d bit\n&quot;</span>, stat.Size())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据类型: *os.fileStat </span><br><span class="line">文件名：hello.sol </span><br><span class="line">是否是一个目录:false </span><br><span class="line">文件权限：-rw-r--r-- </span><br><span class="line">文件最后修改时间：2022-08-19 14:28:06.674944276 +0800 CST </span><br><span class="line">文件大小：167 bit</span><br></pre></td></tr></table></figure>

<h3 id="创建与删除"><a href="#创建与删除" class="headerlink" title="创建与删除"></a>创建与删除</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//创建</span></span><br><span class="line">	err := os.Mkdir(<span class="string">&quot;./test&quot;</span>, os.ModeDir) <span class="comment">//创建文件夹</span></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;文件夹创建成功&quot;</span>)</span><br><span class="line">		<span class="comment">//递归生成文件夹</span></span><br><span class="line">		err2 := os.MkdirAll(<span class="string">&quot;canyue/go/test&quot;</span>, os.ModePerm)</span><br><span class="line">		<span class="keyword">if</span> err2 == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;递归生成成功&quot;</span>)</span><br><span class="line">		&#125; <span class="comment">//递归删除不会因为已存在而抛出异常</span></span><br><span class="line">		<span class="comment">//创建文件</span></span><br><span class="line">		file, err3 := os.Create(<span class="string">&quot;./test/canyue.txt&quot;</span>) <span class="comment">//返回该文件以及错误,已存在文件将覆盖</span></span><br><span class="line">		<span class="keyword">if</span> err3 == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;文件创建成功，内存地址：%v&quot;</span>, file)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;文件夹已存在&quot;</span>) <span class="comment">//已存在将抛出错误</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//删除</span></span><br><span class="line">	os.Remove(<span class="string">&quot;./test/canyue.txt&quot;</span>)</span><br><span class="line">	os.Remove(<span class="string">&quot;./test&quot;</span>) <span class="comment">//只能删除一个空目录</span></span><br><span class="line">	<span class="comment">//递归删除</span></span><br><span class="line">	os.RemoveAll(<span class="string">&quot;./canyue&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><h4 id="OS包实现"><a href="#OS包实现" class="headerlink" title="OS包实现"></a>OS包实现</h4><p>文件打开方式： os.关键字</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>模式</th>
</tr>
</thead>
<tbody><tr>
<td>O_RDONLY</td>
<td>只读(read-only)</td>
</tr>
<tr>
<td>O_WRONLY</td>
<td>只写(write-only)</td>
</tr>
<tr>
<td>O_RDWR</td>
<td>可读可写(read-write)</td>
</tr>
<tr>
<td>O_APPEND</td>
<td>追加写</td>
</tr>
<tr>
<td>O_CREATE</td>
<td>文件不存在时创建该文件</td>
</tr>
</tbody></table>
<p>打开方式之间可以使用 | 分隔，代表同时使用多个模式</p>
<p>通常与O_CREATE同时使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, err := os.OpenFile(<span class="string">&quot;./canyue.txt&quot;</span>, os.O_RDWR|os.O_CREATE, os.ModePerm) <span class="comment">//打开文件</span></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> file.Close() <span class="comment">//关闭文件,通常使用defer语句</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;文件打开成功&quot;</span>)</span><br><span class="line">		<span class="comment">//写入文件</span></span><br><span class="line">		n, err2 := file.Write([]<span class="type">byte</span>(<span class="string">&quot;你好\n我是残月&quot;</span>))</span><br><span class="line">		<span class="keyword">if</span> err2 == <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;文件写入成功，写入字节&quot;</span>, n)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;文件打开错误&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//OS包实现</span></span><br><span class="line">	file, err := os.OpenFile(<span class="string">&quot;./canyue.txt&quot;</span>, os.O_RDWR|os.O_CREATE, os.ModePerm) <span class="comment">//打开文件</span></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="comment">//读取文件</span></span><br><span class="line">		buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">512</span>) <span class="comment">//创建一个512字节的缓冲区</span></span><br><span class="line">		<span class="keyword">for</span> &#123;                    <span class="comment">//一次读一行</span></span><br><span class="line">			n, err3 := file.Read(buf) <span class="comment">//字节数，错误</span></span><br><span class="line">			<span class="keyword">if</span> n == <span class="number">0</span> || err3 != <span class="literal">nil</span> &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;打印完成&quot;</span>)</span><br><span class="line">				<span class="keyword">break</span></span><br><span class="line">			&#125;</span><br><span class="line">			fmt.Println(<span class="type">string</span>(buf[:n])) <span class="comment">//将缓冲区所有数据装换为字符串</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;文件打开错误&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你好</span><br><span class="line">我是残月</span><br><span class="line">打印完成</span><br></pre></td></tr></table></figure>

<h4 id="ioutil包实现"><a href="#ioutil包实现" class="headerlink" title="ioutil包实现"></a>ioutil包实现</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//打开刚刚的文件</span></span><br><span class="line">	data1, err1 := ioutil.ReadFile(<span class="string">&quot;./canyue.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err1 == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="type">string</span>(data1), <span class="string">&quot;\n------------&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;读取canyue.txt失败&quot;</span>, err1)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//无法读取不存在的文件</span></span><br><span class="line">	data2, err2 := ioutil.ReadFile(<span class="string">&quot;./canyue.md&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err2 == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="type">string</span>(data2), <span class="string">&quot;\n------------&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;读取canyue.md失败&quot;</span>, err2)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//写文件 （追加写入，不存在将会创建文件）</span></span><br><span class="line">	writeText01 := []<span class="type">byte</span>(<span class="string">&quot;文件001&quot;</span>) <span class="comment">//传入的是字节类型的数组</span></span><br><span class="line">	err := ioutil.WriteFile(<span class="string">&quot;./test/001.txt&quot;</span>, writeText01, os.ModePerm) == <span class="literal">nil</span></span><br><span class="line">	writeText02 := []<span class="type">byte</span>(<span class="string">&quot;文件002&quot;</span>)</span><br><span class="line">	err = ioutil.WriteFile(<span class="string">&quot;./test/002.txt&quot;</span>, writeText02, os.ModePerm) == <span class="literal">nil</span> &amp;&amp; err</span><br><span class="line">	writeText03 := []<span class="type">byte</span>(<span class="string">&quot;文件003&quot;</span>)</span><br><span class="line">	err = ioutil.WriteFile(<span class="string">&quot;./test/003.txt&quot;</span>, writeText03, os.ModePerm) == <span class="literal">nil</span> &amp;&amp; err</span><br><span class="line">	<span class="keyword">if</span> err &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;文件写入成功&quot;</span>)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;有文件写入失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">你好</span><br><span class="line">我是残月 </span><br><span class="line">------------</span><br><span class="line">读取canyue.md失败 open ./canyue.md: no such file or directory</span><br><span class="line">文件写入成功</span><br></pre></td></tr></table></figure>

<h1 id="原生网络编程"><a href="#原生网络编程" class="headerlink" title="原生网络编程"></a>原生网络编程</h1><p>常见HTTP代码</p>
<p><a href="https://http.cat/">https://http.cat/</a></p>
<p>RESTful规范</p>
<p><a href="https://blog.csdn.net/qq_26460841/article/details/119977022">https://blog.csdn.net/qq_26460841/article/details/119977022</a></p>
<p>一个Http测试网站</p>
<p><a href="http://httpbin.org/">http://httpbin.org</a></p>
<h2 id="JSON字符串转Map"><a href="#JSON字符串转Map" class="headerlink" title="JSON字符串转Map"></a>JSON字符串转Map</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//原数据</span></span><br><span class="line">	originData := <span class="string">`[&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:&quot;12&quot;,&quot;sex&quot;:&quot;男&quot;&#125;]`</span> <span class="comment">//`` 不转译字符串</span></span><br><span class="line">	<span class="comment">//解析后的数据</span></span><br><span class="line">	<span class="keyword">var</span> data []<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">	<span class="comment">//解析</span></span><br><span class="line">	json.Unmarshal([]<span class="type">byte</span>(originData), &amp;data)</span><br><span class="line">	fmt.Println(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[map[age:12 name:小明 sex:男]]</span><br></pre></td></tr></table></figure>

<h2 id="HTTP客户端"><a href="#HTTP客户端" class="headerlink" title="HTTP客户端"></a>HTTP客户端</h2><p>GO语言原生内置HTTP包net&#x2F;http</p>
<p>包内提供了最简介的HTTP客户端实现方式</p>
<h3 id="简单演示"><a href="#简单演示" class="headerlink" title="简单演示"></a>简单演示</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	httpRequest(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://httpbin.org/get&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//http请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpRequest</span><span class="params">(method <span class="type">string</span>, url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//创建客户端</span></span><br><span class="line">	client := http.Client&#123;&#125;</span><br><span class="line">	<span class="comment">//创建请求</span></span><br><span class="line">	request, err := http.NewRequest(method, url, <span class="literal">nil</span>)</span><br><span class="line">	checkError(err)</span><br><span class="line">	<span class="comment">//添加Cookie</span></span><br><span class="line">	cookieName := &amp;http.Cookie&#123;Name: <span class="string">&quot;n1&quot;</span>, Value: <span class="string">&quot;v1&quot;</span>&#125;</span><br><span class="line">	request.AddCookie(cookieName)</span><br><span class="line">	<span class="comment">//设置请求头</span></span><br><span class="line">	request.Header.Set(<span class="string">&quot;User-Agent&quot;</span>, <span class="string">&quot;Mozilla/5.0 (X11; Linux x86_64; rv:103.0) Gecko/20100101 Firefox/103.0&quot;</span>)</span><br><span class="line">	<span class="comment">//发送Do请求</span></span><br><span class="line">	response, err := client.Do(request)</span><br><span class="line">	checkError(err)</span><br><span class="line">	<span class="keyword">defer</span> response.Body.Close()</span><br><span class="line">	<span class="comment">//查看请求头数据</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;Header:&quot;</span>, request.Header)</span><br><span class="line">	<span class="comment">//查看状态</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;HTTPCode:&quot;</span>, response.StatusCode)</span><br><span class="line">	fmt.Println(<span class="string">&quot;HTTPState:&quot;</span>, response.Status)</span><br><span class="line">	<span class="comment">//操作数据</span></span><br><span class="line">	<span class="keyword">if</span> response.StatusCode == <span class="number">200</span> &#123;</span><br><span class="line">		data, err := ioutil.ReadAll(response.Body)</span><br><span class="line">		checkError(err)</span><br><span class="line">		fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;访问异常:&quot;</span>, response.Status)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Header: map[Cookie:[n1=v1] User-Agent:[Mozilla/5.0 (X11; Linux x86_64; rv:103.0) Gecko/20100101 Firefox/103.0]]</span><br><span class="line">HTTPCode: 200</span><br><span class="line">HTTPState: 200 OK</span><br><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;, </span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;gzip&quot;, </span><br><span class="line">    &quot;Cookie&quot;: &quot;n1=v1&quot;, </span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;, </span><br><span class="line">    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (X11; Linux x86_64; rv:103.0) Gecko/20100101 Firefox/103.0&quot;, </span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-630478c3-3b53d2801c6f0b190dab7480&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;origin&quot;: &quot;xxx.xxx.xxx.xxx&quot;, </span><br><span class="line">  &quot;url&quot;: &quot;http://httpbin.org/get&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h3><h4 id="client-Get"><a href="#client-Get" class="headerlink" title="client.Get()"></a>client.Get()</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	httpRequest(<span class="string">&quot;http://httpbin.org/get?param1=12&amp;param2=13&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//http请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpRequest</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//创建客户端</span></span><br><span class="line">	client := http.Client&#123;&#125;</span><br><span class="line">	<span class="comment">//发送请求</span></span><br><span class="line">	request, err := client.Get(url)</span><br><span class="line">	checkError(err)</span><br><span class="line">	<span class="keyword">defer</span> request.Body.Close()</span><br><span class="line">	<span class="comment">//处理返回</span></span><br><span class="line">	<span class="keyword">if</span> request.StatusCode == <span class="number">200</span> &#123;</span><br><span class="line">		data, err := ioutil.ReadAll(request.Body)</span><br><span class="line">		checkError(err)</span><br><span class="line">		fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(request.Status)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;</span><br><span class="line">    &quot;param1&quot;: &quot;12&quot;, </span><br><span class="line">    &quot;param2&quot;: &quot;13&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;gzip&quot;, </span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;, </span><br><span class="line">    &quot;User-Agent&quot;: &quot;Go-http-client/1.1&quot;, </span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-63047a79-1bcdea4942031af9214acd15&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;origin&quot;: &quot;xxx.xxx.xxx.xxx&quot;, </span><br><span class="line">  &quot;url&quot;: &quot;http://httpbin.org/get?param1=12,param2=13&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="http-Get"><a href="#http-Get" class="headerlink" title="http.Get()"></a>http.Get()</h4><blockquote>
<p>两者区别在，后者无需创建一个客户端，直接发送请求</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	httpRequest(<span class="string">&quot;http://httpbin.org/get?param1=12&amp;param2=13&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//http请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpRequest</span><span class="params">(url <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	request, err := http.Get(url)</span><br><span class="line">	checkError(err)</span><br><span class="line">	<span class="comment">//处理返回</span></span><br><span class="line">	<span class="keyword">if</span> request.StatusCode == <span class="number">200</span> &#123;</span><br><span class="line">		data, err := ioutil.ReadAll(request.Body)</span><br><span class="line">		checkError(err)</span><br><span class="line">		fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(request.Status)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查错误</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkError</span><span class="params">(err <span class="type">error</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;</span><br><span class="line">    &quot;param1&quot;: &quot;12&quot;, </span><br><span class="line">    &quot;param2&quot;: &quot;13&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;gzip&quot;, </span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;, </span><br><span class="line">    &quot;User-Agent&quot;: &quot;Go-http-client/1.1&quot;, </span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-63047b82-70e59d7d44c5bfe337698d64&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;origin&quot;: &quot;xxx.xxx.xxx.xxx&quot;, </span><br><span class="line">  &quot;url&quot;: &quot;http://httpbin.org/get?param1=12&amp;param2=13&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h3><h4 id="client-Post"><a href="#client-Post" class="headerlink" title="client.Post()"></a>client.Post()</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	params := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">		<span class="string">&quot;sex&quot;</span>:  <span class="string">&quot;男&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	httpRequest(<span class="string">&quot;http://httpbin.org/post&quot;</span>, params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//http请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpRequest</span><span class="params">(u <span class="type">string</span>, params <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//创建客户端</span></span><br><span class="line">	client := http.Client&#123;&#125;</span><br><span class="line">	<span class="comment">//处理请求参数</span></span><br><span class="line">	data := url.Values&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> params &#123;</span><br><span class="line">		data.Add(k, v)</span><br><span class="line">	&#125;</span><br><span class="line">	requestData := strings.NewReader(data.Encode())</span><br><span class="line">	<span class="comment">//发送请求</span></span><br><span class="line">	request, err := client.Post(</span><br><span class="line">		u,</span><br><span class="line">		<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,</span><br><span class="line">		requestData,</span><br><span class="line">	)</span><br><span class="line">	checkError(err)</span><br><span class="line">	<span class="comment">//处理返回</span></span><br><span class="line">	<span class="keyword">if</span> request.StatusCode == <span class="number">200</span> &#123;</span><br><span class="line">		data, err := ioutil.ReadAll(request.Body)</span><br><span class="line">		checkError(err)</span><br><span class="line">		fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(request.Status)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;, </span><br><span class="line">  &quot;data&quot;: &quot;&quot;, </span><br><span class="line">  &quot;files&quot;: &#123;&#125;, </span><br><span class="line">  &quot;form&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;\u5c0f\u660e&quot;, </span><br><span class="line">    &quot;sex&quot;: &quot;\u7537&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;gzip&quot;, </span><br><span class="line">    &quot;Content-Length&quot;: &quot;37&quot;, </span><br><span class="line">    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, </span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;, </span><br><span class="line">    &quot;User-Agent&quot;: &quot;Go-http-client/1.1&quot;, </span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-63047f1a-0523d8e45f53e8c311926ecd&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;json&quot;: null, </span><br><span class="line">  &quot;origin&quot;: &quot;xxx.xxx.xxx.xxx&quot;, </span><br><span class="line">  &quot;url&quot;: &quot;http://httpbin.org/post&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="http-Post"><a href="#http-Post" class="headerlink" title="http.Post()"></a>http.Post()</h4><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	params := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">		<span class="string">&quot;sex&quot;</span>:  <span class="string">&quot;男&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	httpRequest(<span class="string">&quot;http://httpbin.org/post&quot;</span>, params)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//http请求</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">httpRequest</span><span class="params">(u <span class="type">string</span>, params <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">//处理请求参数</span></span><br><span class="line">	data := url.Values&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> k, v := <span class="keyword">range</span> params &#123;</span><br><span class="line">		data.Add(k, v)</span><br><span class="line">	&#125;</span><br><span class="line">	requestData := strings.NewReader(data.Encode())</span><br><span class="line">	<span class="comment">//发送请求</span></span><br><span class="line">	request, err := http.Post(</span><br><span class="line">		u,                                          <span class="comment">//url</span></span><br><span class="line">		<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>,        <span class="comment">//第二个参数必须设置成&quot;application/x-www-form-urlencoded&quot;，否则post参数无法传递</span></span><br><span class="line">		requestData,</span><br><span class="line">	)</span><br><span class="line">	checkError(err)</span><br><span class="line">	<span class="comment">//处理返回</span></span><br><span class="line">	<span class="keyword">if</span> request.StatusCode == <span class="number">200</span> &#123;</span><br><span class="line">		data, err := ioutil.ReadAll(request.Body)</span><br><span class="line">		checkError(err)</span><br><span class="line">		fmt.Println(<span class="type">string</span>(data))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(request.Status)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;&#125;, </span><br><span class="line">  &quot;data&quot;: &quot;&quot;, </span><br><span class="line">  &quot;files&quot;: &#123;&#125;, </span><br><span class="line">  &quot;form&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;\u5c0f\u660e&quot;, </span><br><span class="line">    &quot;sex&quot;: &quot;\u7537&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;gzip&quot;, </span><br><span class="line">    &quot;Content-Length&quot;: &quot;37&quot;, </span><br><span class="line">    &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, </span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;, </span><br><span class="line">    &quot;User-Agent&quot;: &quot;Go-http-client/1.1&quot;, </span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-63047f69-1d941f48748d9bf60bceacc7&quot;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;json&quot;: null, </span><br><span class="line">  &quot;origin&quot;: &quot;xxx.xxx.xxx.xxx&quot;, </span><br><span class="line">  &quot;url&quot;: &quot;http://httpbin.org/post&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记分享</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>GO语言</tag>
      </tags>
  </entry>
  <entry>
    <title>Scala解析XML</title>
    <url>/article/Scala%E8%A7%A3%E6%9E%90XML/</url>
    <content><![CDATA[<p>本文主要了解如何使用Scala解析XML</p>
<span id="more"></span>

<h1 id="Scala-原生方法"><a href="#Scala-原生方法" class="headerlink" title="Scala 原生方法"></a>Scala 原生方法</h1><p>XML基本结构</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">school</span> <span class="attr">address</span>=<span class="string">&quot;联榕路8号&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">strdents</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xiaomin</span> <span class="attr">strId</span>=<span class="string">&quot;202012040293221&quot;</span> <span class="attr">sex</span>=<span class="string">&quot;男&quot;</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">xiaomin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xiaohua</span> <span class="attr">strId</span>=<span class="string">&quot;202012040293222&quot;</span> <span class="attr">sex</span>=<span class="string">&quot;女&quot;</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">xiaohua</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">strdents</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">school</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>根元素</code>:这里 school是根元素</p>
<p><code>子/父元素</code>：students是school的子元素，school是students的父元素</p>
<p><code>属性</code>：address是school的属性</p>
<p><code>文本</code>：小明、小花</p>
<p><code>scala原生对XML字面量支持</code></p>
<p>你甚至可以在代码中直接使用XML片段</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> elem: <span class="type">Elem</span> =      <span class="comment">//scala.xml.Elem</span></span><br><span class="line">      &lt;a&gt;</span><br><span class="line">        &lt;b&gt;</span><br><span class="line">          hello</span><br><span class="line">        &lt;/b&gt;</span><br><span class="line">      &lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p>在我们直接写XML的时候，Scala会将其解析并识别为scala.xml.Elem类型</p>
<p><code>主要的类</code></p>
<p>Node类。它的一个抽象类，用于对象XML中的所有节点进行抽象： </p>
<p>Text类，仅包含文本的节点，例如<code>&lt;url&gt;http://www.baidu.com/&lt;/url&gt;</code> 中的<a href="http://www.baidu.com/%E5%B0%B1%E6%98%AF%E4%B8%80%E7%A7%8DText%E5%AF%B9%E8%B1%A1">http://www.baidu.com/就是一种Text对象</a></p>
<p>NodeSeq类，它同样是一个抽象类，指的是节点的序列，Node继承自NodeSeq，可以看Node可作是NodeSeq只有一个元素的情况。</p>
<h2 id="将字符串转成XML-Elem"><a href="#将字符串转成XML-Elem" class="headerlink" title="将字符串转成XML.Elem"></a>将字符串转成XML.Elem</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.xml._</span><br><span class="line"><span class="keyword">val</span> string=<span class="string">&quot;&lt;play&gt;&lt;scala&gt;&lt;/scala&gt;&lt;/play&gt;&quot;</span></span><br><span class="line"><span class="type">XML</span>.loadString(string)</span><br><span class="line"></span><br><span class="line"><span class="comment">//res0: scala.xml.Elem = &lt;play&gt;&lt;scala/&gt;&lt;/play&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="获取文本"><a href="#获取文本" class="headerlink" title="获取文本"></a>获取文本</h2><p>通过text方法可以获取文本</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> elem:<span class="type">Elem</span> = &lt;p&gt;<span class="type">Hello</span> <span class="type">Scala</span>&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">elem.text</span><br><span class="line"></span><br><span class="line"><span class="comment">//res0: String = Hello Scala</span></span><br></pre></td></tr></table></figure>

<h2 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h2><p>可以通过attributes方法得到当前元素的某个属性</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> elem:<span class="type">Elem</span> = &lt;a href=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">elem.attributes(<span class="string">&quot;href&quot;</span>).text</span><br><span class="line"></span><br><span class="line"><span class="comment">//res1: String = http://www.baidu.com</span></span><br></pre></td></tr></table></figure>

<p>也可以通过 <code>\</code> 或 <code>\\</code> 获取</p>
<blockquote>
<p>其实 \ 和 \\ 是 Elem的一个方法</p>
<p>scala允许方法之间不写“.”</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> elem:<span class="type">Elem</span> = &lt;a href=<span class="string">&quot;http://www.baidu.com&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">elem \ <span class="string">&quot;@href&quot;</span>      <span class="comment">//带上@符号，让scala知道你要查询的是属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//res2:  scala.xml.NodeSeq = http://www.baidu.com</span></span><br></pre></td></tr></table></figure>

<h3>遍历元数的属性</h3>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> elem:<span class="type">Elem</span> = &lt;a href=<span class="string">&quot;http://www.baidu.com&quot;</span> id=<span class="string">&quot;web&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(arr &lt;- elem.attributes) println(arr)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">href=&quot;http://www.baidu.com&quot; id=&quot;web&quot;</span><br><span class="line">id=&quot;web&quot;</span><br></pre></td></tr></table></figure>

<h3>获取属性(Map类型)</h3>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> elem:<span class="type">Elem</span> = &lt;a href=<span class="string">&quot;http://www.baidu.com&quot;</span> id=<span class="string">&quot;web&quot;</span>&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">elem.attributes.asAttrMap</span><br><span class="line"></span><br><span class="line"><span class="comment">// res3: Map[String,String] = Map(href -&gt; http://www.baidu.com, id -&gt; web)</span></span><br></pre></td></tr></table></figure>

<h2 id="进入子元素"><a href="#进入子元素" class="headerlink" title="进入子元素"></a>进入子元素</h2><p>可以通过 <code>\</code> 或 <code>\\</code> 进入当前节点下的某个子节点</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> elem:<span class="type">Elem</span> = &lt;div&gt;&lt;p&gt;<span class="type">Hello</span> <span class="type">Scala</span>&lt;/p&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> newElem = elem \\ <span class="string">&quot;p&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//newElem: scala.xml.NodeSeq = NodeSeq(&lt;p&gt;Hello Scala&lt;/p&gt;)</span></span><br><span class="line"></span><br><span class="line">newElem.text</span><br><span class="line"><span class="comment">// res4: String = Hello Scala</span></span><br></pre></td></tr></table></figure>

<h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.language.postfixOps</span><br><span class="line"><span class="keyword">import</span> scala.xml.<span class="type">Elem</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">test5</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mimi = <span class="keyword">new</span> <span class="type">Cat</span>(<span class="string">&quot;咪咪&quot;</span>, <span class="string">&quot;black&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化</span></span><br><span class="line">    <span class="keyword">val</span> mimiElem =  mimi.toXML()</span><br><span class="line">    println(mimiElem \ <span class="string">&quot;name&quot;</span> text)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line">    mimi.fromXML(mimiElem).jump()</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">name:<span class="type">String</span>,color:<span class="type">String</span></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//序列化</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">toXML</span></span>():<span class="type">Elem</span> =&#123;</span><br><span class="line">    &lt;<span class="type">Cat</span>&gt;</span><br><span class="line">      &lt;name&gt;&#123;name&#125;&lt;/name&gt;</span><br><span class="line">      &lt;color&gt;&#123;color&#125;&lt;/color&gt;</span><br><span class="line">    &lt;/<span class="type">Cat</span>&gt;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//反序列化</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fromXML</span></span>(xml:<span class="type">Elem</span>): <span class="type">Cat</span> =&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Cat</span>(xml \ <span class="string">&quot;name&quot;</span> text, xml \ <span class="string">&quot;color&quot;</span> text)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//跳</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">jump</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">    println(name + <span class="string">&quot;一蹦跳老高&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">咪咪</span><br><span class="line">咪咪一蹦跳老高</span><br></pre></td></tr></table></figure>

<h2 id="XML模式匹配"><a href="#XML模式匹配" class="headerlink" title="XML模式匹配"></a>XML模式匹配</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">elem <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;<span class="type">Cat</span>&gt;&lt;name&gt;&#123;name&#125;&lt;/name&gt;&lt;/<span class="type">Cat</span>&gt; =&gt; println(name)                      <span class="comment">//匹配单个元数</span></span><br><span class="line">  <span class="keyword">case</span> &lt;<span class="type">Cat</span>&gt;&lt;name&gt;&#123;name&#125;&lt;/name&gt;&lt;/<span class="type">Cat</span>&gt; =&gt; println(name.attribute(<span class="string">&quot;enName&quot;</span>))  <span class="comment">//匹配属性</span></span><br><span class="line">  <span class="keyword">case</span> &lt;<span class="type">Cat</span>&gt;&#123;info&#125;&lt;/<span class="type">Cat</span>&gt; =&gt; &#123;                                               <span class="comment">//匹配多个元素，返回ArrayBuffer</span></span><br><span class="line">    <span class="keyword">for</span> (e &lt;- info) println(e.text)      <span class="comment">//打印文本</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">case</span> _ =&gt; print(<span class="string">&quot;无匹配&quot;</span>)                                                   <span class="comment">//未被匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="XML中执行Scala表达式"><a href="#XML中执行Scala表达式" class="headerlink" title="XML中执行Scala表达式"></a>XML中执行Scala表达式</h2><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">&lt;sum&gt;&#123;<span class="number">1</span>+<span class="number">2</span>&#125;&lt;/sum&gt;</span><br><span class="line"><span class="comment">// res5:scala.xml.Elem = &lt;sum&gt;3&lt;/sum&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="利用Dom4j"><a href="#利用Dom4j" class="headerlink" title="利用Dom4j"></a>利用Dom4j</h1><p>Dom4J是dom4j.org出品的应用于Java上的一个开源的XML解析包</p>
<p>由于Scala基于Java，故也可使用</p>
<p>DOM4J 最大的特色是使用大量的接口。它的主要接口都在org.dom4j里面定义：</p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>定义了 XML 的属性。</th>
</tr>
</thead>
<tbody><tr>
<td>Branch</td>
<td>指能够包含子节点的节点。如XML元素(Element)和文档(Docuemnts)定义了一个公共的行为</td>
</tr>
<tr>
<td>CDATA</td>
<td>定义了 XML CDATA 区域</td>
</tr>
<tr>
<td>CharacterData</td>
<td>是一个标识接口，标识基于字符的节点。如CDATA，Comment, Text.</td>
</tr>
<tr>
<td>Comment</td>
<td>定义了 XML 注释的行为</td>
</tr>
<tr>
<td>Document</td>
<td>定义了XML 文档</td>
</tr>
<tr>
<td>DocumentType</td>
<td>定义 XML DOCTYPE 声明</td>
</tr>
<tr>
<td>Element</td>
<td>定义XML 元素</td>
</tr>
<tr>
<td>ElementHandler</td>
<td>定义了Element 对象的处理器</td>
</tr>
<tr>
<td>ElementPath</td>
<td>被 ElementHandler 使用，用于取得当前正在处理的路径层次信息</td>
</tr>
<tr>
<td>Entity</td>
<td>定义 XML entity</td>
</tr>
<tr>
<td>Node</td>
<td>为dom4j中所有的XML节点定义了多态行为</td>
</tr>
<tr>
<td>NodeFilter</td>
<td>定义了在dom4j 节点中产生的一个滤镜或谓词的行为（predicate）</td>
</tr>
<tr>
<td>ProcessingInstruction</td>
<td>定义 XML 处理指令</td>
</tr>
<tr>
<td>Text</td>
<td>定义 XML 文本节点</td>
</tr>
<tr>
<td>Visitor</td>
<td>用于实现 Visitor模式</td>
</tr>
<tr>
<td>XPath</td>
<td>在分析一个字符串后会提供一个 XPath 表达式</td>
</tr>
</tbody></table>
<p>在使用之前需要先引入dom4j，以maven为例，在Pom文件添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--dom4j--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--前者xPath依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.code.maven-play-plugin.org.allcolor.shanidom<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1-patched-shani-1.4.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><p>Document是一个接口类，里面定义了XML文档数据</p>
<p>Dom4J提供了非常多的方法以便使用者能灵活读取各种来源的数据</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.dom4j.&#123;<span class="type">Document</span>, <span class="type">DocumentHelper</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.&#123;<span class="type">DOMReader</span>, <span class="type">SAXReader</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.&#123;<span class="type">File</span>, <span class="type">FileInputStream</span>, <span class="type">FileReader</span>, <span class="type">InputStream</span>, <span class="type">Reader</span>&#125;</span><br><span class="line"><span class="keyword">import</span> java.net.<span class="type">URL</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DomForJavaTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">/*---------------------------数据来自XML文件------------------------------*/</span></span><br><span class="line">    <span class="comment">//读取有两种实现方式，一种是SAXReader，还有一种DOMReader，两者调用了同一个接口，所以调用方式是一样的</span></span><br><span class="line">    <span class="comment">//读取的数据将被转换为org.dom4j.Document对象</span></span><br><span class="line">    <span class="keyword">val</span> saxReader = <span class="keyword">new</span> <span class="type">SAXReader</span>()   <span class="comment">//一般来说用这种，下面演示的也是这种</span></span><br><span class="line">    <span class="keyword">val</span> domReader = <span class="keyword">new</span> <span class="type">DOMReader</span>()   <span class="comment">//这种只能从org.w3c.dom.Document对象中获取数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以在systemId中直接传入路径</span></span><br><span class="line">    <span class="keyword">val</span> document1:<span class="type">Document</span> = saxReader.read(<span class="string">&quot;./data.xml&quot;</span>)</span><br><span class="line">    <span class="comment">//也可传入一个java.io.File对象</span></span><br><span class="line">    <span class="keyword">val</span> file:<span class="type">File</span> = <span class="keyword">new</span> <span class="type">File</span>(<span class="string">&quot;./data.xml&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> document2:<span class="type">Document</span> = saxReader.read(file)</span><br><span class="line">    <span class="comment">//也可是一个统一资源定位符(java.net.URL)读取互联网上的XML文件</span></span><br><span class="line"><span class="comment">//    val url: URL = new URL(&quot;xxxx&quot;)</span></span><br><span class="line"><span class="comment">//    val document3:Document = saxReader.read(url)</span></span><br><span class="line">    <span class="comment">//也可通过通过java的各种读取器(java.io.Reader)</span></span><br><span class="line">    <span class="keyword">val</span> fileReader:<span class="type">Reader</span> = <span class="keyword">new</span> <span class="type">FileReader</span>(file)</span><br><span class="line">    <span class="keyword">val</span> document4 = saxReader.read(fileReader)</span><br><span class="line">    <span class="comment">//结束了吗，不!还可以读输入取流(java.io.InputStream)中的数据</span></span><br><span class="line">    <span class="keyword">val</span> fileStream:<span class="type">InputStream</span> = <span class="keyword">new</span> <span class="type">FileInputStream</span>(file)</span><br><span class="line">    <span class="keyword">val</span> document5:<span class="type">Document</span> = saxReader.read(fileStream)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*---------------------------数据来自字符串------------------------------*/</span></span><br><span class="line">    <span class="comment">//解析字符串的数据需要通过一个文档助手(字面意思)的类实现</span></span><br><span class="line">    <span class="comment">//官方解释该类是Dom4J的一个辅助工具集合</span></span><br><span class="line">    <span class="comment">//注意 他是一个finalClass，请直接使用它</span></span><br><span class="line">    <span class="keyword">val</span> str:<span class="type">String</span> =</span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        |&lt;school&gt;</span></span><br><span class="line"><span class="string">        |    &lt;student id=&quot;1001&quot;&gt;</span></span><br><span class="line"><span class="string">        |        &lt;name&gt;小明&lt;/name&gt;</span></span><br><span class="line"><span class="string">        |        &lt;sex&gt;男&lt;/sex&gt;</span></span><br><span class="line"><span class="string">        |    &lt;/student&gt;</span></span><br><span class="line"><span class="string">        |    &lt;student id=&quot;1002&quot;&gt;</span></span><br><span class="line"><span class="string">        |        &lt;name&gt;小花&lt;/name&gt;</span></span><br><span class="line"><span class="string">        |        &lt;sex&gt;女&lt;/sex&gt;</span></span><br><span class="line"><span class="string">        |    &lt;/student&gt;</span></span><br><span class="line"><span class="string">        |    &lt;student id=&quot;1003&quot;&gt;</span></span><br><span class="line"><span class="string">        |        &lt;name&gt;小军&lt;/name&gt;</span></span><br><span class="line"><span class="string">        |        &lt;sex&gt;男&lt;/sex&gt;</span></span><br><span class="line"><span class="string">        |    &lt;/student&gt;</span></span><br><span class="line"><span class="string">        |    &lt;student id=&quot;1004&quot;&gt;</span></span><br><span class="line"><span class="string">        |        &lt;name&gt;小鹏&lt;/name&gt;</span></span><br><span class="line"><span class="string">        |        &lt;sex&gt;男&lt;/sex&gt;</span></span><br><span class="line"><span class="string">        |    &lt;/student&gt;</span></span><br><span class="line"><span class="string">        |&lt;/school&gt;</span></span><br><span class="line"><span class="string">        |&quot;&quot;&quot;</span>.stripMargin</span><br><span class="line">    <span class="keyword">val</span> document6:<span class="type">Document</span> = <span class="type">DocumentHelper</span>.parseText(str)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><blockquote>
<p>接下来的演示数据</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">school</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">&quot;1001&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>小明<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">&quot;1002&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>小花<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">sex</span>&gt;</span>女<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">&quot;1003&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>小军<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">student</span> <span class="attr">id</span>=<span class="string">&quot;1004&quot;</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">name</span>&gt;</span>小鹏<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">sex</span>&gt;</span>男<span class="tag">&lt;/<span class="name">sex</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">school</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="进入"><a href="#进入" class="headerlink" title="进入"></a>进入</h3><blockquote>
<p>特此补充，TNN的网上写的都是啥啊，只字不提Node与Element两者的的概念</p>
<p>为了防止后人混淆。为此我特意翻了源码</p>
</blockquote>
<ul>
<li><p>Element(元素)</p>
<p>Element是一个接口，他定义了一个XML元素，各元数中可以声明名称、注释、属性、子节点以及其中的文本内容，这就很想正常的XML格式</p>
</li>
<li><p>Node(节点)</p>
<p>Node是Element的组成部分，他可以是一个元素中的某个子节点甚至只是某个属性，是Element的多态性为，我们可以通过.getNodeTypeName()得到该节点是属性还是文本等别的</p>
<p>可以将节点转换为XML格式的字符串，还可以对节点本身计算XPath表达式(xPath语法教程略)。</p>
</li>
</ul>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取根元素</span></span><br><span class="line"><span class="keyword">val</span> rootElement:<span class="type">Element</span> = document</span><br><span class="line">  .getRootElement</span><br><span class="line"><span class="comment">//获取下面的所有的student元素</span></span><br><span class="line"><span class="keyword">val</span> studentElements:<span class="type">Array</span>[<span class="type">Element</span>] = rootElement</span><br><span class="line">  .elements(<span class="string">&quot;student&quot;</span>)</span><br><span class="line">  .toArray()</span><br><span class="line">  .map(_.asInstanceOf[<span class="type">Element</span>])</span><br><span class="line"><span class="comment">//继续进入id为1002的student元素的name元素</span></span><br><span class="line"><span class="keyword">val</span> index = studentElements</span><br><span class="line">  .map(_.attribute(<span class="string">&quot;id&quot;</span>).getData.asInstanceOf[<span class="type">String</span>])     <span class="comment">//拿各元素的id属性(后面细说)</span></span><br><span class="line">  .indexOf(<span class="string">&quot;1002&quot;</span>)                                                <span class="comment">//得到下标</span></span><br><span class="line"><span class="keyword">val</span> tmp = studentElements(index)</span><br><span class="line">  .element(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="comment">//    println(tmp.getData)         //小花</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    //进入小花在的那个元素（无法使用，正在研究）</span></span><br><span class="line"><span class="comment">//    val xiaoHuaNode:Node = document</span></span><br><span class="line"><span class="comment">//      .selectNodes(&quot;//student[@id=&#x27;1002]&quot;)</span></span><br><span class="line"><span class="comment">//      .toArray()</span></span><br><span class="line"><span class="comment">//      .map(_.asInstanceOf[Node])</span></span><br><span class="line"><span class="comment">//      .head</span></span><br><span class="line"><span class="comment">//    println(xiaoHuaNode.asXML())</span></span><br></pre></td></tr></table></figure>

<h3 id="读取-1"><a href="#读取-1" class="headerlink" title="读取"></a>读取</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取某个元素的文本</span></span><br><span class="line"><span class="keyword">val</span> xiaoMinElement:<span class="type">Element</span> = document</span><br><span class="line">  .getRootElement</span><br><span class="line">  .element(<span class="string">&quot;student&quot;</span>)             <span class="comment">//默认进第一个</span></span><br><span class="line"><span class="keyword">val</span> text = xiaoMinElement</span><br><span class="line">  .elementText(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//println(text)   //小明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取某个元素的某个属性</span></span><br><span class="line"><span class="keyword">val</span> attribute:<span class="type">Attribute</span> = xiaoMinElement</span><br><span class="line">  .attribute(<span class="string">&quot;id&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//println(attribute.getName)     //id</span></span><br><span class="line"><span class="comment">//println(attribute.getData)    //1001</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历节点，得到每个节点的XML</span></span><br><span class="line"><span class="keyword">val</span> nodes:mutable.<span class="type">HashMap</span>[<span class="type">String</span>,<span class="type">Any</span>] = mutable.<span class="type">HashMap</span>()</span><br><span class="line"><span class="keyword">for</span>(i &lt;- <span class="type">Range</span>(<span class="number">0</span>,xiaoMinElement.nodeCount()))&#123;</span><br><span class="line">  <span class="keyword">val</span> node:<span class="type">Node</span> = xiaoMinElement.node(i)</span><br><span class="line">  nodes.put(node.getName,node.asXML())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//println(nodes.mkString(&quot;|&quot;))</span></span><br><span class="line"><span class="comment">//name -&gt; &lt;name&gt;小明&lt;/name&gt;|sex -&gt; &lt;sex&gt;男&lt;/sex&gt;|null -&gt; (这有一个\n)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历各个元数</span></span><br><span class="line"><span class="keyword">val</span> iterator = xiaoMinElement.elementIterator()    <span class="comment">//得到可迭代对象</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext)&#123;</span><br><span class="line">  <span class="keyword">val</span> data:<span class="type">String</span> = iterator</span><br><span class="line">    .next()</span><br><span class="line">    .asInstanceOf[<span class="type">Element</span>]</span><br><span class="line">    .getData</span><br><span class="line">    .toString</span><br><span class="line">  println(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 小明</span></span><br><span class="line"><span class="comment">* 男</span></span><br><span class="line"><span class="comment">* */</span></span><br></pre></td></tr></table></figure>

<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改/添加某个元素的属性(在dom4j 1.6+被弃用)</span></span><br><span class="line">document</span><br><span class="line">  .getRootElement</span><br><span class="line">  .element(<span class="string">&quot;student&quot;</span>)</span><br><span class="line">  .setAttributeValue(<span class="string">&quot;id&quot;</span>,<span class="string">&quot;2001&quot;</span>)   <span class="comment">//当属性不存在时将创建</span></span><br><span class="line"><span class="comment">//另一种没被弃用的方法,就是不能新增属性</span></span><br><span class="line"><span class="keyword">val</span> attribute = document</span><br><span class="line">  .getRootElement</span><br><span class="line">  .element(<span class="string">&quot;student&quot;</span>)</span><br><span class="line">  .attribute(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">attribute</span><br><span class="line">  .setValue(<span class="string">&quot;2011&quot;</span>)</span><br><span class="line"><span class="comment">//添加需要用另一个方法</span></span><br><span class="line">document</span><br><span class="line">  .getRootElement</span><br><span class="line">  .element(<span class="string">&quot;student&quot;</span>)</span><br><span class="line">  .addAttribute(<span class="string">&quot;type&quot;</span>,<span class="string">&quot;寄宿生&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//还可以通过节点来做，会更方便,不过遇到点技术问题，无法使用xPath</span></span><br><span class="line"><span class="comment">//    val attribute_2 = document</span></span><br><span class="line"><span class="comment">//      .selectNodes(&quot;//student[@id=&#x27;1002&#x27;]/@id&quot;)</span></span><br><span class="line"><span class="comment">//      .iterator()</span></span><br><span class="line"><span class="comment">//      .next()</span></span><br><span class="line"><span class="comment">//      .asInstanceOf[DefaultAttribute]</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    attribute_2</span></span><br><span class="line"><span class="comment">//      .setValue(&quot;2012&quot;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*......</span></span><br><span class="line"><span class="comment">&lt;student id=&quot;2011&quot; type=&quot;寄宿生&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;name&gt;小明&lt;/name&gt;</span></span><br><span class="line"><span class="comment">    &lt;sex&gt;男&lt;/sex&gt;</span></span><br><span class="line"><span class="comment">&lt;/student&gt;</span></span><br><span class="line"><span class="comment">......*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改文本内容</span></span><br><span class="line">document</span><br><span class="line">  .getRootElement</span><br><span class="line">  .element(<span class="string">&quot;student&quot;</span>)</span><br><span class="line">  .element(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">  .setText(<span class="string">&quot;小徐&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*......</span></span><br><span class="line"><span class="comment">&lt;student id=&quot;2011&quot; type=&quot;寄宿生&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;name&gt;小徐&lt;/name&gt;</span></span><br><span class="line"><span class="comment">    &lt;sex&gt;男&lt;/sex&gt;</span></span><br><span class="line"><span class="comment">&lt;/student&gt;</span></span><br><span class="line"><span class="comment">......*/</span></span><br><span class="line"><span class="comment">//理论上用节点也行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//添加元素</span></span><br><span class="line"><span class="comment">//各个学生都添加一个元素，元素名为class，根据id第一位生成</span></span><br><span class="line"><span class="keyword">val</span> iterator = document</span><br><span class="line">  .getRootElement</span><br><span class="line">  .elements()</span><br><span class="line">  .iterator()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext)&#123;</span><br><span class="line">  <span class="keyword">val</span> element:<span class="type">Element</span> = iterator.next().asInstanceOf[<span class="type">Element</span>]</span><br><span class="line">  <span class="keyword">val</span> stuClass:<span class="type">String</span> = element.attribute(<span class="string">&quot;id&quot;</span>).getValue.head + <span class="string">&quot;班&quot;</span></span><br><span class="line">  element   <span class="comment">//新增空元素</span></span><br><span class="line">    .addElement(<span class="string">&quot;class&quot;</span>)</span><br><span class="line">  element   <span class="comment">//设置元素文本</span></span><br><span class="line">    .element(<span class="string">&quot;class&quot;</span>)</span><br><span class="line">    .setText(stuClass)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*&lt;school&gt;</span></span><br><span class="line"><span class="comment">&lt;student id=&quot;2011&quot; type=&quot;寄宿生&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;name&gt;小徐&lt;/name&gt;</span></span><br><span class="line"><span class="comment">    &lt;sex&gt;男&lt;/sex&gt;</span></span><br><span class="line"><span class="comment">&lt;class&gt;2班&lt;/class&gt;&lt;/student&gt;</span></span><br><span class="line"><span class="comment">&lt;student id=&quot;1002&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;name&gt;小花&lt;/name&gt;</span></span><br><span class="line"><span class="comment">    &lt;sex&gt;女&lt;/sex&gt;</span></span><br><span class="line"><span class="comment">&lt;class&gt;1班&lt;/class&gt;&lt;/student&gt;</span></span><br><span class="line"><span class="comment">&lt;student id=&quot;1003&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;name&gt;小军&lt;/name&gt;</span></span><br><span class="line"><span class="comment">    &lt;sex&gt;男&lt;/sex&gt;</span></span><br><span class="line"><span class="comment">&lt;class&gt;1班&lt;/class&gt;&lt;/student&gt;</span></span><br><span class="line"><span class="comment">&lt;student id=&quot;1004&quot;&gt;</span></span><br><span class="line"><span class="comment">    &lt;name&gt;小鹏&lt;/name&gt;</span></span><br><span class="line"><span class="comment">    &lt;sex&gt;男&lt;/sex&gt;</span></span><br><span class="line"><span class="comment">&lt;class&gt;1班&lt;/class&gt;&lt;/student&gt;</span></span><br><span class="line"><span class="comment">&lt;/school&gt;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> tmp = document</span><br><span class="line">  .node(<span class="number">0</span>)</span><br><span class="line">  .asXML()</span><br><span class="line">println(tmp)</span><br></pre></td></tr></table></figure>

<h2 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h2><p>写入到CSV</p>
<blockquote>
<p>文件会被复写，不用担心写入问题</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> writer:<span class="type">Writer</span> = <span class="keyword">new</span> <span class="type">FileWriter</span>(<span class="string">&quot;./newData.xml&quot;</span>)</span><br><span class="line">    document</span><br><span class="line">      .write(writer)</span><br><span class="line">    writer.close()                  <span class="comment">//记得释放资源，不然写不进去</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记分享</category>
      </categories>
      <tags>
        <tag>编程语言</tag>
        <tag>Scala</tag>
      </tags>
  </entry>
  <entry>
    <title>SparkRDD</title>
    <url>/article/SparkRDD/</url>
    <content><![CDATA[<h1 id="RDD"><a href="#RDD" class="headerlink" title="RDD"></a>RDD</h1><p>RDD（Resilient Distributed Dataset）即弹性分布式数据集，数据集的全部或部分可以存储在集群的多台机子的内存上，当内存不够时，数据也可持久化到硬盘</p>
<p>RDD的主要特征：</p>
<ul>
<li>RDD都是<code>只读</code>的，但可以将RDD转换为新的RDD</li>
<li>RDD是可分区的，每个分区对应一个Tesk执行</li>
<li>对RDD的操作，相对于对RDD某个分区操作</li>
<li>RDD拥有一系列的分区技术函数，称为算子</li>
<li>RDD之间存在依赖关系，可以实现管道化</li>
</ul>
<p><code>转换算子</code>负责对RDD中的数据进行计算并转换为一个新的RDD</p>
<p>Spark中所有算子都是惰性的，只有遇到<code>行动算子</code>才会一起执行</p>
<span id="more"></span>

<blockquote>
<p>下面先使用Spark Shell操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">[root@master ~]<span class="comment"># spark-shell</span></span><br><span class="line">Spark context Web UI available at http://192.168.159.136:4041</span><br><span class="line">Spark context available as <span class="string">&#x27;sc&#x27;</span> (master = <span class="built_in">local</span>[*], app <span class="built_in">id</span> = local-1665305112084).</span><br><span class="line">Spark session available as <span class="string">&#x27;spark&#x27;</span>.</span><br><span class="line">Welcome to</span><br><span class="line">____              __</span><br><span class="line">/ __/__  ___ _____/ /__</span><br><span class="line">_\ \/ _ \/ _ `/ __/  <span class="string">&#x27;_/</span></span><br><span class="line"><span class="string">/___/ .__/\_,_/_/ /_/\_\   version 2.1.1</span></span><br><span class="line"><span class="string">/_/</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Using Scala version 2.11.8 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_221)</span></span><br><span class="line"><span class="string">Type in expressions to have them evaluated.</span></span><br><span class="line"><span class="string">Type :help for more information.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">scala&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="创建RDD"><a href="#创建RDD" class="headerlink" title="创建RDD"></a>创建RDD</h2><h3 id="通过对象创建"><a href="#通过对象创建" class="headerlink" title="通过对象创建"></a>通过对象创建</h3><p>Spark可以通过parallelize()或makeRDD()将一个对象集合转换为RDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="comment">// 创建Scala集合</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">list: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(list)</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">0</span>] at makeRDD at &lt;console&gt;:<span class="number">26</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd.collect</span><br><span class="line">res0: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h3 id="通过本地文件创建"><a href="#通过本地文件创建" class="headerlink" title="通过本地文件创建"></a>通过本地文件创建</h3><p>Spark可以通过textFile()读取本地文件系统文件，并按行拆分，转换为RDD</p>
<p>创建一个文本文件，在&#x2F;root&#x2F;text.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@master ~]# cat text.txt</span><br><span class="line">hello scala</span><br><span class="line">hello spark</span><br><span class="line">hello bigData</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.textFile(<span class="string">&quot;/root/text.txt&quot;</span>)</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = /root/text.txt <span class="type">MapPartitionsRDD</span>[<span class="number">4</span>] at textFile at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd.collect</span><br><span class="line">res2: <span class="type">Array</span>[<span class="type">String</span>] = <span class="type">Array</span>(hello scala, hello spark, hello bigData)</span><br></pre></td></tr></table></figure>

<h3 id="通过HDFS文件系统中文件创建"><a href="#通过HDFS文件系统中文件创建" class="headerlink" title="通过HDFS文件系统中文件创建"></a>通过HDFS文件系统中文件创建</h3><p>与前者类似，就在路径前加上<code>hdfs://hostname:post</code>就行</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.textFile(<span class="string">&quot;hdfs://master:9000/text.txt&quot;</span>)</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = hdfs:<span class="comment">//master:9000/text.txt MapPartitionsRDD[12] at textFile at &lt;console&gt;:24</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd.collect</span><br><span class="line">res6: <span class="type">Array</span>[<span class="type">String</span>] = <span class="type">Array</span>(hello scala, hello spark, hello bigData)</span><br></pre></td></tr></table></figure>

<h2 id="RDD转换算子"><a href="#RDD转换算子" class="headerlink" title="RDD转换算子"></a>RDD转换算子</h2><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>Map算子可以对RDD中每个元素进行转换，如何作为结果RDD中对应位置元素的值</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">15</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> newRdd = rdd.map(_+<span class="number">1</span>)</span><br><span class="line">newRdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">MapPartitionsRDD</span>[<span class="number">16</span>] at map at &lt;console&gt;:<span class="number">26</span></span><br><span class="line"></span><br><span class="line">scala&gt; newRdd.collect</span><br><span class="line">res9: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>RDD是只读的，所以算子对RDD的修改不会影响源RDD，但会返回一个新的RDD</p>
</blockquote>
<h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>与map类似，不过flatMap算子对每个元素的转换的结果可以是0、1或多个结果，然后将所有结果合并到一个RDD中</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b c&quot;</span>,<span class="string">&quot;d&quot;</span>))</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">17</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> newRdd = rdd.flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">newRdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = <span class="type">MapPartitionsRDD</span>[<span class="number">18</span>] at flatMap at &lt;console&gt;:<span class="number">26</span></span><br><span class="line"></span><br><span class="line">scala&gt; newRdd.collect</span><br><span class="line">res10: <span class="type">Array</span>[<span class="type">String</span>] = <span class="type">Array</span>(a, b, c, d)</span><br></pre></td></tr></table></figure>

<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>filter算子可以过滤掉一些元素，然后将剩下的元素放入一个新的RDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">20</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> newRdd = rdd.filter(_&gt;<span class="number">2</span>)</span><br><span class="line">newRdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">MapPartitionsRDD</span>[<span class="number">21</span>] at filter at &lt;console&gt;:<span class="number">26</span></span><br><span class="line"></span><br><span class="line">scala&gt; newRdd.collect</span><br><span class="line">res11: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h3 id="reduceByKey"><a href="#reduceByKey" class="headerlink" title="reduceByKey"></a>reduceByKey</h3><p>reduceByKey只能用于(key,value)样式的scala<code>一维</code>长度为<code>2</code>的<code>元组</code>,默认且只能指定第一个元素为key，第二个为value</p>
<p>将相同的key的元素进行聚合，value进行计算，然后放在一个新的RDD中返回，返回的类型也是(key,value)</p>
<p>例,相同key，value求和</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>((<span class="string">&quot;A&quot;</span>,<span class="number">12</span>),(<span class="string">&quot;A&quot;</span>,<span class="number">13</span>),(<span class="string">&quot;B&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;B&quot;</span>,<span class="number">2</span>)))</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">ParallelCollectionRDD</span>[<span class="number">27</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> newRDD = rdd.reduceByKey((v1,v2) =&gt; v1 + v2)</span><br><span class="line">newRDD: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">ShuffledRDD</span>[<span class="number">28</span>] at reduceByKey at &lt;console&gt;:<span class="number">26</span></span><br><span class="line"></span><br><span class="line">scala&gt; newRDD.collect</span><br><span class="line">res14: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">Array</span>((<span class="type">A</span>,<span class="number">25</span>), (<span class="type">B</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<h3 id="groupByKey"><a href="#groupByKey" class="headerlink" title="groupByKey"></a>groupByKey</h3><p>类似前者，源RDD数据类型只能是(key,value)样式的scala<code>一维</code>长度为<code>2</code>的<code>元组</code></p>
<p>将相同的key的元素聚合，value都丢在一个集合内，然后放在一个新的RDD中返回，返回的类型是(key,CompactBuffer(value…….))</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>((<span class="string">&quot;A&quot;</span>,<span class="number">12</span>),(<span class="string">&quot;A&quot;</span>,<span class="number">13</span>),(<span class="string">&quot;B&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;B&quot;</span>,<span class="number">2</span>)))</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">ParallelCollectionRDD</span>[<span class="number">29</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> newRDD = rdd.groupByKey()</span><br><span class="line">newRDD: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">Int</span>])] = <span class="type">ShuffledRDD</span>[<span class="number">30</span>] at groupByKey at &lt;console&gt;:<span class="number">26</span></span><br><span class="line"></span><br><span class="line">scala&gt; newRDD.collect</span><br><span class="line">res15: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">Int</span>])] = <span class="type">Array</span>((<span class="type">A</span>,<span class="type">CompactBuffer</span>(<span class="number">12</span>, <span class="number">13</span>)), (<span class="type">B</span>,<span class="type">CompactBuffer</span>(<span class="number">1</span>, <span class="number">2</span>)))</span><br></pre></td></tr></table></figure>

<h3 id="union"><a href="#union" class="headerlink" title="union"></a>union</h3><p>用于将两个<code>相同数据类型</code>RDD进行合并，并放回一个合并后的RDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line">rdd1: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">31</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd2 = sc.makeRDD(<span class="type">Array</span>(<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line">rdd2: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">32</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd3 = rdd1.union(rdd2)</span><br><span class="line">rdd3: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">UnionRDD</span>[<span class="number">33</span>] at union at &lt;console&gt;:<span class="number">28</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd3.collect</span><br><span class="line">res16: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<h3 id="sortBy"><a href="#sortBy" class="headerlink" title="sortBy"></a>sortBy</h3><p>sortBy算子可以将RDD内的元素进行排序，并返回新的RDD</p>
<p>sortBy第一个参数是排序函数，可以用于指定排序依据，第二个参数是布尔值，表示是否升序排序（即如果要降序，就false）</p>
<p><code>第二个参数默认为true（默认升序）</code></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">Array</span>((<span class="string">&quot;xiaomin&quot;</span>,<span class="number">75</span>),(<span class="string">&quot;xiaohua&quot;</span>,<span class="number">85</span>),(<span class="string">&quot;xiaodong&quot;</span>,<span class="number">83</span>)))</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">ParallelCollectionRDD</span>[<span class="number">57</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> newRDD = rdd.sortBy(_._2)</span><br><span class="line">newRDD: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">MapPartitionsRDD</span>[<span class="number">62</span>] at sortBy at &lt;console&gt;:<span class="number">26</span></span><br><span class="line"></span><br><span class="line">scala&gt; newRDD.collect</span><br><span class="line">res21: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">Array</span>((xiaomin,<span class="number">75</span>), (xiaodong,<span class="number">83</span>), (xiaohua,<span class="number">85</span>))</span><br><span class="line"></span><br><span class="line">scala&gt; newRDD = rdd.sortBy(_._2,<span class="literal">false</span>)</span><br><span class="line">newRDD: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">MapPartitionsRDD</span>[<span class="number">67</span>] at sortBy at &lt;console&gt;:<span class="number">26</span></span><br><span class="line"></span><br><span class="line">scala&gt; newRDD.collect</span><br><span class="line">res22: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">Array</span>((xiaohua,<span class="number">85</span>), (xiaodong,<span class="number">83</span>), (xiaomin,<span class="number">75</span>))</span><br></pre></td></tr></table></figure>

<h3 id="sortByKey"><a href="#sortByKey" class="headerlink" title="sortByKey"></a>sortByKey</h3><p>源RDD数据类型只能是(key,value)样式的scala<code>一维</code>长度为<code>2</code>的<code>元组</code></p>
<p>按照key进行排序</p>
<p>只有一个参数表示是否升序排序，默认true,即默认升序</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">Array</span>((<span class="number">2</span>,<span class="string">&quot;A&quot;</span>),(<span class="number">1</span>,<span class="string">&quot;B&quot;</span>),(<span class="number">3</span>,<span class="string">&quot;C&quot;</span>)))</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">ParallelCollectionRDD</span>[<span class="number">75</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> newRDD = rdd.sortByKey(<span class="literal">false</span>)</span><br><span class="line">newRDD: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">ShuffledRDD</span>[<span class="number">78</span>] at sortByKey at &lt;console&gt;:<span class="number">26</span></span><br><span class="line"></span><br><span class="line">scala&gt; newRDD.collect</span><br><span class="line">res25: <span class="type">Array</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">Array</span>((<span class="number">3</span>,<span class="type">C</span>), (<span class="number">2</span>,<span class="type">A</span>), (<span class="number">1</span>,<span class="type">B</span>))</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> newRDD = rdd.sortByKey()</span><br><span class="line">newRDD: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">ShuffledRDD</span>[<span class="number">81</span>] at sortByKey at &lt;console&gt;:<span class="number">26</span></span><br><span class="line"></span><br><span class="line">scala&gt; newRDD.collect</span><br><span class="line">res26: <span class="type">Array</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = <span class="type">Array</span>((<span class="number">1</span>,<span class="type">B</span>), (<span class="number">2</span>,<span class="type">A</span>), (<span class="number">3</span>,<span class="type">C</span>))</span><br></pre></td></tr></table></figure>

<h3 id="join"><a href="#join" class="headerlink" title="join"></a>join</h3><p>源RDD数据类型只能是(key,value)样式的scala<code>一维</code>长度为<code>2</code>的<code>元组</code></p>
<p>join算子做的是内连接，是将两个RDD工具key进行连接，并只返回两个RDD都匹配的内容</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">Array</span>((<span class="string">&quot;A&quot;</span>,<span class="string">&quot;a&quot;</span>),(<span class="string">&quot;B&quot;</span>,<span class="string">&quot;b&quot;</span>)))</span><br><span class="line">rdd1: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">String</span>)] = <span class="type">ParallelCollectionRDD</span>[<span class="number">83</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd2 = sc.makeRDD(<span class="type">Array</span>((<span class="string">&quot;B&quot;</span>,<span class="string">&quot;b1&quot;</span>),(<span class="string">&quot;B&quot;</span>,<span class="string">&quot;b2&quot;</span>),(<span class="string">&quot;C&quot;</span>,<span class="string">&quot;c&quot;</span>)))</span><br><span class="line">rdd2: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">String</span>)] = <span class="type">ParallelCollectionRDD</span>[<span class="number">84</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd3 = rdd1.join(rdd2)</span><br><span class="line">rdd3: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">String</span>, <span class="type">String</span>))] = <span class="type">MapPartitionsRDD</span>[<span class="number">87</span>] at join at &lt;console&gt;:<span class="number">28</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd3.collect</span><br><span class="line">res27: <span class="type">Array</span>[(<span class="type">String</span>, (<span class="type">String</span>, <span class="type">String</span>))] = <span class="type">Array</span>((<span class="type">B</span>,(b,b1)), (<span class="type">B</span>,(b,b2)))</span><br></pre></td></tr></table></figure>

<h3 id="leftOuterJoin"><a href="#leftOuterJoin" class="headerlink" title="leftOuterJoin"></a>leftOuterJoin</h3><p>源RDD数据类型只能是(key,value)样式的scala<code>一维</code>长度为<code>2</code>的<code>元组</code></p>
<p>leftOuterJoin算子做的是左外连接，是将两个RDD工具key进行连接，左边RDD会都存在，右边RDD只保留匹配内容</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd2 = sc.makeRDD(<span class="type">Array</span>((<span class="string">&quot;B&quot;</span>,<span class="string">&quot;b1&quot;</span>),(<span class="string">&quot;B&quot;</span>,<span class="string">&quot;b2&quot;</span>),(<span class="string">&quot;C&quot;</span>,<span class="string">&quot;c&quot;</span>)))</span><br><span class="line">rdd2: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">String</span>)] = <span class="type">ParallelCollectionRDD</span>[<span class="number">89</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd3 = rdd1.leftOuterJoin(rdd2)</span><br><span class="line">rdd3: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">String</span>, <span class="type">Option</span>[<span class="type">String</span>]))] = <span class="type">MapPartitionsRDD</span>[<span class="number">92</span>] at leftOuterJoin at &lt;console&gt;:<span class="number">28</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd3.collect</span><br><span class="line">res28: <span class="type">Array</span>[(<span class="type">String</span>, (<span class="type">String</span>, <span class="type">Option</span>[<span class="type">String</span>]))] = <span class="type">Array</span>((<span class="type">A</span>,(a,<span class="type">None</span>)), (<span class="type">B</span>,(b,<span class="type">Some</span>(b1))), (<span class="type">B</span>,(b,<span class="type">Some</span>(b2))))</span><br></pre></td></tr></table></figure>

<h3 id="rightOuterJoin"><a href="#rightOuterJoin" class="headerlink" title="rightOuterJoin"></a>rightOuterJoin</h3><p>源RDD数据类型只能是(key,value)样式的scala<code>一维</code>长度为<code>2</code>的<code>元组</code></p>
<p>leftOuterJoin算子做的是右外连接，是将两个RDD工具key进行连接，左边RDD只保留匹配内容，右边RDD会都存在</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">Array</span>((<span class="string">&quot;A&quot;</span>,<span class="string">&quot;a&quot;</span>),(<span class="string">&quot;B&quot;</span>,<span class="string">&quot;b&quot;</span>)))</span><br><span class="line">rdd1: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">String</span>)] = <span class="type">ParallelCollectionRDD</span>[<span class="number">93</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd2 = sc.makeRDD(<span class="type">Array</span>((<span class="string">&quot;B&quot;</span>,<span class="string">&quot;b1&quot;</span>),(<span class="string">&quot;B&quot;</span>,<span class="string">&quot;b2&quot;</span>),(<span class="string">&quot;C&quot;</span>,<span class="string">&quot;c&quot;</span>)))</span><br><span class="line">rdd2: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">String</span>)] = <span class="type">ParallelCollectionRDD</span>[<span class="number">94</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd3 = rdd1.rightOuterJoin(rdd2)</span><br><span class="line">rdd3: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Option</span>[<span class="type">String</span>], <span class="type">String</span>))] = <span class="type">MapPartitionsRDD</span>[<span class="number">97</span>] at rightOuterJoin at &lt;console&gt;:<span class="number">28</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd3.collect</span><br><span class="line">res29: <span class="type">Array</span>[(<span class="type">String</span>, (<span class="type">Option</span>[<span class="type">String</span>], <span class="type">String</span>))] = <span class="type">Array</span>((<span class="type">B</span>,(<span class="type">Some</span>(b),b1)), (<span class="type">B</span>,(<span class="type">Some</span>(b),b2)), (<span class="type">C</span>,(<span class="type">None</span>,c)))</span><br></pre></td></tr></table></figure>

<h3 id="fullOuterJoin"><a href="#fullOuterJoin" class="headerlink" title="fullOuterJoin"></a>fullOuterJoin</h3><p>源RDD数据类型只能是(key,value)样式的scala<code>一维</code>长度为<code>2</code>的<code>元组</code></p>
<p>leftOuterJoin算子做的是全外连接，是将两个RDD工具key进行连接，两边RDD不管匹不匹配的元素会都存在</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">Array</span>((<span class="string">&quot;A&quot;</span>,<span class="string">&quot;a&quot;</span>),(<span class="string">&quot;B&quot;</span>,<span class="string">&quot;b&quot;</span>)))</span><br><span class="line">rdd1: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">String</span>)] = <span class="type">ParallelCollectionRDD</span>[<span class="number">98</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd2 = sc.makeRDD(<span class="type">Array</span>((<span class="string">&quot;B&quot;</span>,<span class="string">&quot;b1&quot;</span>),(<span class="string">&quot;B&quot;</span>,<span class="string">&quot;b2&quot;</span>),(<span class="string">&quot;C&quot;</span>,<span class="string">&quot;c&quot;</span>)))</span><br><span class="line">rdd2: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">String</span>)] = <span class="type">ParallelCollectionRDD</span>[<span class="number">99</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd3 = rdd1.fullOuterJoin(rdd2)</span><br><span class="line">rdd3: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Option</span>[<span class="type">String</span>], <span class="type">Option</span>[<span class="type">String</span>]))] = <span class="type">MapPartitionsRDD</span>[<span class="number">102</span>] at fullOuterJoin at &lt;console&gt;:<span class="number">28</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd3.collect</span><br><span class="line">res30: <span class="type">Array</span>[(<span class="type">String</span>, (<span class="type">Option</span>[<span class="type">String</span>], <span class="type">Option</span>[<span class="type">String</span>]))] = <span class="type">Array</span>((<span class="type">A</span>,(<span class="type">Some</span>(a),<span class="type">None</span>)), (<span class="type">B</span>,(<span class="type">Some</span>(b),<span class="type">Some</span>(b1))), (<span class="type">B</span>,(<span class="type">Some</span>(b),<span class="type">Some</span>(b2))), (<span class="type">C</span>,(<span class="type">None</span>,<span class="type">Some</span>(c))))</span><br></pre></td></tr></table></figure>

<h3 id="intersection"><a href="#intersection" class="headerlink" title="intersection"></a>intersection</h3><p>返回两个RDD元素的<code>交集</code>组成的新RDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="number">1</span> to <span class="number">5</span>)</span><br><span class="line">rdd1: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">105</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd2 = sc.makeRDD(<span class="number">3</span> to <span class="number">7</span>)</span><br><span class="line">rdd2: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">106</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd1.intersection(rdd2).collect</span><br><span class="line">res32: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="cogroup"><a href="#cogroup" class="headerlink" title="cogroup"></a>cogroup</h3><p>对两个数据类型是(key,value)样式的scala<code>一维</code>长度为<code>2</code>的<code>元组</code>的RDD先按照Key进行组合，然后工具key进行<code>并集</code>操作</p>
<p>一种合并，左边有的放左边，右边有的放右边，没有留空</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">Array</span>((<span class="string">&quot;A&quot;</span>,<span class="string">&quot;a&quot;</span>),(<span class="string">&quot;B&quot;</span>,<span class="string">&quot;b&quot;</span>)))</span><br><span class="line">rdd1: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">String</span>)] = <span class="type">ParallelCollectionRDD</span>[<span class="number">117</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd2 = sc.makeRDD(<span class="type">Array</span>((<span class="string">&quot;B&quot;</span>,<span class="string">&quot;b1&quot;</span>),(<span class="string">&quot;B&quot;</span>,<span class="string">&quot;b2&quot;</span>),(<span class="string">&quot;C&quot;</span>,<span class="string">&quot;c&quot;</span>)))</span><br><span class="line">rdd2: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">String</span>)] = <span class="type">ParallelCollectionRDD</span>[<span class="number">118</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd1.cogroup(rdd2).collect</span><br><span class="line">res34: <span class="type">Array</span>[(<span class="type">String</span>, (<span class="type">Iterable</span>[<span class="type">String</span>], <span class="type">Iterable</span>[<span class="type">String</span>]))] = <span class="type">Array</span>((<span class="type">A</span>,(<span class="type">CompactBuffer</span>(a),<span class="type">CompactBuffer</span>())), (<span class="type">B</span>,(<span class="type">CompactBuffer</span>(b),<span class="type">CompactBuffer</span>(b1, b2))), (<span class="type">C</span>,(<span class="type">CompactBuffer</span>(),<span class="type">CompactBuffer</span>(c))))</span><br></pre></td></tr></table></figure>

<h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><p>返回一个源RDD去重后的RDD</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line">rdd1: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">113</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd1.distinct.collect</span><br><span class="line">res33: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠<code>注意</code>，会乱序</p>
</blockquote>
<h2 id="RDD行动算子"><a href="#RDD行动算子" class="headerlink" title="RDD行动算子"></a>RDD行动算子</h2><p>Spark中对RDD的操作都惰性的，只有遇到行动算子才会触发计算</p>
<p>所以，在使用转换算子时出现的问题，可能不会立即显现</p>
<p>行动算子有一些这些</p>
<ol>
<li><p>reduce</p>
</li>
<li><p>collect</p>
</li>
<li><p>count</p>
</li>
<li><p>first</p>
</li>
<li><p>take</p>
</li>
<li><p>takeOrdered</p>
</li>
<li><p>aggregate</p>
</li>
<li><p>fold</p>
</li>
<li><p>countByKey</p>
</li>
<li><p>save相关算子</p>
</li>
<li><p>foreach</p>
</li>
</ol>
<p>拿几个常用的算子举例</p>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h3><p>将RDD中元素进行聚合,直接返回聚合结果</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="number">1</span> to <span class="number">100</span>)</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">1</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd.reduce((a,b) =&gt; a+b)</span><br><span class="line">res0: <span class="type">Int</span> = <span class="number">5050</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>行动算子返回不一定是RDD</p>
</blockquote>
<h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><p>统计并返回RDD中元素个数</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="number">1</span> to <span class="number">100</span>)</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">2</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd.count</span><br><span class="line">res1: <span class="type">Long</span> = <span class="number">100</span></span><br></pre></td></tr></table></figure>



<h3 id="countByKey"><a href="#countByKey" class="headerlink" title="countByKey"></a>countByKey</h3><p>源RDD数据类型只能是(key,value)样式的scala<code>一维</code>长度为<code>2</code>的<code>元组</code></p>
<p>按照key分类，然后按照可以统计个数，返回scala.collection.Map</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">Array</span>((<span class="string">&quot;A&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;B&quot;</span>,<span class="number">1</span>),(<span class="string">&quot;A&quot;</span>,<span class="number">2</span>)))</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">ParallelCollectionRDD</span>[<span class="number">3</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd.countByKey</span><br><span class="line">res2: scala.collection.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Long</span>] = <span class="type">Map</span>(<span class="type">A</span> -&gt; <span class="number">2</span>, <span class="type">B</span> -&gt; <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="take-n"><a href="#take-n" class="headerlink" title="take(n)"></a>take(n)</h3><p>返回RDD前n个元素组成的数组</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="number">1</span> to <span class="number">100</span>)</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">6</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd.take(<span class="number">10</span>)</span><br><span class="line">res3: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果是取第一个，可以使用first算子</p>
</blockquote>
<h2 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h2><p>RDD可以分为多个分区，各个分区放在各个节点上</p>
<h3 id="分区数量"><a href="#分区数量" class="headerlink" title="分区数量"></a>分区数量</h3><p>RDD中各个分区中的数据可以并行计算，Spark会给每个分区分配一个Task任进行计算</p>
<p>RDD<code>通常</code>默认分区数量为你的集群的CPU核心数</p>
<h4 id="查看分区数量"><a href="#查看分区数量" class="headerlink" title="查看分区数量"></a>查看分区数量</h4><p>我可以使用getNumPartitis查看分区数量</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="number">1</span> to <span class="number">100</span>)</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">9</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd.getNumPartitions</span><br><span class="line">res9: <span class="type">Int</span> = <span class="number">4</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>getNumPartitis默认是使用当前设备的核心数；我是用了台4核心的虚拟机。可以看出，与核心数一致</p>
</blockquote>
<h4 id="指定分区数量"><a href="#指定分区数量" class="headerlink" title="指定分区数量"></a>指定分区数量</h4><p>一般来说，在创建RDD的函数的第二个参数传入一个Int类型的数，就可以指定RDD分区数量</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="number">1</span> to <span class="number">100</span>,<span class="number">20</span>)</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">10</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd.getNumPartitions</span><br><span class="line">res10: <span class="type">Int</span> = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>分区数不受核心数限制</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.textFile(<span class="string">&quot;/root/text.txt&quot;</span>,<span class="number">1</span>)</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">String</span>] = /root/text.txt <span class="type">MapPartitionsRDD</span>[<span class="number">14</span>] at textFile at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd.getNumPartitions</span><br><span class="line">res12: <span class="type">Int</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，textFile中第二个参数只是最小分区数量，具体Spark可能会按照文件大小等一些因素决定</p>
<hr>
<p>所以，我一开始的话可能有点片面，实际上要看看编辑器的提示或源码，视情况而定</p>
</blockquote>
<h4 id="自定义分区器"><a href="#自定义分区器" class="headerlink" title="自定义分区器"></a>自定义分区器</h4><p>分区规则是由分区控制器（Partitioner）控制，Spark的主要分区类是HashPartitioner和RangePartitioner,他们都继承自抽象类Partitioner,我们可以实现Partitioner类达到自定义分区控制器</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">Partitioner</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @author 20软件林泰圣</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">PartitionerTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">      .setAppName(<span class="string">&quot;PartitionerTest&quot;</span>)</span><br><span class="line">      .setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> dataRDD:<span class="type">RDD</span>[(<span class="type">String</span>,(<span class="type">String</span>,<span class="type">String</span>))] = sc.makeRDD(</span><br><span class="line">      <span class="type">Array</span>(</span><br><span class="line">        (<span class="string">&quot;cat&quot;</span>,(<span class="string">&quot;mimi&quot;</span>,<span class="string">&quot;white&quot;</span>)),</span><br><span class="line">        (<span class="string">&quot;cat&quot;</span>,(<span class="string">&quot;tom&quot;</span>,<span class="string">&quot;blue&quot;</span>)),</span><br><span class="line">        (<span class="string">&quot;dog&quot;</span>,(<span class="string">&quot;wancai&quot;</span>,<span class="string">&quot;black&quot;</span>))</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写到HDFS</span></span><br><span class="line">    dataRDD</span><br><span class="line">      .partitionBy(<span class="keyword">new</span> <span class="type">MyPartitioner</span>(<span class="number">3</span>))   <span class="comment">//自定义分区器</span></span><br><span class="line">      .saveAsTextFile(<span class="string">&quot;hdfs://192.168.159.136:9000/output&quot;</span>)    <span class="comment">//保存到hdfs</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义分区器</span></span><br><span class="line"><span class="comment"> * @param partitionNum 分区数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPartitioner</span>(<span class="params">partitionNum:<span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获得分区数量</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = partitionNum</span><br><span class="line">  <span class="comment">//获得分区ID,即那个分区，分区ID为Int类型</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> project = key.toString</span><br><span class="line">    <span class="keyword">if</span>(project.equals(<span class="string">&quot;cat&quot;</span>))&#123;          <span class="comment">//猫：0</span></span><br><span class="line">      <span class="number">0</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(project.equals(<span class="string">&quot;dog&quot;</span>))&#123;    <span class="comment">//狗:1</span></span><br><span class="line">      <span class="number">1</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;                              <span class="comment">//其他:2</span></span><br><span class="line">      <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# hadoop dfs -ls /output</span><br><span class="line"></span><br><span class="line">Found 4 items</span><br><span class="line">-rw-r--r--   3 ÁÖ̩ʥ supergroup          0 2022-10-10 01:18 /output/_SUCCESS</span><br><span class="line">-rw-r--r--   3 ÁÖ̩ʥ supergroup         36 2022-10-10 01:18 /output/part-00000</span><br><span class="line">-rw-r--r--   3 ÁÖ̩ʥ supergroup         21 2022-10-10 01:18 /output/part-00001</span><br><span class="line">-rw-r--r--   3 ÁÖ̩ʥ supergroup          0 2022-10-10 01:18 /output/part-00002</span><br><span class="line">[root@master ~]# hadoop dfs -cat /output/part-00000</span><br><span class="line"></span><br><span class="line">(cat,(mimi,white))</span><br><span class="line">(cat,(tom,blue))</span><br><span class="line">[root@master ~]# hadoop dfs -cat /output/part-00001</span><br><span class="line"></span><br><span class="line">(dog,(wancai,black))</span><br><span class="line">[root@master ~]# hadoop dfs -cat /output/part-00002</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="RDD持久化"><a href="#RDD持久化" class="headerlink" title="RDD持久化"></a>RDD持久化</h2><p>SparkRDD是懒加载的，只有遇到行动算子才会从头开始计算所有RDD，当遇到一个RDD被多次使用，就会严重影响性能，这时候可以通过RDD持久化避免重复计算</p>
<p>在RDD上进行persist()或cache()可以对RDD进行持久化；cache()底层调用persist()，不可更改级别</p>
<h3 id="存储级别"><a href="#存储级别" class="headerlink" title="存储级别"></a>存储级别</h3><table>
<thead>
<tr>
<th>Storage Level</th>
<th>Meaning</th>
</tr>
</thead>
<tbody><tr>
<td>MEMORY_ONLY</td>
<td>将RDD作为非序列化的Java对象存储在jvm中。如果RDD不适合存在内存中，一些分区将不会被缓存，从而在每次需要这些分区时都需重新计算它们。这是系统默认的存储级别。</td>
</tr>
<tr>
<td>MEMORY_AND_DISK</td>
<td>将RDD作为非序列化的Java对象存储在jvm中。如果RDD不适合存在内存中，将这些不适合存在内存中的分区存储在磁盘中，每次需要时读出它们。</td>
</tr>
<tr>
<td>MEMORY_ONLY_SER</td>
<td>将RDD作为序列化的Java对象存储（每个分区一个byte数组）。这种方式比非序列化方式更节省空间，特别是用到快速的序列化工具时，但是会更耗费cpu资源—密集的读操作。</td>
</tr>
<tr>
<td>MEMORY_AND_DISK_SER</td>
<td>和MEMORY_ONLY_SER类似，但不是在每次需要时重复计算这些不适合存储到内存中的分区，而是将这些分区存储到磁盘中。</td>
</tr>
<tr>
<td>DISK_ONLY</td>
<td>仅仅将RDD分区存储到磁盘中</td>
</tr>
<tr>
<td>MEMORY_ONLY_2, MEMORY_AND_DISK_2, etc.</td>
<td>和上面的存储级别类似，但是复制每个分区到集群的两个节点上面</td>
</tr>
<tr>
<td>OFF_HEAP (experimental)</td>
<td>以序列化的格式存储RDD到<a href="http://tachyon-project.org/">Tachyon</a>中。相对于MEMORY_ONLY_SER，OFF_HEAP减少了垃圾回收的花费，允许更小的执行者共享内存池。这使其在拥有大量内存的环境下或者多并发应用程序的环境中具有更强的吸引力。</td>
</tr>
</tbody></table>
<h3 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="number">1</span> to <span class="number">100</span>)</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">16</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd.cache</span><br><span class="line">res13: rdd.<span class="keyword">type</span> = <span class="type">ParallelCollectionRDD</span>[<span class="number">16</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd.persist</span><br><span class="line">res14: rdd.<span class="keyword">type</span> = <span class="type">ParallelCollectionRDD</span>[<span class="number">16</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>默认持久化到内存中，可切换等级调整到硬盘，具体看什上面的存储级别</p>
</blockquote>
<blockquote>
<p>Spark程序执行结束后，cache()与persist()中的内容会被清空</p>
</blockquote>
<blockquote>
<p>cache()与persist()操作也只能在遇到行动算子后才会执行持久化</p>
</blockquote>
<blockquote>
<p>RDD的持久化方法，同样适用于后面会出现的DataFrame以及DataSet</p>
</blockquote>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>cache() 是persist的一种 准确说是 persist(StorageLevel.MEMORY_ONLY)。 </p>
<h2 id="RDD检查点"><a href="#RDD检查点" class="headerlink" title="RDD检查点"></a>RDD检查点</h2><p>cache()与persist()中的内容会被清空，无法长期保存</p>
<p>检查点可以将RDD状态保存在硬盘中，在需要的时候又可以还原</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; sc.setCheckpointDir(<span class="string">&quot;/root/checkpoint&quot;</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; sc.setCheckpointDir(<span class="string">&quot;/root/checkpoint&quot;</span>)    <span class="comment">//设置检查点路径</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="number">1</span> to <span class="number">100</span>)</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">0</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd.checkpoint</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@master ~]# ls -l checkpoint/</span><br><span class="line">总用量 0</span><br><span class="line">drwxr-xr-x 2 root root 6 10月 10 02:58 56326811-6331-4a7c-884b-fb09a2a15954</span><br><span class="line">drwxr-xr-x 2 root root 6 10月 10 02:58 d2a3592b-c36b-4a57-8488-626da9b9d425</span><br></pre></td></tr></table></figure>

<blockquote>
<p>检查点只有在遇到行动算子后才会保存</p>
<p>当下次行动算子计算时，将直接调用检查点数据，不需要从头计算</p>
</blockquote>
<h2 id="共享变量"><a href="#共享变量" class="headerlink" title="共享变量"></a>共享变量</h2><p>通常情况下(集群)，Spark应用程序会将个算子中的函数分配到多个Worker节点运行，若一个算子使用了某个外部变量，那该变量就会被复制到该Worker节点上的每个Task任务中。由于各个Task相互独立，当该变量存储的数据非常大时(例如存储了100M的SCV文件的源数据),那就回导致网络传输以及内存开销明显加大，因此可能会导致些许性能问题</p>
<p>Spark提供了两种共享变量，广播变量以及累加器,学过Flink这些应该不会陌生</p>
<h3 id="默认的变量传递"><a href="#默认的变量传递" class="headerlink" title="默认的变量传递"></a>默认的变量传递</h3><figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> arr = <span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">arr: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; rdd.map(x =&gt; (x,arr)).collect</span><br><span class="line">res4: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Array</span>[<span class="type">String</span>])] = <span class="type">Array</span>((<span class="type">A</span>,<span class="type">Array</span>(<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>, <span class="type">D</span>)), (<span class="type">B</span>,<span class="type">Array</span>(<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>, <span class="type">D</span>)), (<span class="type">C</span>,<span class="type">Array</span>(<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>, <span class="type">D</span>)), (<span class="type">D</span>,<span class="type">Array</span>(<span class="type">A</span>, <span class="type">B</span>, <span class="type">C</span>, <span class="type">D</span>)))</span><br></pre></td></tr></table></figure>

<p>这是个简单的案例，有一个存放在Driver的外部变量arr，arr被用在map算子中，arr将被发送给每个Task</p>
<p>但要是arr是一个100M的数据，那每个Task去维护100M大小的数据副本，要是某个Executor启动了4个Task，那就共有400M是数据副本，消耗内存不说，还有带来较大的网络开销</p>
<h3 id="广播变量"><a href="#广播变量" class="headerlink" title="广播变量"></a>广播变量</h3><p>广播变量是一个在每个Worder节点的一个只读缓存，该变量无论你有几个Task都只发送一次，每个Worder节点也只存在一个广播变量</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> broadcastArr = sc.broadcast(arr)</span><br><span class="line">broadcastArr: org.apache.spark.broadcast.<span class="type">Broadcast</span>[<span class="type">Array</span>[<span class="type">Int</span>]] = <span class="type">Broadcast</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; rdd.map(x =&gt; (x,broadcastArr)).collect</span><br><span class="line">res5: <span class="type">Array</span>[(<span class="type">String</span>, org.apache.spark.broadcast.<span class="type">Broadcast</span>[<span class="type">Array</span>[<span class="type">Int</span>]])] = <span class="type">Array</span>((<span class="type">A</span>,<span class="type">Broadcast</span>(<span class="number">2</span>)), (<span class="type">B</span>,<span class="type">Broadcast</span>(<span class="number">2</span>)), (<span class="type">C</span>,<span class="type">Broadcast</span>(<span class="number">2</span>)), (<span class="type">D</span>,<span class="type">Broadcast</span>(<span class="number">2</span>)))</span><br></pre></td></tr></table></figure>

<p>可以发现，RDD中每个元素使用org.apache.spark.broadcast.Broadcast对象，它只在执行行动算子后复制一次到各个Worder节点,不管你Executor启动了几个Task，这个Worder节点只有一个变量</p>
<p>Broadcast对象只是一个简单的封装，你可以使用.value方法得到里面的值</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; broadcastArr.value</span><br><span class="line">res7: <span class="type">Array</span>[<span class="type">Int</span>] = <span class="type">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<h3 id="累加器"><a href="#累加器" class="headerlink" title="累加器"></a>累加器</h3><p>广播变量是将Driver中的变量广播并缓存到各个Worker节点，那累加器就是可以让Worker访问Driver中的特殊变量</p>
<p>若不是用累加器。由于Driver中的变量是复制到各个Worder的各个Task中，那就有一个问题，在Task中的修改，不影响Driver的外部变量</p>
<p>如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">sum: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">8</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd.foreach(x =&gt; sum += x)</span><br><span class="line"></span><br><span class="line">scala&gt; print(sum)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Driver中sum值未被更改，更改的仅仅是各个Task中被复制过去的sum</p>
<p>这时候可以使用累加器，累加器使用add()方法累加，使用value()方法取值</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> myAcc = sc.longAccumulator(<span class="string">&quot;myAcc&quot;</span>)</span><br><span class="line">myAcc: org.apache.spark.util.<span class="type">LongAccumulator</span> = <span class="type">LongAccumulator</span>(id: <span class="number">480</span>, name: <span class="type">Some</span>(myAcc), value: <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line">rdd: org.apache.spark.rdd.<span class="type">RDD</span>[<span class="type">Int</span>] = <span class="type">ParallelCollectionRDD</span>[<span class="number">9</span>] at makeRDD at &lt;console&gt;:<span class="number">24</span></span><br><span class="line"></span><br><span class="line">scala&gt; rdd.foreach(x =&gt; myAcc.add(x))</span><br><span class="line"></span><br><span class="line">scala&gt; print(myAcc.value)</span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>

<h2 id="扩充样例"><a href="#扩充样例" class="headerlink" title="扩充样例"></a>扩充样例</h2><h3 id="SparkRDD二次排序"><a href="#SparkRDD二次排序" class="headerlink" title="SparkRDD二次排序"></a>SparkRDD二次排序</h3><p>在项目目录下，存在一个文件sort.txt，内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4 5</span><br><span class="line">2 6</span><br><span class="line">4 6</span><br><span class="line">3 5</span><br><span class="line">1 5</span><br><span class="line">8 6</span><br><span class="line">4 7</span><br></pre></td></tr></table></figure>

<p>要求，每行按照第一个数字升序排序，当第一个数字相同时，按照第二个数字降序排序</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @author 20软件林泰圣</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Sort01</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">SecondSortKey</span>(<span class="params">val firstNum:<span class="type">Int</span>,val secondNum:<span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Ordered</span>[<span class="type">SecondSortKey</span>] <span class="keyword">with</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">compare</span></span>(that: <span class="type">SecondSortKey</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">      <span class="comment">//判断第一个数字是否相同</span></span><br><span class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.firstNum != that.firstNum)&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstNum - that.firstNum</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        that.secondNum - <span class="keyword">this</span>.secondNum</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">      .setAppName(<span class="string">&quot;Sort01&quot;</span>)</span><br><span class="line">      .setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> pairRDD:<span class="type">RDD</span>[(<span class="type">SecondSortKey</span>,<span class="type">String</span>)] = sc</span><br><span class="line">      .textFile(<span class="string">&quot;./sort.txt&quot;</span>)</span><br><span class="line">      .map(d =&gt; &#123;</span><br><span class="line">        (<span class="keyword">new</span> <span class="type">SecondSortKey</span>(</span><br><span class="line">          d.split(<span class="string">&quot; &quot;</span>)(<span class="number">0</span>).toInt,</span><br><span class="line">          d.split(<span class="string">&quot; &quot;</span>)(<span class="number">1</span>).toInt</span><br><span class="line">        ),d)</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sortRDD = pairRDD</span><br><span class="line">      .sortByKey()              <span class="comment">//将按照SecondSortKey排序</span></span><br><span class="line">      .map(_._2)</span><br><span class="line"></span><br><span class="line">    sortRDD.collect().foreach(d =&gt; &#123;</span><br><span class="line">      println(d)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1 5</span><br><span class="line">2 6</span><br><span class="line">3 5</span><br><span class="line">4 7</span><br><span class="line">4 6</span><br><span class="line">4 5</span><br><span class="line">8 6</span><br></pre></td></tr></table></figure>

<h3 id="SparkRDD数据倾斜问题解决"><a href="#SparkRDD数据倾斜问题解决" class="headerlink" title="SparkRDD数据倾斜问题解决"></a>SparkRDD数据倾斜问题解决</h3><p>案例来自《Spark大数据分析实战》</p>
<p>如果一个Spark作业有两个Stage(),Stage2依赖与Stage1时，Stage2必须要等另一个Stage1<code>完成时才能往下做</code></p>
<p>这时要是Stage1的任务量非常庞大，假如要1小时，Stage2只需要1秒，这个任务<code>分配不均</code>的现象就叫数据倾斜</p>
<p>数据倾斜会影响Spark应用程序的执行效率以及资源利用率</p>
<h4 id="解决数据倾斜的几个方法"><a href="#解决数据倾斜的几个方法" class="headerlink" title="解决数据倾斜的几个方法"></a>解决数据倾斜的几个方法</h4><ol>
<li><p>数据预处理</p>
<p>假设Spark数据都来自Hive或MySQL，那可以先在上面对数据进行预处理，尽量保证数据均匀，或者是先对数据进行一次聚合，在传入Spark时就不要那么多次的reduceByKey()操作,就能减少Shuffle操作，缓解数据倾斜</p>
</li>
<li><p>过滤掉导致数据倾斜的key</p>
<p>要是导致数据倾斜的key本身无意义，本身不参与计算或对结果无影响，那可以讲该key过滤掉</p>
</li>
<li><p>提高Shuffle的并行度</p>
<p>Spark RDD的Shuffer过程与MapReduce类似，会涉及数据重组和从分区，如果并行度设置不合适，那可能会导致多个Key被分配到一个分区，使得某一Task任务过大，影响性能</p>
<p>在使用聚合算子(xxxByKey相关)时，可以通过参数传入并行度，给原先分多个key的Task的任务分配到多个Task上，缓解问题</p>
</li>
<li><p>通过随机Key前缀进行双重聚合</p>
<p>在相同key中加上随机前缀，使得相同key被拆分到不同的key，就可以让原先分配在一个分区的key分配到多个分区，从而分配到多个key</p>
</li>
</ol>
<h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>有一数据文件，存放在hdfs:&#x2F;&#x2F;master:9000&#x2F;test&#x2F;word.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@master ~]# hadoop dfs -cat /test/word.txt</span><br><span class="line">DEPRECATED: Use of this script to execute hdfs command is deprecated.</span><br><span class="line">Instead use the hdfs command for it.</span><br><span class="line"></span><br><span class="line">hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello spark hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello spark hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello scala hello hello hello hello hello hello hello hadoop hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello spark hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello hello</span><br></pre></td></tr></table></figure>

<p>数据中hello量过大，若不处理，再进行聚合操作时，将发生数据倾斜</p>
<p>这时候我们使用随机Key前缀的方法环境数据倾斜问题，通过随机的key，能将量大的Hello分配给多个Stage，这样就避免一个Stage工作量过大的问题</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.sql.<span class="type">SparkSession</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.util.<span class="type">Random</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DataLean</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> spark = <span class="type">SparkSession</span></span><br><span class="line">      .builder()</span><br><span class="line">      .appName(<span class="string">&quot;DataLean&quot;</span>)</span><br><span class="line">      .master(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">      .getOrCreate()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sc = spark.sparkContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> wordRDD = sc.textFile(<span class="string">&quot;hdfs://master:9000/test/word.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> result = wordRDD</span><br><span class="line">      .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      .map(x =&gt; &#123;                          <span class="comment">//添加前缀</span></span><br><span class="line">        <span class="keyword">val</span> random = <span class="type">Random</span>.nextInt(<span class="number">10</span>)    <span class="comment">//0-9随机数</span></span><br><span class="line">        (random + <span class="string">&quot;_&quot;</span> + x ,<span class="number">1</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">      .reduceByKey((a,b) =&gt; &#123;a + b&#125;)</span><br><span class="line">      .map(x =&gt; &#123;                          <span class="comment">//去除前缀</span></span><br><span class="line">        <span class="keyword">val</span> word = x._1.split(<span class="string">&quot;_&quot;</span>)(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">val</span> count = x._2</span><br><span class="line">        (word, count)</span><br><span class="line">      &#125;)</span><br><span class="line">      .reduceByKey((a,b) =&gt; &#123;a + b&#125;)       <span class="comment">//总聚合</span></span><br><span class="line"></span><br><span class="line">    println(result.collect().mkString(<span class="string">&quot;Array(&quot;</span>, <span class="string">&quot;, &quot;</span>, <span class="string">&quot;)&quot;</span>))</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Array((scala,1), (hello,275), (spark,3), (hadoop,1))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记分享</category>
      </categories>
      <tags>
        <tag>Spark</tag>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统与存储器管理</title>
    <url>/article/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<blockquote>
<p>以下内容涉及知识点较深，可能有误，望指出。参考时建议再次查证内容的准确性。</p>
<p>本篇是以OS的视角，研究分页和分段存储优先看这篇</p>
</blockquote>
<p>冯诺依曼型计算机是由运算器、存储器、控制器、输入设备和输出设备五大部件组成，现存计算机都遵循该设计</p>
<p>存储器是一种用于存储程序和数据信息的部件，是一种时序电路</p>
<h1 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h1><p>在计算机执行指令时，基本上都会涉及到存储器的访问，故存储器的性能影响到计算机的运行效率。</p>
<p>但如今随着计算机技术的发展，对存储器的容量需求也越来越大，通常一种存储器无法同时满足快速与大容量甚至低廉的成本，故现在计算机均采用多层次的存储器设计。</p>
<span id="more"></span>

<p>对于通用计算机，通常将存储器分为三个层次，与中央处理器(CPU)的距离由近到远分为：</p>
<ul>
<li><p>寄存器</p>
<p>寄存器常封装在CPU内部，用于暂时存放指令、数据、运算结果，以便CPU能够更快速地访问和操作这些数据。</p>
<p>由于与核心相连，寄存器具必须有与CPU相同的执行速度，故寄存器的生产成本高。</p>
<p>为使CPU在执行指令时能够直接、高效的操作寄存器里的数据，<code>通常</code>寄存器的长度与CPU的位数一致，例如：在32位CPU中，寄存器的长度是32位，能够存储一个32位的数值。</p>
</li>
<li><p>主存储器</p>
<p>主存储器也被称为内存，也有人叫它可执行存储器，可由CPU直接随机存取。</p>
<p>主存储器在速度上逊色于寄存器，当主存储器的容量要比寄存器大得多</p>
<p>主存储器可用于缓存辅助存储器的数据，现代计算机设计，为了提高性能的同时兼顾价格，常常采用多级的主存储器设计。</p>
<ul>
<li><p>高速缓冲存储器</p>
<p>也被称为高数缓存，被封装在CPU内部。</p>
<p><code>与寄存器不同</code>，高速缓存被设计为CPU与其他主存之间，由静态存储芯片(SRAM)，其速度接近于与CPU的速度，容量小于其他主存但比寄存器要大得多，用于缓存其他主存的数据以加速CPU对主存的存取速度，可以显著减少CPU访问主存的延迟。</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E9%AB%98%E6%95%B0%E7%BC%93%E5%AD%98%E4%B8%8E%E4%B8%BB%E5%AD%98%E7%9A%84%E5%B1%82%E6%AC%A1.png" alt="高数缓存与主存的层次"></p>
<p>在现代CPU设计中，高速缓存也被设计成多级结构，通常分为三个级别，等级越高(数字越小)，速度越快、容量越小。</p>
<ul>
<li>L1缓存时计算机中最快的主存储器，当然一般也最小，普遍以KB为单位，部分高端CPU可达1M(例如AMD 7950X)甚至更高，L1缓存常被分割为指令缓存与数据缓存，通常用于存储CPU正在操作的内容。</li>
<li>L2缓存要比L1大不少，通常在256KB-16MB左右(2023年)，L2缓存通常存放着CPU下一步可能要执行的内容，通常与L1缓存一样，L2缓存也被封装在CPU核心内部，但不像L1缓存直接与核心相连。</li>
<li>L3缓存，在现在计算机设计中，L3缓存是CPU中最大的主存，通常被封在CPU中单独区域，由多个核心甚至是核显共享。</li>
</ul>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E5%B1%82%E6%AC%A1.png" alt="高速缓存的层次"></p>
<p align="center" style="font-size: x-small;">图片来源见水印</p>

<p>CPU会优先在L1缓存中寻找，然后是L2、L3以及其他主存，若CPU在L1中找到指令或数据，则称之为缓存命中，缓存的命中率是高速缓存的一项重要性能指标</p>
</li>
<li><p>主存储器</p>
<p>  这里的主存储器应该要理解为现在计算机中的内存条，在辅助存储器与高速缓存之间</p>
</li>
<li><p>磁盘缓存</p>
<p>  由于当今磁盘的IO速度要明显低于主存储器，故在现代计算机设计中使用磁盘存储器暂存磁盘中频繁使用的数据，降低磁盘IO负载。</p>
<p>  磁盘缓存可能是系统内存或由分装在磁盘PCB上独立的存储器如SRAM（静态随机存取存储器）负责</p>
<p>  由于操作系统对磁盘的写入操作可能未能及时从磁盘缓存存储到磁盘中，故在磁盘意外断电时可能会导致应存入磁盘的数据发生丢失。</p>
</li>
</ul>
<blockquote>
<p>高速缓存与磁盘缓存，属于主存储器，而不是寄存器和辅助存储器</p>
</blockquote>
</li>
<li><p>辅助存储器</p>
<p>辅助存储器又被称为外存储器，此类储存器一般采用非易失的存储介质制成，通常断电后能保留数据，如磁盘、固态硬盘、光盘等。</p>
<p>辅助存储器不可由CPU直接寻址，通常在使用时由操作系统(OS)读取并缓存在主存储器中，这也是主存储器被称为可执行存储器的原因。</p>
</li>
</ul>
<p>不同层次的存储器会由OS进行统一管理</p>
<h1 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h1><h2 id="随机访问存储器"><a href="#随机访问存储器" class="headerlink" title="随机访问存储器"></a>随机访问存储器</h2><p>也被称为随机存取存储器(RAM)，被分为两类:SRAM(Static Random Access Memory,静态随机存储器)与DRAM(Dynamic Random Access Memory,动态随机存储器)，SRAM更快，成本也相对更高。</p>
<p>RAM工作时(刷新时除外)可以随时从任何一个指定的地址写入（存入）或读出（取出）信息</p>
<p>RAM的读写速度很快，但存储其中的数据是易失的，这就意味着一旦断电存储的说有数据将丢失，故常被用作临时的存储介质</p>
<h3 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h3><p>SRAM通常采用6管MOS制成，这种电路结构天生在通电时具有双稳态性（也就是图中，要么1，要么3，在其他状态都是不稳定的，会很快的恢复到一个稳定状态下）</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%8F%8C%E7%A8%B3%E6%80%81%E6%80%A7.png" alt="双稳态性"></p>
<p>正是由于双稳态性，SRAM<code>无需刷新即可保持在稳定值</code>，即使受到干扰，在干扰消除时也可很快恢复，这些特点使其特别适用于需要高速访问和可靠存储数据的场景，如CPU与主存之间的高速缓存、CPU内部的L1&#x2F;L2等</p>
<p>但由于SRAM集成密度小、芯片面积大、成本高，现如今DRAM仍是主流</p>
<h3 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h3><p>DRAM采用电容对数据位进行存储，正是由于采用电容来存储bit数据，由于存储在电容器上的电荷会随着时间的推移而泄漏，因此DRAM<code>需要定期刷新</code>以确保数据的完整性</p>
<p>DRAM存储器对干扰非常敏感，若电容的电压被扰乱就永远无法恢复</p>
<p>DRAM相较于SRAM拥有更高的密度，这也意味着成本更低，但速度要比SRAM慢</p>
<h2 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h2><p>非易失性存储器:即即使在断电后，仍能保持器数据的存储器</p>
<h3 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h3><p>只读存储器(Read-Only Memory，ROM)，原本是指一种以非破坏性读出方式工作，只能读出无法写入信息的存储器，但随着技术的发展，现如今部分ROM可以实现读写</p>
<p>在计算机主板PCB上封装着一块ROM，用于存放固件(firmware)，这块存储器也属于内存的一种，也可由CPU直接寻址，同样例如显卡、磁盘驱动器等复杂的设备，也需要由固件翻译来自CPU和I&#x2F;O设备的请求</p>
<h3 id="PROM"><a href="#PROM" class="headerlink" title="PROM"></a>PROM</h3><p>可编程只读存储器（Programmable ROM，PROM）允许用户通过专用的设备（编程器）一次性写入自己所需要的信息，这类存储器只可被编程一次，被编写的数据会被永久性保存。</p>
<p>PROM的每个单元时一种融丝，在出厂时，PROM中的数据全为1&#x2F;0，由用户使用时，再通过编程使PROM存储需要的数据，此时熔丝熔断，数据被写入，这也是只能被编程一次的原因</p>
<h3 id="EPROM"><a href="#EPROM" class="headerlink" title="EPROM"></a>EPROM</h3><p>可编程可擦除只读存储器（Erasable Programmable Read Only Memory，EPROM）可多次编程，是一种以读为主的可写可读的存储器，在写入新数据时，需要把原先的内容先擦除才能写入。</p>
<p>EPROM会留有一个透明的石英窗口，当紫外线透过窗口照射在EPROM单元上，该单元会被重置为0。故EPROM需要使用专用设备才能进行擦写。</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/EROM.jpg" alt="EROM"></p>
<p>RPROM采用MOS管，速度较慢</p>
<h3 id="EEPROM"><a href="#EEPROM" class="headerlink" title="EEPROM"></a>EEPROM</h3><p>电可擦可编程序只读存储器（Electrically Erasable Programmable Read-Only Memory，EEPROM）是一种可以随时写入而无需先擦除原先内容的存储器，在写入时，也无需使用专用设备。</p>
<p>EEPROM的写入往往要比读取的速度慢</p>
<h3 id="Flash"><a href="#Flash" class="headerlink" title="Flash"></a>Flash</h3><p>快擦除读写存储器( Flash Memory)是一种高密度、非易失性的读&#x2F;写半导体存储器。</p>
<p>其擦写速度要比EERPOM快得多，目前，闪存已广泛用于制作各种移动存储器，如U盘及数码相机&#x2F;摄像机所用的存储卡等。</p>
<h1 id="程序的装入与链接"><a href="#程序的装入与链接" class="headerlink" title="程序的装入与链接"></a>程序的装入与链接</h1><p>要在系统中运行用户程序，就必须将其由外存装入到内存中，并将其转化为一个可执行的程序，</p>
<p>在此过程中，会经历以下三步:</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4.jpg" alt="处理用户程序的三个步骤"></p>
<h2 id="地址绑定"><a href="#地址绑定" class="headerlink" title="地址绑定"></a>地址绑定</h2><p>以CPU的视角，生成的地址通常为<code>逻辑地址(Logic Address)</code>，也叫相对地址.<a href="../X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80-logical-address">另一篇文字细说</a></p>
<p>以内存单元的视角，能看到的地址为<code>物理地址(Physical Address)</code>，也叫绝对地址<a href="../X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80-physical-address">另一篇文字细说</a></p>
<p>在编译和装入的过程中，地址绑定会产生相同的逻辑地址和物理地址</p>
<p>在执行时，地址绑定会生成不同的逻辑地址和物理地址，此时成逻辑地址为<code>虚拟地址(Virtual Address)</code></p>
<p>由程序所生成的所有逻辑地址集合被称为<code>逻辑地址空间(Virtual Address Space)</code></p>
<p>由这些逻辑地址所对于的物理地址的集合被称为<code>物理地址空间(Physical Address Space)</code></p>
<h2 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h2><p>内存保护是操作系统对电脑上的内存进行访问权限管理的一个机制。其主要目的是防止某个进程去访问不是操作系统配置给它的寻址空间，从而防止该进程因某些程序错误或问题而有意或无意地影响到其他进程或是操作系统本身的运行状态和数据，保证进程之间不会相互影响。</p>
<p>这种保证通常时基于硬件实现的，因为一旦OS进行干预就会严重影响性能</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>一种由编译器(一种程序)将用户程序进行处理，并转换为若干模块的过程，这一过程就是编译</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>由链接程序将编译后产生的<code>一组目标模块</code>以及<code>所需的库函数</code>链接到一起，形成一个完整的装入模块的过程</p>
<p>根据进行装配的时机不同，分为一下三种</p>
<h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>在程序<code>运行前</code>，先将各目标模块以及其所需函数库链接成一个完整的装配模块，以后<code>不再拆开</code>,</p>
<p>静态链接有以下特点:</p>
<ul>
<li>代码装载速度快、执行速度略快与动态转载</li>
<li>只需保证开发者电脑上有正确的函数依赖库文件，再以二进制形式发布程序时无需考虑用户电脑上库文件是否存在或版本问题</li>
<li>生成的可执行文件大、可执行文件包含公共代码</li>
<li>每次需要更新其中的目标模块时，则需要重新打开装入模块，影响效率。</li>
</ul>
<p>在模块装配时，需解决以下问题:</p>
<blockquote>
<p>设有三个模块A、B、C，长度分别为L、M、N，A模块调用B模块；B模块调用C模块</p>
</blockquote>
<blockquote>
<p>这部分内容与书本有出入，待核实！！</p>
</blockquote>
<ul>
<li><p>修改相对地址</p>
<p>由于上一步编译所产生的目标模块(A、B、C)中所采用的都是相对地址，每个目标模块之间的起始地址都是0，而将其装转载为一个模块时，除原模块A外，被调用的B、C模块在装入模块中的起始位置将不再为0.</p>
<p>B模块的起始位置为L(0 + A模块长度)</p>
<p>C模块的起始位置为L+M(B模块的起始位置 + B模块的长度)</p>
<p>也就是在装入模块中，各目标按顺序相连</p>
</li>
<li><p>变换外部调用信号</p>
<p>由于模块的起始位置发生变化，则要将所用的外部调用符号改为装入模块中的相对位置</p>
<p>CALL B 指向的就是L</p>
<p>CALL C 指向的就是 L + M</p>
</li>
</ul>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>动态链接则是不一口气将模块装入，而是按需装入</p>
<p>具有以下特点:</p>
<ul>
<li><p>生成的可执行文件较静态链接生成的可执行文件小；</p>
</li>
<li><p>适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试；</p>
</li>
<li><p>不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；</p>
</li>
<li><p>DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；</p>
</li>
<li><p>使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息；</p>
</li>
<li><p>速度比静态链接慢；</p>
</li>
</ul>
<h4 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h4><p>将用户源程序编译后得到的一组目标模块，<strong>在装入内存时</strong>，采用边装入边链接的方式。</p>
<p>当发生一个外部调用事件，则让装入程序去找到被调用的外部目标模块，并装入。</p>
<h4 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h4><p>对某些目标模块的链接，是在程序执行中需要该模块时才进行的。其优点是便于<strong>修改和更新，便于实现对目标模块的共享</strong>。</p>
<h2 id="装入"><a href="#装入" class="headerlink" title="装入"></a>装入</h2><p>也被称为加载：由装入程序 将装入模块 装入内存的过程</p>
<h3 id="绝对装入方式"><a href="#绝对装入方式" class="headerlink" title="绝对装入方式"></a>绝对装入方式</h3><p>当计算机系统很小，且仅能运行<code>单道程序</code>时(即:所有进程一个一个排对执行。若A阻塞，B只能等待的一种程序设计)，此时用户程序在编译后产生的目标模块会带有一个目标代码，代码中包含模块所要装载的位置，这个位置是个内存中的绝对地址。也可以理解为，此时编译产生的目标模块内，逻辑地址&#x3D;物理地址，程序中的所有内存引用都是基于这个绝对地址。</p>
<blockquote>
<p>绝对装入方式仅适用于单道程序环境，因为在多道程序环境中，编译器无法预知编译后的程序该放在内存中的何处</p>
</blockquote>
<h3 id="可重定向装入方式"><a href="#可重定向装入方式" class="headerlink" title="可重定向装入方式"></a>可重定向装入方式</h3><p>装入时对目标程序中指令和数据的修改过程称为<strong>重定位</strong>，因此可以将模块装载在内存的’’任何位置’’，地址变换通常实在装入时<strong>一次完成的</strong>，所以又称静态重定位</p>
<p>由于是一次性完成，故在装入内存时，需为装入模块分配全部的内存空间，这段空间应该是连续的。</p>
<p>若此时系统内存剩余容量不足以装载模块时，模块将不会被装载</p>
<p>若容量足够，但无连续空间装载模块时，OS可能会尝试移动其他模块，以空出合适的空间装载模块。</p>
<p>本方式在装载模块后<code>不允许程序运行时在内存中移动位置</code>，此时对模块的移动会影响模块中数据地址发生错误。</p>
<h3 id="动态运行时装入方式"><a href="#动态运行时装入方式" class="headerlink" title="动态运行时装入方式"></a>动态运行时装入方式</h3><p>装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转化为绝对地址，而是把这种地址转换<strong>推迟到程序真正要执行时才进行</strong>。因此装入内存后的所有地址均为逻辑地址，这种方式需要一个重定位寄存器的支持。</p>
<p>故这种装入方式，允许程序在内存中发生移动，且在程序运行前只装载部分代码，后续再陆续按需动态分配内存，故这种装入方式可将程序分配在不连续的内存中。</p>
<h1 id="存储分配方式"><a href="#存储分配方式" class="headerlink" title="存储分配方式"></a>存储分配方式</h1><p>为使用户程序装入内存，则必须为其分配一定大小的存储空间</p>
<h2 id="连续分配存储方式-分区"><a href="#连续分配存储方式-分区" class="headerlink" title="连续分配存储方式(分区)"></a>连续分配存储方式(分区)</h2><p>简称连续分配方式，被广泛用于20世纪60-80年代的OS</p>
<p>这种分配方式为用户程序只分配<code>一段连续的内存空间</code>，用户程序中的代码或数据被放置在<code>连续的内存空间</code>中</p>
<h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>在早期单道批处理系统的小型机中，内存常被分为<code>系统内存区</code>和<code>用户内存区</code>，系统内存区被分配至低位，而高位的其他空间，也就是用户内存区中<code>仅有一道用户程序</code>，故整个用户内存区有一个用户程序独占，而这种存储分配方式称为单一内存分配。</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E7%94%A8%E6%88%B7%E5%8C%BA%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%8C%BA.jpg" alt="用户区与系统区"></p>
<p>正因如此，早期部分的单用户单任务的OS，并未采取存储器保护机制，这是因为单用户环境不存在用户之间互相干扰的问题，并且若OS部分内存遭受破坏，课程通过重启重新载入，相对影响较小，而不采取保护机制，可以节约硬件资源</p>
<h3 id="固定连续分配"><a href="#固定连续分配" class="headerlink" title="固定连续分配"></a>固定连续分配</h3><p>20世纪60年代出现了多道程序系统，为使得内存可以装入多道程序，且这些程序之间不会互相干扰，于是将用户用户内存区的空间划分为多个大小固定的区域，这些区域也被称为分区，每个分区只装入一个作业。这也是最早的、最简单的一种可以运行多道程序的分区式存储方式。</p>
<p>此时加入用户空间中有4个分区，那么现在便能允许4个程序并发运行并且互不干扰。当一个作业结束时，分区将空出，并从外存中后备作业列队中选择一个合适大小的作业装入。</p>
<p>虽然这种分配方式实现简单，但可能会出现当用户程序过于大，可能所有分区都无法满足需求，此时还需使用覆盖技术解决，影响性能</p>
<p>且分区技术虽不会产生外部碎片，但会产生内部碎片。</p>
<h4 id="分区的划分"><a href="#分区的划分" class="headerlink" title="分区的划分"></a>分区的划分</h4><p>分区的大小可以时相等或是不相等的</p>
<ul>
<li><p>分区大小相等</p>
<p>将用户空间内的分区划分为多个<code>等大的</code>分区</p>
<p>这种分区方式适合<code>一台计算机同时控制多个相同对象</code>的场合</p>
<p>但这种方法<code>缺少灵活性</code>，当程序太小时，会造成空间的浪费，若程序太大，一个分区将装不下该程序</p>
</li>
<li><p>分区大小不等</p>
<p>将存储器划分为多个<code>大小不等</code>的分区，分区大小视系统中作业大小决定</p>
<p>通常OS会创建较多的小分区，适量的中分区以及少量的大分区</p>
</li>
</ul>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F%E5%88%92%E5%88%86_%E5%8A%A8%E6%80%81%E6%88%96%E9%9D%99%E6%80%81.jpg" alt="分区大小划分——动态或静态"></p>
<h4 id="内存的分配"><a href="#内存的分配" class="headerlink" title="内存的分配"></a>内存的分配</h4><p>为方便内存分配，OS常将分区按照其大小进行排队，并建立一张分区表。</p>
<p>表通常使用数组或链表实现，记录有分区大小、起始地址、是否已被分配状态等信息。</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D_%E5%88%86%E5%8C%BA%E8%A1%A8.jpg" alt="连续分配_分区表"></p>
<h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><p>动态分区分配属于可变分区分配，它是<code>不会事先划分内存分区</code>，而是根据实际需求动态的对为用户程序<code>分配合适的内存空间</code>。</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.jpg" alt="动态内存分区"></p>
<h4 id="使用数据结构记录使用情况"><a href="#使用数据结构记录使用情况" class="headerlink" title="使用数据结构记录使用情况"></a>使用数据结构记录使用情况</h4><p>为实现动态分区分配，OS必须配置相应的数据结构，以描述分区的分配情况，进而为分区的分配提供依据。</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="示意图"></p>
<p>以这张内存分配情况示意图举例，常用的数据结构有以下两种：</p>
<ul>
<li><p>空闲分区表</p>
<p>OS将建立一张表，于之前的分区表类似，只不过用于记录<code>空闲分区</code>，表中每个条目表示一个空闲分区，条目包含分区号、分区大小、起始位置等数据，如下图所示。</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E7%A9%BA%E9%97%B2%E5%88%86%E5%8C%BA%E8%A1%A8.jpg" alt="空闲分区表"></p>
</li>
<li><p>空闲分区链</p>
<p>为实现空闲分区的分配和链接，在每个分区的头部设置一些用于表示分配信息的控制位以及一个向前的指针，并在每个分区尾部设置一个向后的指针。</p>
<p>这就使得空闲分区形成一个双向的连表，如下：</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E7%A9%BA%E9%97%B2%E5%88%86%E5%8C%BA%E9%93%BE.jpg" alt="空闲分区链"></p>
</li>
</ul>
<h4 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h4><p>若多个分区都满足需求，那作业应该装入到那个分区，这就有相应的动态分区分配算法决定。</p>
<p>由于分配算法往往对系统性能会产生较大影响，故人们发明了很多中算法，如下:</p>
<h5 id="基于顺序搜索"><a href="#基于顺序搜索" class="headerlink" title="基于顺序搜索"></a>基于顺序搜索</h5><ul>
<li><p>首次适应(First Fit,FF)算法</p>
<p>该算法由地址地位向上顺序查找，直到一个大小合适的分区为止。</p>
<p>若遍历整个链后任无法找到一个合适的分区，则表明目前系统只能没有合适大小的空闲分区，也就意味着内存分配失败。</p>
<p>该算法的特点是，在分配内存时，会更加<code>倾向使用低位空间</code>，而高位往往保留着大量空闲的空间，方便以后到达的大作业的使用，但由于频繁划分地位空间，会导致地位保留许多难以利用的小空闲分区，也就是碎片，这些碎片也会增大查找空闲分区的开销，如下：</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.jpg" alt="首次适应算法"></p>
</li>
<li><p>循环首次适应(Next Fit,NF)算法</p>
<p>循环首次适应算法于首先适应算法类似，只不过在查找空闲分区时，并不每次从链首开始查找，而是<code>基于上次查找到的空闲分区</code>的位置向上进行查找</p>
<p>这么做时可以有效避免过度倾向使用地位的空间，可以使空闲分区分布更加均匀，缓解一个地方堆积大量无法利用的碎片，但这么做会使得空间中连续的大块分区变少。</p>
<blockquote>
<p>应该看得懂，就不配图了</p>
</blockquote>
</li>
<li><p>最佳适应(Best Fit,BF)算法</p>
<p>最佳：指的是将最小可用的空闲分区分配给作业</p>
<p>最佳适应算法将所有可用空闲分区<code>由小到大</code>排序，形成空闲分区链。当需要装入作业时，由小至大遍历分区链，直到找到一个<code>可以容纳作业的最小空闲分区</code>，将作业装入该分区，由于倾向于使用小分区，则会更有可能保留大分区以应对大作业。如下：</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.jpg" alt="最佳适应算法"></p>
<p>孤立的看，这种算法貌似是最好的，因为看上去每次浪费的空间是最小的，但长远来看，由于每次装入后产生的空闲分区也最小，着也导致后续会产生大量无法利用的碎片</p>
</li>
<li><p>最坏使用(Worst Fit,WF)算法</p>
<p>最坏：也就是和最好唱反调</p>
<p>最佳适应算法将所有可用空闲分区<code>由大到小</code>排序，形成空闲分区链。当需要装入作业时，由大至小遍历分区链。</p>
<p>由于更加倾向于使用大分区，故这种算法必然会导致存储器中缺乏大空闲分区，也就意味着当有大作业时，很有可能会因为没有合适的分区而导致内存分配失败。</p>
<p>但换个角度看，最坏使用算法每次被切割后产生的空闲分区并不小，被利用的概率要比最佳使用算法要好，故对小作业场景更有好，所以最坏也未必坏</p>
<blockquote>
<p>应该看得懂，就不配图了</p>
</blockquote>
</li>
</ul>
<h5 id="基于索引搜索"><a href="#基于索引搜索" class="headerlink" title="基于索引搜索"></a>基于索引搜索</h5><ul>
<li><p>快速适应算法</p>
<p>OS先依据常用的分区大小(大小由OS决定)，先将用户空间划分为<code>若种不同大小的分区</code>，分区<code>不再被二次分割</code>，再将<code>相同大小的分区建立单独的空闲分区链表</code>，然后再交友一张索引表管理。</p>
<p>当有作业需要装入时，系统会在索引表中找到最小可容纳的分区大小，然后去对应链表中拿一个分区用于装入作业。</p>
<p>可以看出，快速适应算法比较复杂，对于装入过程，查找效率高，且倾向于使用更小的空闲分区，但在分区回收时，由于算法复杂，对系统开销也大。</p>
<p>而且由于分区不再被二次分割，虽然不会产生外碎片，但会产生内碎片</p>
<blockquote>
<p>欸，要是小分区都用完了，这时还有很多小作业怎么办</p>
<p>还能怎么办，这时只能学迪拜土豪，拿大分区装小作业，这也是一种典型的拿空间换时间的做法</p>
</blockquote>
</li>
<li><p>伙伴系统</p>
<p>伙伴系统相对而言就没那么死板</p>
<p>伙伴系统规定，无论分区是否被分配，<code>所有分区都必须是2ᵏ(k为整数，n ≤ k ≤ m)</code>，2ⁿ为分配的最小分区大小，2ᵐ为可分配的最大分区大小，通常2ᵐ为整个可分配内存</p>
<p>系统启动初期，只有一个空闲分区，也就是整个内存</p>
<p>随着系统的运行，由于不断划分，会产生若干个不同大小的分区</p>
<p>对于相同的大小的所有空闲分区，会为其单独设立一个空闲分区链表，</p>
<p>若装载一个大小为k的作业，首先计算出一个值i，使得<code>2ⁱ⁻¹ &lt; k ≤ 2ⁱ</code></p>
<p>然后尝试去大小为2ⁱ的空闲分区链表中找到一个空闲分区，若能，则将该分区分配给该作业独享</p>
<p>若此时无可满足大小的分区，则尝试<code>向2ⁱ⁺¹大小的空闲分区链</code>表查找是否有空闲分区，若有，借用一个2ⁱ⁺¹大小的空闲分区，将其<code>拆分为两个2ⁱ大小的空闲分区</code>，并将其中一个分配给作业独享，剩余一个加入2ⁱ大小的空闲分区链表中备用</p>
<p>如此循环，直到遍历到最大的分区链表，若还找不到，则分配失败</p>
<p>被拆分的分区被称为’一对伙伴’，在回收分区时也将被合并</p>
<p>伙伴系统依旧存在内碎片，但要比快速适应算法好得多。</p>
</li>
<li><p>哈希算法</p>
<p>哈希(Hash)：一种散列函数，可以将任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。同一输入得到的哈希值是唯一的，哈希值很难被逆向。</p>
<p>哈希表作为一种高效的数据存储结构，可以使数据的存储位置与关键码之间建立一一映射的关系，从而加快元素的搜索速度，这里不细究原理。</p>
<p>基于哈希快速查找的优点，将空闲空间大小作为关键字，并将这些关键字经过计算得到哈希值，并再将这些哈希值存储到一个链表中，这就得到了一个哈希表。</p>
<p>在需要分配空间时，将按照需要分配的空间大小，提供哈希计算出相应空闲分区链表在哈希表中的位置，并取出一个空闲分区分配。</p>
<p>利用哈希主要还是利用其特性加速查找。</p>
</li>
</ul>
<h4 id="可变分区的分配与回收"><a href="#可变分区的分配与回收" class="headerlink" title="可变分区的分配与回收"></a>可变分区的分配与回收</h4><h5 id="可变分区的分配"><a href="#可变分区的分配" class="headerlink" title="可变分区的分配"></a>可变分区的分配</h5><p>设请求的分区大小为u.size，空闲分区表中每个空闲分区大小为m.size，事先规定的最小不可切分大小为size</p>
<ul>
<li><p>当当前空闲分区小于请求分区大小时，也就是<code>u.size &gt; m.size</code>，将继续向下一表项遍历</p>
</li>
<li><p>若当前空闲分区在分配后剩余的空间小于等于不可分割的大小，也就是<code>m.size - u.size ≤ size</code>，则将这个空闲分区<code>不切割</code>进行分配</p>
</li>
<li><p>若剩余大小大于不可分割的大小，则分配u.size大小的分区</p>
</li>
</ul>
<p><img data-src="/image/%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98_%E6%B5%81%E7%A8%8B.png" alt="分配内存_流程"></p>
<h5 id="可变分区的回收"><a href="#可变分区的回收" class="headerlink" title="可变分区的回收"></a>可变分区的回收</h5><p>系统在回收分区时，会从当前链表中找到相应的插入点用于插入空闲分区信息，此时就存在以下3种情况</p>
<ul>
<li><p>回收区时插入点与一个分区相邻时，合并这两个分区</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E4%B8%80%E4%B8%AA%E7%9B%B8%E9%82%BB%E5%88%86%E5%8C%BA%E6%97%B6_%E5%9B%9E%E6%94%B6.png" alt="一个相邻分区时_回收"></p>
</li>
<li><p>回收区时插入点与前后各一个分区相邻时，合并这三个分区</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E4%B8%A4%E4%B8%AA%E7%9B%B8%E9%82%BB%E5%88%86%E5%8C%BA%E6%97%B6_%E5%9B%9E%E6%94%B6.png" alt="两个相邻分区时_回收"></p>
</li>
<li><p>回收区时插入点与前后两个分区都不相连时，此时单独新建一个表项，并将其按照回收区的起始位置插入到表中合适位置</p>
</li>
</ul>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E4%B8%8D%E7%9B%B8%E9%82%BB%E5%88%86%E5%8C%BA%E5%9B%9E%E6%94%B6.png" alt="不相邻分区回收"></p>
<h3 id="动态重定向分配"><a href="#动态重定向分配" class="headerlink" title="动态重定向分配"></a>动态重定向分配</h3><p>在连续分配存储方式中，随着计算机的运行，计算机内存中将产生很多<code>小而零散</code>的分区，这些小分区难以被利用，这些分区也就是外碎片</p>
<h4 id="怎么解决"><a href="#怎么解决" class="headerlink" title="怎么解决"></a>怎么解决</h4><p><code>紧凑</code>是将内存中的作业进行移动，将它们<code>移动到一起</code>，以<code>腾出一块大的空闲</code>空间的方法</p>
<p>紧凑有时也被称作:紧缩、拼接</p>
<p>由于紧凑操作对内存中的程序和数据进行移动，这就导致位置发生改变，此时就需要对移动后的程序和数据进行<code>重定位</code></p>
<p>OS会在一段时间对内存进行一次紧缩和重定位操作，以确保系统的内存利用率，但这些操作比较复杂，其实对系统性能影响很大，过于频繁的操作可能会严重影响系统的性能</p>
<h2 id="分页存储方式"><a href="#分页存储方式" class="headerlink" title="分页存储方式"></a>分页存储方式</h2><p>连续分配方式在计算机的运行过程中会产生很多碎片，虽然可以提供紧凑解决，但对系统性能开销较大，如果允许<code>单个作业零散的被分配到不相邻的区域中</code>，就能更加有效的利用内存空间</p>
<p>分页存储方式中，将用户程序地址空间划分为若干各<code>大小固定的区域</code>，这些区域就是<code>页</code>也叫页面</p>
<p>每个页都有对于的编号，也就是<code>页号</code>，从0开始编号</p>
<p>每个页在物理内存中就是一段段连续的空间块，这些空间被叫做<code>页框</code>，同样页框也会从0开始编号，也就是<code>页框号</code>，页框号和页号是两个东西<br>$$<br>页框号 &#x3D; INT[逻辑地址 &#x2F; 单个页框长度]<br>$$<br>页框的在物理地址中的起始位置就是<code>页基址</code>，在页框大小相同时<br>$$<br>页基址 &#x3D; 页框号 * 页框大小<br>$$<br>程序&#x2F;数据在页框中的位置，<code>基于页基址的偏移量</code>叫<code>页内偏移量</code>，也叫<code>页内地址</code><br>$$<br>物理地址 &#x3D; 页基址 + 页内偏移量<br>$$<br><a href="../X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/#%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80-linear-address">更多细节可以参考这个</a></p>
<h3 id="页面大小与内碎片"><a href="#页面大小与内碎片" class="headerlink" title="页面大小与内碎片"></a>页面大小与内碎片</h3><p>页面的大小不是越大&#x2F;越小就越好</p>
<p>由于一个作业常常占不满分配给该作业的最后一个页，这就势必会产生内碎片</p>
<p>通过设置更小的页可以提高内存的利用率，但更小的页也将会使一个作业分配到更多的页，这会使该进程的页表过长，不仅占用内存，也会降低页面换入&#x2F;换出的效率</p>
<h3 id="分页地址结构"><a href="#分页地址结构" class="headerlink" title="分页地址结构"></a>分页地址结构</h3><blockquote>
<p>以下只考虑纯分页管理的情况，不涉及<a href="../X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/#%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80">段页式混合管理</a>，且只考虑X86架构</p>
</blockquote>
<p>分页地址由 低位的12位页内偏移量 和处于 高位的20位的页号组成</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%88%86%E9%A1%B5%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png" alt="分页地址结构"></p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>在分页系统中，各进程的各页可能零散的存放于物理内存空间中，位确保进程能够顺利运行，系统将为每个进程新建页面映射表，简称<code>页表</code></p>
<p>页表由操作系统进行维护，一般程序无权访问与修改，操作系统会定期维护页表</p>
<p>在进程地址空间中的所有页，都依次在页表中由一个页表项，页表中存放着页基址等信息，实现页号到物理地址(页框)之间的映射</p>
<h3 id="分页地址的变址"><a href="#分页地址的变址" class="headerlink" title="分页地址的变址"></a>分页地址的变址</h3><p>为使用户地址空间的逻辑地址转换为内存空间的物理地址，系统中必须设置地址的变换机构</p>
<h4 id="基于地址的变址机构"><a href="#基于地址的变址机构" class="headerlink" title="基于地址的变址机构"></a>基于地址的变址机构</h4><p>变址操作的频率非常高，故变址机构会利用硬件进行实现</p>
<p>例如页表就是利用一组专门的寄存器实现</p>
<p>由于寄存器制造成本高，故大多数页表存储在内存中</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E9%A1%B5%E9%9D%A2%E5%9C%B0%E5%9D%80%E5%8F%98%E5%9D%80.png" alt="页面地址变址"></p>
<p>在索引时，先将页号与页表长度进行比较，若大于页表长度，也就是越界，此时就会产生一个越界中断</p>
<p>若未越界，页号将在页表中得到页基址，将页基址对应的物理块号存放于物理地址寄存器中</p>
<p>再加上逻辑地址中的页内偏移量就得到数据的物理地址</p>
<h4 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h4><p>由于页表被存放于内存中，这就意味着当CPU每次存取数据时，就需要访问内存两次，着就降低了系统的运行效率</p>
<p>为提高变址效率，再变址机构中设立一个具有并行查能力的高速缓冲寄存器，也就是联想寄存器,也就是快表(TLB， translation lookaside buffer)</p>
<p>TLB页表不受操作系统维护，而是交由MMU硬件。MMU会不间断更改TLB页表的内容，例如在TLB miss(TLB 未命中)时，MMU会将未命中的页表项插入TLB页表。</p>
<p>在进行变址时，会优先去TBL中查找，若未命中，才去内存中找页表查找</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.png" alt="具有快表的地址变换机构"></p>
<h4 id="引入快表后的内存有效访问时间"><a href="#引入快表后的内存有效访问时间" class="headerlink" title="引入快表后的内存有效访问时间"></a>引入快表后的内存有效访问时间</h4><p>从进程法术指定逻辑地址的访问请求，经过变址。再到内存中找到对应的物理地址，这一流程所花费的时间被称为<code>有效访问时间(Effective access time, EAT)</code></p>
<p>计算公式如下:<br>$$<br>EAT &#x3D; a * λ +(t + λ)(1 - a) + t  \\<br>&#x3D; 2t + λ - t * a<br>$$<br>λ表示查找快表所需要的时间 | a表示命中率 | t表示访问一次内存所需要的时间</p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><blockquote>
<p>以下只考虑纯分页管理的情况，不涉及<a href="../X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/#%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80">段页式混合管理</a>，且只考虑X86架构</p>
</blockquote>
<p>页表存储虽然可以使一个作业分配在若干个零散的内存空间中，但<code>页表</code>必须连续存放，当一个页表很大时，就需要占用一段很大的连续空间。且链表必须常驻内存，大量表也会造成内存浪费</p>
<p>我们可以将链表进行分组，使一个内存块正好放下一个页表(这里以一个内存块4KB为例)</p>
<p>对离散的页表专门分配一张页表，这张页表就是<code>外页表</code>，也叫<code>页目录</code>&#x2F;<code>顶层页表</code></p>
<p>为方便实现地址转换，在变址机构中，需要增设一个外层页表寄存器，用于存放外城页表的起始位置</p>
<p>外页表中的每个页表向记录着各页表的物理块号，如下</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%A4%BA%E4%BE%8B.png" alt="二级页表示例"></p>
<p>当页面大小为4KB(12位)时，若采用一级页表结构则应具有20位(32-12)的页号，即此时页表项有1M个</p>
<p>当采用两级页表结构时，假设每个页表项占用4B，则每个页可包含2^10个页表项，最多有2^10个分页。</p>
<h4 id="在64位环境下"><a href="#在64位环境下" class="headerlink" title="在64位环境下"></a>在64位环境下</h4><p>对于32位计算机，采用二级页表结构很合适</p>
<p>但对于64位计算机就不一定，例如此时页面大小仍是4KB，即2^12B，每个页占用4B，地址还剩下52位(64-12)，假定物理块大小还是4KB，则还剩下42位(64-12-10)用于外层页号，也就是外层页表凯南有4096G个页表项，将占用4096GB的空间，很显然是不可接受的</p>
<p>此时必须将现在的外层页表在分成两层，也就是三层页表的结构</p>
<h2 id="分段存储方式"><a href="#分段存储方式" class="headerlink" title="分段存储方式"></a>分段存储方式</h2><p>分页存储主要是为了提高内存利用率，而分段存储主要目的则是为了更好地<code>满足用户的逻辑需求</code>，如数据共享、数据保护和动态链接等。因此，当今许多高级语言支持也使用分段存储方式。</p>
<p>分页存储是<code>以进程为单位</code>分配连续的空间，而分段存储将<code>以分段为单位</code>分配连续空间，而<code>一个进程可能由多个分段组成</code></p>
<blockquote>
<p>分段管理的诞生，最早是为了扩充8086处理器的寻址空间<a href="../X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/#%E5%88%86%E6%AE%B5%E7%AE%A1%E7%90%86%E7%9A%84%E8%AF%9E%E7%94%9F">另一篇文字细说</a></p>
</blockquote>
<h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>在分段管理方式中，作业地址空间被分为若干段，并用<code>段号表示不同段</code></p>
<p>每个段都从<code>0开始编址</code>，并采用一段<code>连续的地址空间</code>，且各个段之间<code>彼此独立</code></p>
<p>每个段都具有自己的<code>段基址</code>(段在物理地址中的起始位置)以及<code>长度</code>。</p>
<p>每个段可以<code>定义一组相对完整的逻辑信息</code>，如主程序段、子程序段、数据段等</p>
<p>段的<code>长度不固定</code>，而是由程序自身逻辑关系进行划分，一个进程可划分为多个段</p>
<p>分段地址由地位的段内地址以及高位的段号组成</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%88%86%E6%AE%B5%E5%9C%B0%E5%9D%80.png" alt="分段地址"></p>
<h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p>由于分段存储是将一个作业空间按照程序自身逻辑关系，划分为若干大小不等的段，这些段可以零散的存储在内存用户区或是分页中（段页结合管理方式)</p>
<p>由于段的位置不好确定，OS会维护一张段号和段基址之间对应关系的映射表，也就是段表。</p>
<p>段表中的每个项表示一个段，记录了段号、段基址、段长度等信息</p>
<p>段表可放置于寄存器中，以提高运行效率</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E6%AE%B5%E8%A1%A8.png" alt="段表"></p>
<h3 id="分段地址的变址"><a href="#分段地址的变址" class="headerlink" title="分段地址的变址"></a>分段地址的变址</h3><p>系统中通常会设置段表寄存器，段表寄存器中存储了段表的起始位置以及段表的长度(TL)</p>
<p>当分段地址需要变址时，会先将段号与段表起始位置进行累加，再与段表长度TL进行比较</p>
<p>若大于段表长度，也就越界了，此时将发出中断信号</p>
<p>若小于，则会尝试在段表中查找段表项，得到段基址于段长</p>
<p>此时利用累加器对段基址于段内偏移量进行相加</p>
<p>此时若大于段长，也是越界、发出中断</p>
<p>若小于则可得到段起始位置的物理地址，编制结束</p>
<p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%88%86%E6%AE%B5%E5%8F%98%E5%9D%80.png" alt="分段变址"></p>
<p>可以看出，和分页存储利用页表进行变址一样，访问一次数据，就需要读取两次内存</p>
<p>所以，分段存储也会使用“快表”对段表进行存储，和分页类似，就不多赘述了</p>
<h3 id="一维和二维的问题"><a href="#一维和二维的问题" class="headerlink" title="一维和二维的问题"></a>一维和二维的问题</h3><p>主要是怎么理解分页是一维的，而分段是二维的这一说法。</p>
<p>发现在网上有<a href="https://www.zhihu.com/question/601280472">争论</a>，我这里结合书中的讲解，赞成‘wfs’的说法</p>
<p>分页完全是系统行为，分页大小可预见，程序员只需利用一个页号就可以表示一个地址，这是一维</p>
<p>而分段是用户行为，分段大小由程序逻辑决定，故大小不好遇见，所以程序员既要给出段号，还要给出段内地址，这是二维</p>
<hr>

<blockquote>
<p>参考资料：</p>
<p>《计算机操作系统(慕课版)》 - 中国通信出版集团 人民邮电出版社</p>
<p>《深入理解计算机系统》 - 机械工业出版社</p>
<p><a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8/1583185#5">存储器_百度百科 (baidu.com)</a></p>
<p><a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8/187682">寄存器_百度百科 (baidu.com)</a></p>
<p><a href="https://baike.baidu.com/item/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8?fromModule=lemma_search-box">主存储器_百度百科 (baidu.com)</a></p>
<p><a href="https://baike.baidu.com/item/%E5%A4%96%E5%AD%98%E5%82%A8%E5%99%A8">外存储器_百度百科 (baidu.com)</a></p>
<p><a href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8?fromtitle=RAM&fromid=144481&fromModule=lemma_search-box">随机存取存储器_百度百科 (baidu.com)</a></p>
<p><a href="https://baike.baidu.com/item/SRAM%E5%AD%98%E5%82%A8%E5%99%A8/18883998?fromModule=search-result_lemma-recommend">SRAM存储器_百度百科 (baidu.com)</a></p>
<p><a href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8/12717044">动态随机存取存储器_百度百科 (baidu.com)</a></p>
<p><a href="https://baike.baidu.com/item/%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8/2399075">只读存储器_百度百科 (baidu.com)</a></p>
<p><a href="https://blog.csdn.net/dawuga/article/details/104400171">操作系统-程序的装入和链接_怎么区分链接和装入-CSDN博客</a></p>
<p><a href="https://baike.baidu.com/item/%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F/7379759#:~:text=%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D,%E7%94%A8%E8%BF%99%E7%A7%8D%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%E3%80%82">单一连续分区分配方式_百度百科 (baidu.com)</a></p>
<p><a href="https://blog.csdn.net/weixin_45990326/article/details/119967080">连续分配管理方式（单一连续分配 固定分区分配 动态分区分配）-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_45990326/article/details/119968255">动态分区分配算法（1、首次适应算法 2、最佳适应算法 3、最坏适应算法 4、邻近适应算法）-CSDN博客</a></p>
<p><a href="https://baike.baidu.com/item/HASH/390310">Hash（散列函数）_百度百科 (baidu.com)</a></p>
<p><a href="https://juejin.cn/post/7126514613432090655">分页和分段有什区别？ - 掘金 (juejin.cn)</a></p>
<p>一些有关AI生成的内容</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记分享</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>X86内存机制的小研究</title>
    <url>/article/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<blockquote>
<p>以下内容涉及知识点较深，可能有误，望指出。参考时建议再次查证内容的准确性。</p>
<p>文章很长、这已经是我拆开来写的了，建议收藏慢慢看</p>
<p>本篇偏向于以CPU的视角</p>
</blockquote>
<p>内存(Internal memory、也被习惯称为Memory)，是一个与外存(External memory)相对的概念，本质上是CPU<code>能够直接寻址</code>的<code>存储空间</code>，存储空间<code>由存储器(Memory)提供</code>，可为RAM(Random access memory,随机存储器)、ROM(Read only memory,只读存储器)、cache(高数缓冲存储器)、register(寄存器)，这也就是说除了内存条提供的空间外，主板存储BIOS的存储器、CPU缓存以及寄存器，都可以作为提供内存空间的存储器。而外存(也成为辅助存储器)就是那些CPU无法直接去寻址的空间，主要用于弥补内存的不足，提供外存才存储介质有:硬盘、软盘、U盘、SD卡等</p>
<p>不过在日常通常提到的内存是RAM，大家也叫习惯了，这也就是很多人把RAM和内存两者概念混淆的原因，内存不一定是RAM、RAM不一定是内存(好奇可自行百度 ANS-9010)。</p>
<p>内存作为存储器，自然是用于存放程序以及数据的。只不过内存常为RAM，所以数据在存储器断电后就消失了。故通常只用于作为程序会数据的临时运行环境，一般不作为长期存储的介质。</p>
<span id="more"></span>

<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><p>依赖：一些基础知识，这些知识有助于辅助后续的内容理解</p>
<p>若你已经对此有一定了解，可选择性跳过</p>
<h2 id="80X86处理器？"><a href="#80X86处理器？" class="headerlink" title="80X86处理器？"></a>80X86处理器？</h2><p>1978年，微软发布了第一款16位处理器：Intel 8086，开启了X86时代，并首次使用了分段管理的内存管理方式。</p>
<p>长这样，和现在的CPU外观上还是有差别，图片来自维基百科：</p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/8086%E5%AE%9E%E6%8B%8D.jpg" alt="8086实拍"></p>
<p>作为16位处理器，其数据总线长度为16位，微软使用了加法器将内部两个16位地址相加得到20位地址，从而使得其寻址能力提升到1MB。再利用这20位地址在存储器上寻得指令，指令经过内部指令缓冲器交由指令执行器执行。</p>
<p>80X86处理器这个说法，主要是用于表示8086以及8088(便宜版的8086)那个时代的16位的X86处理器</p>
<h2 id="分段管理的诞生"><a href="#分段管理的诞生" class="headerlink" title="分段管理的诞生"></a>分段管理的诞生</h2><p>这个我细说，因为段基址、段基值、偏移量等与分段密切相关。</p>
<p>因为当时工艺限制，导致8086CPU还是只能使用早期八位处理器的40个引脚，如下：</p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/8086%E5%BC%95%E8%84%9A%E5%AE%9A%E4%B9%89.png" alt="8086引脚定义"></p>
<p>查阅资料，8086CPU使用AD0~AD15通过复用引脚的方式用于传递地址以及数据，8086CPU地址总线为16位，而地址总线(AB)直接影响着寻址空间。其计算公式为：</p>
<p>$$<br>寻址空间 &#x3D; 2 ^ {地址总线条数}<br>$$<br>但地址总线通常只能是数据总线的整数倍，可又受限于当时工艺，无法将地址总线设置为32条，可16条的地址总线只能支持:<br>$$<br>2 ^ {16} &#x3D; 65536Byte &#x3D; 64KB<br>$$</p>
<blockquote>
<p>内存按字节编址，所以这里的65536个地址代表65536字节</p>
</blockquote>
<p>为了实现更大的寻址空间，因特尔通过将地址总线加到20条，也就是支持:<br>$$<br>2 ^ {20} &#x3D; 1048576Byte &#x3D; 1024KB &#x3D; 1MB<br>$$<br>虽然只增加了4条地址总线，但寻址空间就原地扩大了16倍，看着是很香，但这就遇到了新的问题。</p>
<p>还记得地址总线通常只能是数据总线的整数倍吗，20条的地址总线数与16条的数据总线数并不兼容，咋办，这时候分段就诞生了。</p>
<h3 id="后人"><a href="#后人" class="headerlink" title="后人"></a>后人</h3><p>由于汇编语言在各个类型的处理器中不通用，所以人们就都喜欢去学相对更为通用的汇编语言，这就导致了很多教程都是以80X86举例。</p>
<p>通常一些人会把80X86用于表示最初的X86架构处理器，而X86用于表示比较新的处理器，而X64用于代表后期64位的X86-64处理器。</p>
<p><em>既然大家都用，我也用</em></p>
<h2 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h2><p>实模式(Real mode),是为了让80286之后的处理器去兼容早期80X86处理器的一种工作模式,在CPU的复位(reset)、加电(power on)过程中也会使用</p>
<p>该模式下，CPU的寻址方式与80X86类似，直接面向物理地址，使用16位段基值左移4位得到20位段基址，再加16位偏移量得到物理地址，故该模式只能寻址1MB的内存空间，且无分段机制。</p>
<blockquote>
<p>在X64处理器中，取消了实模式！</p>
</blockquote>
<h2 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h2><p>保护模式(Protected Mode、pmode),又称为保护地址模式，是一种在80286后出现的一种新的CPU工作模式，保护模式支持存储器保护、标签页系统、硬件支持的虚拟内存，且突破之前的内存限制，通常最大寻址空间为2^32字节，即4GB(80286只有24位的数据总线，最大只能支持2^24字节，即16MB的寻址空间)。下图表示80286处理器在保护模式下的寻址过程:</p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/286CPU%E5%9C%A8%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%AF%BB%E5%9D%80.png" alt="286CPU在保护模式下的寻址"></p>
<p>为兼容之前的程序，X86处理器都在重置与上电时工作在实模式，想要切换到保护模式，需由操作系统在引导的时候切换到保护模式。</p>
<p>在保护模式下，寄存器保存的数据不再是物理内存地址，而是段选择符(也有人叫选择器、选择子)，由选择符在对应的描述符表中拿到段基址，再与偏移量相加得到物理地址。</p>
<p>在80386后首次出现分页机制，同样也兼容80286的无分页的保护模式，不过386的数据总线为32位，故支持4GB寻址空间。下图表示80386处理器在保护模式下4KiB的分页寻址：</p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/386CPU%E5%9C%A8%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B4KiB%E7%9A%84%E5%88%86%E9%A1%B5%E5%AF%BB%E5%9D%80.jpg" alt="386CPU在保护模式下4KiB的分页寻址"></p>
<p>分页机制的出现，使得386的保护模式与286的保护模式具有更多的优点，例如(来自维基百科)：</p>
<ul>
<li>操作系统可以控制与限制进程对页面的访问权限</li>
<li>为应用程序创造一个连续的、独立的、线性的虚拟内存空间</li>
<li>页面可以移出<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%AD%98">主存</a>，存入更慢速的次级<a href="https://zh.wikipedia.org/w/index.php?title=%E5%A4%96%E5%AD%98%E5%82%A8%E5%99%A8&action=edit&redlink=1">外存</a>如<a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98">硬盘</a>。这使得操作系统可以使用比物理内存更大的存储空间。</li>
</ul>
<h2 id="虚拟8086模式"><a href="#虚拟8086模式" class="headerlink" title="虚拟8086模式"></a>虚拟8086模式</h2><p>虚拟8086模式，有人叫虚拟86模式，最早在80386处理器中出现，该模式主要是为了使得已经进入保护模式下的CPU可以兼容早期8086时代的程序(实模式到保护模式是单向的)</p>
<p>以Windows为例，WIndows系统工作在保护模式下，但其前身DOS工作在实模式下，需要在Windows中运行DOS程序(例如32位的CMD<code>所启动的MS-DOS环境以及里面跑的东西</code>，有人说错了，特指出，CMD本身运行在保护模式)，就需要单独开辟1MB的内存，并创建一个进程，让这个进程利用这1MB空间去模拟一个8086那时候的环境，这就是虚拟8086模式。</p>
<blockquote>
<p>在X64处理器中，取消了虚拟8086模式</p>
</blockquote>
<h2 id="长模式"><a href="#长模式" class="headerlink" title="长模式"></a>长模式</h2><p>当时的人们可能认为4GB足够了，但放到现在4GB跑IDEA都够呛，显然，32位的数据总线放现在很多场景已经满足不了需求</p>
<p>长模式(Long mode)，也叫X64保护模式,这是处于X86-64处理器中的模式，该模式可以使用64为的指令和寄存器，同时也提供IA-32仿真模式以兼容32位的应用程序。</p>
<blockquote>
<p> X64比较特殊，目前不放在X86这篇里面,这里只是提几句。</p>
</blockquote>
<h2 id="了解一点点汇编"><a href="#了解一点点汇编" class="headerlink" title="了解一点点汇编"></a>了解一点点汇编</h2><blockquote>
<p><em>会汇编的自觉跳过</em></p>
</blockquote>
<p>这里快速了解一点点必要的汇编指令知识皮毛，不然可能进行不下去。</p>
<blockquote>
<p>下面来自百度百科与维基百科并修改</p>
</blockquote>
<p>什么是汇编指令，汇编指令是汇编语言中一些操作符和助记符，还包括一些伪指令，任何一款处理器在设计时，就已规定好自己特定的指令系统，这种指令系统的功能也就决定了由该微处理器构成的计算机系统及其基本功能。指令系统中所设计的每条指令都对应着微处理器要完成的一种规定功能操作，即这些指令功能的实现都是由微处理器中的物理器件完成的。要使计算机完成一个完整的任务，就需要执行一组指令，这组指令通常称为程序。计算机能够执行的各种不同指令的集合就称为处理器（CPU）的指令系统。</p>
<p>什么是汇编语言(assembly language)，汇编语言是任何一种用于<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E8%AE%A1%E7%AE%97%E6%9C%BA">电子计算机</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8">微处理器</a>、<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%8E%A7%E5%88%B6%E5%99%A8">微控制器</a>，或其他可编程器件的<a href="https://zh.wikipedia.org/wiki/%E4%BD%8E%E7%BA%A7%E8%AF%AD%E8%A8%80">低级语言</a>。在不同的设备中，汇编语言对应着不同的<a href="https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E8%AF%AD%E8%A8%80">机器语言</a><a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B">指令集</a>。一种汇编语言专用于某种<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84">计算机系统结构</a>，而不像许多<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80">高级语言</a>，可以在不同系统平台之间移植。汇编语言虽然是低级语言，但相对二进制的机器语言要高级。</p>
<h3 id="操作码"><a href="#操作码" class="headerlink" title="操作码"></a>操作码</h3><p>操作码（Operation Code）用来说明指令操作的性质与功能，常用OP表示。</p>
<p>通常内存寻址用到：</p>
<p>MOV:即传送字或字节，有点类似于赋值。</p>
<p>JMP:无条件转移指令。</p>
<p>ADD： 加法。</p>
<p>ADC： 带进位加法。</p>
<p>SUB： 减法。</p>
<p>SBB： 带借位减法。</p>
<p>MUL： 无符号乘法</p>
<p>DIV： 无符号除法</p>
<p>其他的可以参考<a href="https://baike.baidu.com/item/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/9979890">百度百科</a></p>
<h3 id="操作数和操作数地址"><a href="#操作数和操作数地址" class="headerlink" title="操作数和操作数地址"></a>操作数和操作数地址</h3><p>操作数(Operand)：运算符作用于的那个实体,这里的数，可以理解成数据，非数量。</p>
<p>操作数的地址，就是操作数存放的地址，通常有存储单元、IO接口、CPU内部寄存器，本章就是内存地址。</p>
<p>有时候你看到操作数地址是两个或三个字母，不分大小写，他们一般表示寄存器:</p>
<p>数据寄存器：AX、BX、CX、DX</p>
<p>段寄存器：CS、DS、ES、SS</p>
<p>基址寄存器：BP、SP</p>
<p>变址寄存器：SI、DI</p>
<p>寄存器：REG</p>
<p>寄存器中Rn的值：REG[Rn]</p>
<h3 id="操作结果存放的地址"><a href="#操作结果存放的地址" class="headerlink" title="操作结果存放的地址"></a>操作结果存放的地址</h3><p>这个类似前者，就是将操作的数据改为操作数据后的结果</p>
<h3 id="下一条指令的地址"><a href="#下一条指令的地址" class="headerlink" title="下一条指令的地址"></a>下一条指令的地址</h3><p>程序顺序执行时，下一条指令的地址由CPU中的程序计数器给出。如果遇到程序转移或者调用子程序时，下一条地址由指令给出。</p>
<h3 id="有效地址"><a href="#有效地址" class="headerlink" title="有效地址"></a>有效地址</h3><p>有效地址，通常使用EA表示，我的理解是这样的：能被用来找到东西的地址</p>
<p>例如8086中，段基值位移后与偏移量结合得到的物理地址。</p>
<h3 id="立即数"><a href="#立即数" class="headerlink" title="立即数"></a>立即数</h3><p>立即数指的是指令中直接给出的一个数值常量，直接就拿到，不要再去别的地方读取，例如用于表示立即寻址方式所找到那个地址。</p>
<h1 id="内存管理方式"><a href="#内存管理方式" class="headerlink" title="内存管理方式"></a>内存管理方式</h1><p>在很久很久以前，程序员通常使用汇编语言开发，程序员在开发是直接使用物理内存地址，这就会导致可能两个或是更多的程序用时读写一个地方，程序A的数据刚刚写入，立马又被程序B修改了，程序要再次读取数据的时候就发现不对，啪！立马就不干了。</p>
<p>这就是除了分段机制诞生之初是为了解决寻址空间不够的问题外，内存管理方式的另一个作用。</p>
<h2 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h2><p>内存分段就是将内存空间按照特定的需求，分为若干个段，每个段由段基址与段界限(决定段长度)确定，但每个段的长度并不固定(英特尔8086CPU中，内存段大小不超过64KB，在较新的X86处理器保护模式中，通过段描述符中的”Granularity”位，可将段的长度扩大到不超过4GB)，每个段在<code>其地址范围内</code>是<code>连续</code>的,不同段之间可<code>不相邻</code>，各段<code>大小不固定</code>。</p>
<h3 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h3><ol>
<li>在程序编译时,编译器和链接器会将程序的逻辑地址空间划分为多个<code>段</code>,比如代码段、数据段、堆栈段等。</li>
<li>在程序加载时,操作系统会为每个段分配内存空间,并设置好其<code>段基址</code>和<code>段界限</code>。</li>
<li>CPU中的<code>段寄存器</code>保存了当前代码正在访问的段的信息。</li>
<li>当CPU要访问内存时,会生成一个<code>逻辑地址</code>,包含<code>段选择符</code>和<code>偏移量</code>两部分。</li>
<li>X86保护模式下用段选择器在描述符表中查找到对应的<code>段描述符</code>,获取到段基址。</li>
<li>将偏移地址加上段基址或转换后的段基值,形成线性地址或物理地址。</li>
<li>检查地址是否超出了段界限,如果超出则触发段错误异常。</li>
<li>如果地址合法,使用线性地址访问内存。</li>
<li>如果需要切换到其他段,改变段寄存器的值,执行新的地址转换过程。</li>
<li>程序结束时,操作系统会回收程序占用的各个内存段。</li>
</ol>
<h3 id="空间碎片"><a href="#空间碎片" class="headerlink" title="空间碎片"></a>空间碎片</h3><p>分段不是百利无害的，分段允许段间不相邻且段大小不一致，这势必会产生外部碎片。</p>
<p>就像这样，分段机制将各种方法、数据等等都分好了段，就算一开始各个段都相邻、没有空隙，但随着程序的运行，有段被释放，有新段被申请加入，要是一个大段被释放，而在原有空间放入一个较小的段，就会出现一个空隙，这个空隙要是放不下其他段，就是外部空间碎片。</p>
<p>由于分段机制是事先根据内容进行分段，是一种动态分配，所以一般不会产生内部碎片，主要还是外部碎片。</p>
<p>通常用于缓解外部碎片有以下方法:</p>
<ul>
<li>移动段的位置，使其紧凑。但这方法速度慢，移动过程中还影响程序的运行。</li>
<li>将要放入的段切小块，放到各个缝隙中。但这不是你想切就能切。</li>
</ul>
<h2 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h2><p>在X86实模式以及80X86上，是没有实现内存分页的，分页机制是应该在80386处理器上首次出现，在80386之后的处理器中，处理器内控制标识符CR0的<code>PG控制位为1时</code>，将采用分页机制。</p>
<p>内存分页和分段类似，也是将内存空间分为多个段，然后使用一个虚拟地址去描述(在这就叫线性地址)，X86的分页机制，允许将任何的物理单元分配到线性地址。</p>
<p>分页<code>不会产生外部碎片</code>,这是因为其实将空间划分为多个<code>连续</code>的区域，这个区域称为页(Page)，这是逻辑层面的概念，在物理层面上<code>对应页框</code>，页不会很大，通常为4KB，过大的页会加重内部碎片从而浪费空间，过小的页会增加页表项，影响页表的查询效率以及TLB页表的缓存命中率，4KB是人们总结的经验得来的。每个页的<code>大小是相同</code>的，这是因为页是静态分配，当然，这就无法避免的造成内部碎片的产生。</p>
<p>分页机制使用<code>页号</code>来标识各个页,使用<code>页表</code>(Page Table)映射其与<code>页框</code>的关系。为了节约内存，页表通常是多级结构的，但多级结构就会导致在查询时需要分多步进行，影响效率。此时就可以使用TLB(Translation lookaside buffer,旁路转换缓冲)页表(也被称为快表)来缓解.<code>TLB页表</code>是一张小容量但查找速度极快的缓存表，被放置在CPU的缓存中，存放了部分页表中的内容，在做地址转换时，会先去TBL页表中查找，若未命中，才去内存中找页表查找。TLB页表会不间断的在维护，例如发生TLB miss(缓存未命中)、TLB页表满等情况时，会自动补充或替换TLB页表的项。</p>
<h3 id="具体过程-1"><a href="#具体过程-1" class="headerlink" title="具体过程"></a>具体过程</h3><ol>
<li>操作系统按照固定大小将物理内存划分为多个<code>页框</code>。</li>
<li>根据进程虚拟地址空间,<code>建立</code>多级<code>页表</code>,存储页面映射信息。</li>
<li>当CPU要访问内存时,将虚拟地址分为<code>页目录索引</code>、<code>页表索引</code>和<code>页内偏移量</code>。</li>
<li>通过索引动作,查找对应的物理<code>页框号</code>。</li>
<li>将物理<code>页框号</code>和页内<code>偏移量 组合</code>,得到<code>物理地址</code>。</li>
<li>根据物理地址访问内存相应位置,读取或写入数据。</li>
<li>如果页表项无效,则触发缺页异常,操作系统将暂停进程,并从磁盘加载需要的页面。</li>
<li>访问结束后,操作系统可以根据策略回收物理页面,并在页表中标记无效。</li>
<li>页表也会存储访问权限位,实现页面级内存保护。</li>
</ol>
<h1 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h1><p>内存地址通常以16进制数来表示，与字面意思一样，表示内存中的一个位置，用于访问内存中的数据。</p>
<p>在X86处理器中，以下是X86保护模式下的流程图：</p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80_%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80_%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80.png" alt="逻辑地址_线性地址_物理地址"></p>
<h2 id="逻辑地址-logical-address"><a href="#逻辑地址-logical-address" class="headerlink" title="逻辑地址(logical address)"></a>逻辑地址(logical address)</h2><p>现在逻辑地址更多是为了兼容更早之前的设备所遗留的。前面提到在Intel8086&#x2F;8088CPU中，为了使得CPU能支持的内存从64KB提升到1MB，从而诞生了内存分段以及逻辑地址。</p>
<p>逻辑地址是由编译器生成，故对程序员可见，在编译的过程中，编译器会生成代码段和数据段，每句代码和每条数据都有其相应的逻辑地址。</p>
<p>由于早期80X86CPU与后续CPU设计差异较大，导致分段机制的逻辑差异较大,如下:</p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E6%B5%81%E7%A8%8B.jpg" alt="X86保护模式下分段机制流程"></p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/80X86%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6%E6%B5%81%E7%A8%8B.jpg" alt="80X86分段机制流程"></p>
<h3 id="逻辑地址的结构"><a href="#逻辑地址的结构" class="headerlink" title="-逻辑地址的结构"></a>-逻辑地址的结构</h3><p>X86中逻辑地址是通过16位的段选择符(Segment Selector，也有人叫作选择子)和32位的用来指定段内相对地址的段偏移量(offset)组成，一般用”:”分割</p>
<p>下图是中选择符是现在X86微处理器的概念，在<code>80X86中没有段选择符</code>，而是16位的<code>段基值</code>，且段<code>偏移量也只有16位</code></p>
<p>X86概念图如下： <em><a href="https://blog.csdn.net/wdqqbyt4321/article/details/96978639">图片来源</a></em></p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png" alt="逻辑地址结构"></p>
<h3 id="段寄存器"><a href="#段寄存器" class="headerlink" title="-段寄存器"></a>-段寄存器</h3><p>为了方便选择段选择符，80X86处理器提供了6个段寄存器用来存放段选择符</p>
<p>分别是:CS DS SS ES FS GS,在8086处理器中，他们用于存放段段地址(实模式)&#x2F;选择符(保护模式)的可见部分都是16位长度，以下含义针对的是80X86，已知X64好像有改动。</p>
<ul>
<li>CS为代码段寄存器；</li>
<li>SS为栈段寄存器；</li>
<li>DS为数据段寄存器；</li>
<li>其他三个是附加段，作一般用途</li>
</ul>
<h3 id="段选择符-保护模式特有"><a href="#段选择符-保护模式特有" class="headerlink" title="-段选择符(保护模式特有)"></a>-段选择符(保护模式特有)</h3><blockquote>
<p>这是X86处理器在保护模式下特有的机制</p>
</blockquote>
<p>段<code>选择符</code>长度为16位，其中前13位是索引号（index），用于表示在描述符表中的位置。</p>
<p>TI(Table Indicator，表指示符)，TI&#x3D;0表示段<code>描述符</code>在GDT(全局描述表)中，而T&#x3D;1表示在LDT(局部描述表)中</p>
<p>还有2位的RPL(Requestor Privilege Level，请求优先级&#x2F;特权级)由00-11，数字越大特权级越低，低特权级是无法访问高特权级的</p>
<p>结构如下： <em><a href="https://blog.csdn.net/wdqqbyt4321/article/details/96978639">图片来源</a></em></p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/%E6%AE%B5%E6%A0%87%E8%AF%86%E7%AC%A6%E7%BB%93%E6%9E%84.png" alt="段标识符结构"></p>
<h3 id="GDT和LDT-保护模式特有"><a href="#GDT和LDT-保护模式特有" class="headerlink" title="-GDT和LDT(保护模式特有)"></a>-GDT和LDT(保护模式特有)</h3><blockquote>
<p>这是X86处理器在保护模式下特有的机制</p>
</blockquote>
<p>这两个都是用于存放段描述符的日期，只不过他们作用于不同</p>
<p>你可以将它们俩看成是公共场合和私人场所的关系</p>
<p>GDT(Global Descriptor Table，全局描述符表)是公开的，所有程序都共享一个GDT，</p>
<p>LDT(Locol Descriptor Table，局部描述符表)是私有的，里面都是某个任务特有的描述符</p>
<p>若有一个段a，还有一个任务B。要是GDT和任务B中的LDT都没有段a的描述符，则任务B无法访问段a</p>
<h3 id="段描述符-保护模式特有"><a href="#段描述符-保护模式特有" class="headerlink" title="-段描述符(保护模式特有)"></a>-段描述符(保护模式特有)</h3><blockquote>
<p>这是X86处理器在保护模式下特有的机制</p>
</blockquote>
<p>段描述符主要存放的是一个段的属性，其中就包含了段基址以及段大小限制、描述符优先级等控制位。</p>
<p>如下: </p>
<blockquote><p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6.png" alt="段描述符"></p>
<p>G：粒度标志。Segment Limit 字段的大小比例。G&#x3D;0，Segment Limit 以字节为单位；G&#x3D;1，Segment Limit 以4KB为单位，计算：实际段界限 &#x3D; 描述符中的段界限 * 0x1000 + 0xFFF。该标志不影响Base字段的粒度，Base字段永远以字节为单位。</p>
<p>Segment Limit：表示该段的大小&#x2F;界限。处理器用G标志位来解释该字段。当G&#x3D;0，段的大小是1B~MB，以1字节为单位增长；当G&#x3D;1，段的大小是4KB~4GB，以4KB为单位增长。对于段的扩展方向，如果是向上扩展段，逻辑地址的偏移量是0~Segment Limit；如果是向下扩展段，逻辑地址的偏移量是Segment Limit（最小值）~FFFFFFFFh或FFFFh。实模式下，处理器将Limit预置成0xFFFF，以防出错。</p>
<p>Base：段在线性地址空间中的开始位置。段基址应当是16字节边界对齐的，提高程序性能。</p>
<p>DPL：该描述符的特权级，0 ~ 3。用于控制对该段的访问。</p>
<p>P：表示该段是否在内存。P&#x3D;1，该段在内存中；P&#x3D;0，该段不在内存中，处理器产生一个#NP异常，操作系统可以自由地使用Available域。</p>
<p>D：处理器默认操作尺寸，表示该段按16位还是32位尺寸操作。对于代码段，D&#x2F;B位是D位，表示默认的操作尺寸。当D&#x3D;0，表示16位默认操作尺寸；当D&#x3D;1，表示32位默认操作尺寸。</p>
<p>B：对于数据段，D&#x2F;B位是B位。当栈段的B位&#x3D;0，使用sp；B位&#x3D;1，使用esp。</p>
<p># L：用于IA-32e模式下。表示一个代码段是否包含原生64位代码。L&#x3D;1，表示该代码段中的指令运行在IA-32e下，D位必须为0；L&#x3D;0，表示该代码段中的指令运行在兼容模式下，该位作为保留位。</p>
<p>AVL：是否可以被系统软件使用。</p>
<p>S：确定段描述符是系统&#x2F;门段描述符（S&#x3D;0）还是代码&#x2F;数据段描述符（S&#x3D;1）。</p>
<p>Type：表示段的类型（代码段、数据段、门、系统段）和它们的权限和信息。具体是什么段先由S位决定再根据Type域的二进制决定。</p>
<footer><strong>图片和描述来源</strong><cite><a href="https://www.cnblogs.com/SuperGreen/p/15490472.html">博客园《内存管理--段描述符》</a></cite></footer></blockquote>

<h3 id="段基值和段基址"><a href="#段基值和段基址" class="headerlink" title="-段基值和段基址"></a>-段基值和段基址</h3><p>这两个的诞生还是与内存的分段机制有关，我们了解过，前面写到80X86理论上只能支持64KB的内存，但因特尔不服，就发明出了内存分段这一个概念。</p>
<p>虽然经过因特尔的魔改，地址总线增加到了20条，但80X86处理器寄存器的可见部分是16位的，这就相当于CPU可以寻址1MB的空间，但是你的地址只能写16位。也就还是64KB，那怎么办：</p>
<p>80X86采用了分段寻址的方式，细节<a href="#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6">往上翻</a>，我就当你了解了哈。</p>
<p>段基址(Segment Base Address): 也被叫做段基地址，表示段的起始位置，在80X86中有20位。在X86保护模式下有32位，在X86长模式下有64位。</p>
<p>段基值(Segment Base Value)：段基值的高16位，用于存放在寄存器中。也是用于表示段的起始位置，<code>该概念已在X86上被弃用</code>。</p>
<p>正由于这两个表示的意思相同，加上<code>新版的X86不用再做该转换</code>，导致很多资料将其混淆，甚至出现段基址&#x3D;段基值的情况。</p>
<p>在80X86中他们之间的关系可以看做：<br>$$<br>\begin{align}<br>段基值 &amp;&#x3D; 段基址 &lt;&lt; 4 \\<br>&amp;&#x3D; 段基址 \times 10H<br>\end{align}<br>$$<br>而在因特尔80286CPU之后引入引入了一种新的操作模式(保护模式)，该模式的段基址由更前面提到的段描述符中得到，不过80286还是要做段基址到段基值的转换(和8086不一样，具体百度，非主要内容)。</p>
<p>而我们可以通过段基址和偏移量相加得到物理地址(实模式)&#x2F;线性地址(保护模式)</p>
<p>如下:<br>$$<br>\begin{align}<br>物理地址 or 线性地址 &amp;&#x3D; 段基址 + 偏移量<br>\end{align}<br>$$</p>
<h3 id="偏移量"><a href="#偏移量" class="headerlink" title="-偏移量"></a>-偏移量</h3><p>偏移量(Offset)，又叫偏移地址(Offset Address)是用于表示某一地址相对于段基值的一个偏移量</p>
<h3 id="Linux中的逻辑地址"><a href="#Linux中的逻辑地址" class="headerlink" title="-Linux中的逻辑地址"></a>-Linux中的逻辑地址</h3><p>Linux系统使用了些特殊的方法”关闭”了分段，即想办法使逻辑地址等于线性地址。具体来说貌似是将所有类型的段的段基址都设成 0（包括内核数据段、内核代码段、用户数据段、用户代码段等），迫使所有的段重合，这样就自然不存在分段了。</p>
<p>不过在不兼容的时候，Linux还是会正常使用分段，但这也只是极少数才会出现的情况。</p>
<h2 id="线性地址-linear-address"><a href="#线性地址-linear-address" class="headerlink" title="线性地址(linear address)"></a>线性地址(linear address)</h2><blockquote>
<p>以下是80386之后的保护模式下的线性地址</p>
</blockquote>
<p>线性地址由CPU生成的，在X86中，线性地址由逻辑地址分段后得到，是逻辑地址到物理地址的一个中间地址。线性地址也只是抽象的概念，同样不表示数据存放在存储器上的真实位置。</p>
<p>在X86分页机制中，处于保护模式下，线性地址长度为32位，最大寻址空间为4GB，而在64为长模式中线性地址长度为64位，最大寻址空间为16EB，这也就是为什么当年XP时代，很多计算机只能支持4GB的原因。本章只考虑32位的保护模式。</p>
<p>线性地址32位由高到低分别分为三个部分，并按照如下流程映射至物理地址，如下图:</p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/X86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6.jpg" alt="X86保护模式下的分页机制"></p>
<h3 id="页标志位"><a href="#页标志位" class="headerlink" title="-页标志位"></a>-页标志位</h3><p>页标志位(PG)是用于表示内存是否采用分页机制，页标志位存放在CR0(Control Register 0,CPU的一个和工作模式相关的控制寄存器)的31Bit的位置上，为1则表示采用了分页机制。</p>
<h3 id="页目录基地址寄存器"><a href="#页目录基地址寄存器" class="headerlink" title="-页目录基地址寄存器"></a>-页目录基地址寄存器</h3><p>页目录基地址寄存器(PDBR，Page Directory Base Register),而它存放了20Bit长度的<code>页目录的基地址</code>和一些控制位。</p>
<p>PDBR存放在CR3(Control Register 3,CPU的一个和页目录相关的寄存器)中</p>
<h3 id="页目录"><a href="#页目录" class="headerlink" title="-页目录"></a>-页目录</h3><p>每个进程都有它自己的一个页目录(PD,Page Directory)，他位于一个由操作系统的属于内核的内存中，由操作系统进行维护，普通程序无权访问与操作页目录，也目录可容纳1024个页目录项。在操作系统切换进程时会切换页目录。</p>
<p>页目录不是第一个索引的对象，只有在TLB页无法索引到页框号是才会通过页目录去找页表拿到页框号。</p>
<h3 id="页目录项"><a href="#页目录项" class="headerlink" title="-页目录项"></a>-页目录项</h3><p>页目录项(PDE，Page Directory Entry)，用于表示页目录的一项，内含相对应<code>页表的基地址</code>以及其他控制信息，在页大小为4KB时如下：</p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/%E9%A1%B5%E7%9B%AE%E5%BD%95%E9%A1%B9%E7%BB%93%E6%9E%84.png" alt="页目录项结构"></p>
<ul>
<li>Page-Table Base Address:页表基址(页表的起始位置)</li>
<li>Avail：待研究</li>
<li>G：全局位，为1时，表示该页是全局的，全局项会被缓存</li>
<li>PS：为0时，页的大小是4KB；为1时，若使用的是普通的32为寻址页的大小是4MB</li>
<li>A：访问位，用于记录页有没有被访问过</li>
<li>PCD：Page Cache Disable，用于表示页是否不可被缓存，为0是可被缓存，为1为不可以被缓存，</li>
<li>PWT：Page Write Through，标识页也在被缓存时是否将数据也写入内存,为0时不写入，为1时写入</li>
<li>U&#x2F;S：用户权限标识，为0时，普通用户无权限，为1时，普通用户拥有读与执行权限，普通用户的写权限由R&#x2F;W标识控制，超级用户(拥有0、1、2特权级)始终拥有读写执行三个权限</li>
<li>R&#x2F;W：读写权限表示，当U&#x2F;S表示为1时，R&#x2F;W为0时普通用户无写权限、为1时有写权限，超级用户(拥有0、1、2特权级)始终拥有读写执行三个权限</li>
<li>P：表示页表是否在内存中</li>
</ul>
<h3 id="页目录索引"><a href="#页目录索引" class="headerlink" title="-页目录索引"></a>-页目录索引</h3><p>页目录索引(PDI,Page Directory Index)位于线性地址的高10位，即22-31Bit,表示页目录索引，即页目录中的某一<code>页目录项的索引</code>。</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="-页表"></a>-页表</h3><p>通过页目录项中页表的基地址。可以找到页表。</p>
<p>页表(Page Table)存放了各<code>页框的信息</code>，每个线程拥有自己的页表，页表主要存放于属于内核的内存中，由操作系统进行维护，一般程序无权访问与修改，操作系统会定期维护页表。其中部分内容会缓存到TLB(Translation lookaside buffer,旁路转换缓冲)中。</p>
<p>TLB页表又叫快表，存放于CPU中MMU(Memory Management Unit,内存管理单元)的高速缓存中。TLB页表不受操作系统维护，而是交由MMU硬件。MMU会不间断更改TLB页表的内容，例如在TLB miss(TLB 未命中)时，MMU会将未命中的页表项插入TLB页表。</p>
<h3 id="页表项"><a href="#页表项" class="headerlink" title="-页表项"></a>-页表项</h3><p>页表项(PTE，Page Table Entry)存放了有关页框的相关信息，由于分页是从32位时代才出现的，所以通常来说有两种情况</p>
<p>在32位操作系统中，页表项长度通常为32位，在64位操作系统中，页表项通常扩展为为64位。</p>
<p>通常啊，不一定就是，决定程度的因素不只是操作系统的位数。</p>
<p>在页大小为4KB时如下：</p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/%E9%A1%B5%E8%A1%A8%E9%A1%B9%E7%BB%93%E6%9E%84.png" alt="页表项结构"></p>
<ul>
<li><p>Page Base Address:这里更准确的说应该存储的是页框号，通过页框号算出页基址，由于静态分配，页框大小是一致的，所以，可以通过如下方法算出页基址:<br>$$<br>页基址 &#x3D; 页框号 * 页框大小<br>$$<br>而页基址是表示页在物理层面的起始位置(一个物理地址)，通过与页偏移量，得出所求的物理地址。</p>
</li>
<li><p>Avail：待研究</p>
</li>
<li><p>G：全局位，为1时，表示该页是全局的，全局项会被缓存</p>
</li>
<li><p>PS：为0时，页的大小是4KB；为1时，若使用的是普通的32为寻址页的大小是4MB，要是戚永亮扩展寻址则为2MB.</p>
</li>
<li><p>A：访问位，用于记录页有没有被访问过</p>
</li>
<li><p>PCD：Page Cache Disable，用于表示页是否不可被缓存，为0是可被缓存，为1为不可以被缓存，</p>
</li>
<li><p>PWT：Page Write Through，标识页也在被缓存时是否将数据也写入内存,为0时不写入，为1时写入</p>
</li>
<li><p>U&#x2F;S：用户权限标识，为0时，普通用户无权限，为1时，普通用户拥有读与执行权限，普通用户的写权限由R&#x2F;W标识控制，超级用户(拥有0、1、2特权级)始终拥有读写执行三个权限</p>
</li>
<li><p>R&#x2F;W：读写权限表示，当U&#x2F;S表示为1时，R&#x2F;W为0时普通用户无写权限、为1时有写权限，超级用户(拥有0、1、2特权级)始终拥有读写执行三个权限</p>
</li>
<li><p>P：表示页是否在内存中</p>
</li>
</ul>
<h3 id="页表索引"><a href="#页表索引" class="headerlink" title="-页表索引"></a>-页表索引</h3><p>页目录索引(PTI,Page Table Index)位于线性地址的12-21Bit，长10位,表示页表索引，即表示页表中的某一<code>页表项的索引</code>。</p>
<h3 id="页框号"><a href="#页框号" class="headerlink" title="-页框号"></a>-页框号</h3><p>页框表示着页的对应的物理空间，通常各页框长度一致，紧凑排列，就像一个个框</p>
<p>页框之间通常<code>页框号</code>表示是哪个页框，通常从0开始累加,有人称为页号，也是这个意思。</p>
<p>一般我们用这个公式计算出页框号:<br>$$<br>页框号 &#x3D; 逻辑地址 | 单个页框长度<br>$$</p>
<blockquote>
<p>这里的|是数学上的整除</p>
</blockquote>
<h3 id="页基址"><a href="#页基址" class="headerlink" title="-页基址"></a>-页基址</h3><p>页基址(Page Base Address),也就是页框的起始位置<br>$$<br>页基址 &#x3D; 页框号 * 页框大小<br>$$</p>
<h3 id="页内偏移量"><a href="#页内偏移量" class="headerlink" title="-页内偏移量"></a>-页内偏移量</h3><p>页框是一个容器，页内偏移量就是逻辑地址(在这就是线性地址)所对应的物理地址在其页框起始地址的偏移量。</p>
<p>故，一般可通过这个公式计算出页内偏移量<br>$$<br>页内偏移量 &#x3D; 逻辑地址\ mod\ 单页框长度<br>$$</p>
<blockquote>
<p>mod 就是取模，即除后取余数</p>
</blockquote>
<p>则线性地址对应的物理地址:<br>$$<br>物理地址 &#x3D; 页基址 + 页内偏移量<br>$$</p>
<h2 id="物理地址-physical-address"><a href="#物理地址-physical-address" class="headerlink" title="物理地址(physical address)"></a>物理地址(physical address)</h2><p>物理地址(physical address)，也叫实地址(real address)、二进制地址(binary address),指的是数据总线能够寻址到的特定的存储单元上的空间的地址。</p>
<p>通常是由MMU(memory management unit,内存管理单元)将虚拟地址转换为物理地址。</p>
<p>在X86实模式下，物理地址由段基址向左偏移4位(也就是常说的X16D或X10H)在加上段内偏移量得到</p>
<p>而在X86保护模式下，物理地址由页基址+页内偏移量得到</p>
<p>在早期的计算机中，程序员通常使用汇编语言开发，程序员在开发是直接使用物理内存地址，这就会导致可能两个或更多的程序用时读写一个地方，导致出现问题。直接使用物理内存的情况，也发生在单片机的程序开发中。</p>
<h3 id="物理地址空间"><a href="#物理地址空间" class="headerlink" title="物理地址空间"></a>物理地址空间</h3><p>程序最终也不会随意使用任意的物理地址，同样，也不是所有的物理地址都能提供给程序使用。</p>
<p>内存空间被分为MMIO(Memory-Mapped I&#x2F;O,内存映射输入和输出)空间和DRAM(动态随机存取内存)空间</p>
<p>其中MMIO空间用于映射IO设备的控制寄存器，这是PCI的一种规范。当然映射方式不止这一种，你打开Windows设备管理器，点上方查看，切换成按类型列出资源就知道了</p>
<p>而DRAM空间才是应用程序所能使用的空间。</p>
<p>通常Windows操作系统的的任务管理器-&gt;性能-&gt;内存中,有个为硬件保留的内存，这就是MMIO区域。</p>
<p>典型的64位系统下物理内存空间示意图如下: <a href="https://zhuanlan.zhihu.com/p/66288943">图片来源</a></p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/%E5%85%B8%E5%9E%8B%E5%86%85%E5%AD%98%E7%89%A9%E7%90%86%E7%A9%BA%E9%97%B4.jpg" alt="典型内存物理空间"></p>
<p>由于历史遗留，早期的32位系统因为其最大寻址空间只能有4GB，而现在的内存空间设计为了兼容性，将空间分为高低两块。</p>
<p>又由于更早的历史遗留，为了兼容性，将最低的那1MB内存(熟悉吧:80X86)保留,而保留他是为了给运行在8086这类早期处理器的操作系统(例如DOS)和已经被淘汰的老BIOS使用的。</p>
<p>在后期安装了超4GB内存的64为操作系统中，为了不影响32位应用程序的使用(32位应用程序只能使用0-4GB这段内存空间)，将4GB以上的区域定义为高端区，4GB以下的定义为低端区，高低端本质上差别不太大。</p>
<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><p>在百度百科中，寄存器的定义是<code>有限存贮容量的高速存贮部件</code>，也在CPU中</p>
<p>这个说法很直观，但又容易与CPU中高速缓存(Cache)的概念混淆</p>
<p>寄存器是CPU内部用于临时存放与传送<code>计算数据</code>的一个很小的存储区域，可<code>参与逻辑运算</code>并<code>暂存运算结果</code>，属于CPU在运行时的一些临时空间；而各级缓存是用于加速内存读写使用的一个要比寄存器大但没那么快的区域。</p>
<p>在计算机领域，寄存器是CPU内部的元件，包括<a href="https://baike.baidu.com/item/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/283978?fromModule=lemma_inlink">通用寄存器</a>、专用寄存器和<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8/9335215?fromModule=lemma_inlink">控制寄存器</a>。寄存器拥有非常高的读写速度,要比Cache快,甚至是操作系统系统访问数据的最快途径。</p>
<p>寄存器本质就是用于存储二进制数据或代码的存储器，由能够置0&#x2F;1功能的电路组成，多由<a href="https://baike.baidu.com/item/%E8%A7%A6%E5%8F%91%E5%99%A8/16782?fr=ge_ala">触发器(Flip-Flop、FF)</a>也可是<a href="https://baike.baidu.com/item/%E9%94%81%E5%AD%98%E5%99%A8/10801965?fr=ge_ala">锁存器(latch)</a>组成,这两个具体是什么可以点击链接跳转百度百科，这里贴出百度百科的两张图，有个基本了解。</p>
<p>由4位触发器构成的数码寄存器(图：百度百科):</p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/%E7%94%B14%E4%BD%8D%E8%A7%A6%E5%8F%91%E5%99%A8%E6%9E%84%E6%88%90%E7%9A%84%E6%95%B0%E7%A0%81%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="由4位触发器构成的数码寄存器"></p>
<p>由4位触发器构成的右位移寄存器(图：百度百科):</p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/%E7%94%B14%E4%BD%8D%E8%A7%A6%E5%8F%91%E5%99%A8%E6%9E%84%E6%88%90%E7%9A%84%E4%BD%8D%E7%A7%BB%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="由4位触发器构成的位移寄存器"></p>
<h2 id="数码寄存器和位移寄存器"><a href="#数码寄存器和位移寄存器" class="headerlink" title="数码寄存器和位移寄存器"></a>数码寄存器和位移寄存器</h2><p>一个寄存器具备以下4个功能：</p>
<ul>
<li>清除数码：相当于复位，将寄存器已存的数码清除</li>
<li>接受数码：将外部输入的数码存储与寄存器中</li>
<li>存储数码：保证数码在寄存器中不会莫名其妙发生变化</li>
<li>输出数码：通过电路输出存储在寄存器中的数码</li>
</ul>
<p>由于都是在对数码进行操作，故将寄存器成为<code>数码寄存器</code></p>
<p>而有些机器不仅仅能够实现上方4个功能，还能支持对已存数码做左右位移操作，故称为<code>位移寄存器</code></p>
<hr>

<p>在80X86和X86中，寄存器存在些许差别，这要分开研究</p>
<h2 id="8086处理器"><a href="#8086处理器" class="headerlink" title="8086处理器"></a>8086处理器</h2><p>8086的寄存器都是16位的，如下图:</p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/8086%E5%AF%84%E5%AD%98%E5%99%A8.jpg" alt="8086寄存器"></p>
<p>其中AX、BX、CX、DX这四个通用寄存器可直接使用，但为了兼容8086之前更早的处理器，这些寄存器也可拆分别成两个8位的寄存器使用，若拆分，则分别表示高低位。</p>
<p>在DOS debug命令中，可以使用R查看各个寄存器的内容，这是我在虚拟机运行的MS-DOS7.1的输出，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-R</span><br><span class="line"></span><br><span class="line">AX=0000	BX=0000	CX=0000	DX=0000	SP=FFEE	BP=0000	SI=0000	DI=0000	</span><br><span class="line">DS=2B4A	ES=2B4A	SS=2B4A	CS=2B4A	IP=0000	NV NP EI PL NZ NA PO NC</span><br></pre></td></tr></table></figure>

<h3 id="通用数据寄存器"><a href="#通用数据寄存器" class="headerlink" title="通用数据寄存器"></a>通用数据寄存器</h3><p>通用数据寄存器，又称为通用寄存器(General-Purpose Register)，该类寄存器使用频繁，用途广泛。</p>
<p>在8086中有以下4个通用寄存器:</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>名称</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>AX</td>
<td>累加器: accumulator</td>
<td>用于计算结果的输入&#x2F;输出操作，使用频率高</td>
</tr>
<tr>
<td>BX</td>
<td>基址寄存器: Base Register</td>
<td>存放基数位移定址的指正</td>
</tr>
<tr>
<td>CX</td>
<td>计数寄存器:Count Register</td>
<td>计数，用于控制循环和位移等操作的次数</td>
</tr>
<tr>
<td>DX</td>
<td>数据寄存器(Data Register)</td>
<td>可在运算时存储操作数，也可在IO时存储端口地址</td>
</tr>
</tbody></table>
<blockquote>
<p>AX、BX、CX、DX有时候又称作数据寄存器</p>
</blockquote>
<h4 id="必要时拆分通用寄存器"><a href="#必要时拆分通用寄存器" class="headerlink" title="必要时拆分通用寄存器"></a>必要时拆分通用寄存器</h4><p>通用寄存器的数量有限，有时候寄存器数量可能无法满足需求，这个时候可以将寄存器高低位分开单独存储，将一个寄存器拆分为两个来使用，如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;低位存储20</span><br><span class="line">MOV AL,20</span><br><span class="line">;高位存储08</span><br><span class="line">MOV AH,8</span><br><span class="line"></span><br><span class="line">;------------结果----------</span><br><span class="line">;AX=0820	BX=0000	...</span><br><span class="line"></span><br><span class="line">;此时将AL赋值给BH，AH赋值给BL</span><br><span class="line">MOV BH,AL</span><br><span class="line">MOV BL,AH</span><br><span class="line"></span><br><span class="line">;------------结果----------</span><br><span class="line">;AX=0820	BX=2008	...</span><br></pre></td></tr></table></figure>



<h3 id="段寄存器-1"><a href="#段寄存器-1" class="headerlink" title="段寄存器"></a>段寄存器</h3><p>8086CPU为了能使用1MB的内存空间，故将内存采用分段的方式进行管理，由于数据总线只有16位，故其只能表达2^16就是64KB的内存空间，所以将内存空间分为1024&#x2F;64即16个段，并分为4种，并交由4个16为的段寄存器管理，段寄存器中存放了段基值(段基址的高16位)，即:</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>名称</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>CS</td>
<td>代码段寄存器: Code Segment</td>
<td>存放当前运行的程序代码所在的段的段基值</td>
</tr>
<tr>
<td>DS</td>
<td>数据段寄存器: Data Segment</td>
<td>存放当前程序所使用的数据所在的段的段基值</td>
</tr>
<tr>
<td>SS</td>
<td>堆栈段寄存器: Stack Segment</td>
<td>存放当前程序所使用的堆栈所在的段的段基值</td>
</tr>
<tr>
<td>ES</td>
<td>附加段寄存器: Extra Segment</td>
<td>存放当前程序所使用的附加数据所在的段的段基值</td>
</tr>
</tbody></table>
<h3 id="指针寄存器"><a href="#指针寄存器" class="headerlink" title="指针寄存器"></a>指针寄存器</h3><p>指正寄存器，用于存放目标的地址。</p>
<p>在8086CPU中存在两种指针寄存器，如下:</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>名称</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>BP</td>
<td>基址指针寄存器: Base Pointer Register</td>
<td>栈中的某一数据在栈内的偏移量，相对于SP的指针</td>
</tr>
<tr>
<td>SP</td>
<td>堆栈指针寄存器: Stack Pointer Register</td>
<td>存储栈基址在段内的偏移量，相对于SS的指针</td>
</tr>
</tbody></table>
<p>BP，SP，SS(堆栈段寄存器)一般三种连用</p>
<p>SS保存了堆栈段的段基址，SP存储了堆栈位于段内的偏移量，BP存储了堆栈中数据的基地址</p>
<h3 id="变址寄存器"><a href="#变址寄存器" class="headerlink" title="变址寄存器"></a>变址寄存器</h3><p>变址：操作数在存储单元中某相对位置的偏移地址，8086CPU中有两个变址寄存器，分别是:</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>名称</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>SI</td>
<td>源变址寄存器: Source Index</td>
<td>附加数据地址在段内的偏移量，相对与ES的指针</td>
</tr>
<tr>
<td>DI</td>
<td>目标变址寄存器: Destination Index</td>
<td>数据地址在段内的偏移量，相对于DS的指针</td>
</tr>
</tbody></table>
<h3 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h3><p>控制寄存器是一个用于存储和表达CPU操作模式以及当前任务特性的一个寄存器，</p>
<p>在8086处理器中其实没有当下意义上的控制寄存器，而是使用指令指针寄存器加上标志寄存器实现，即：</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>名称</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>IP</td>
<td>指令指针寄存器: Instruction Pointer</td>
<td>指向指令地址的在代码段内的偏移量，相对于CS的指针</td>
</tr>
<tr>
<td>FLAGS</td>
<td>标志寄存器: Flags</td>
<td>用于存储类现在控制类似现在控制寄存器的标志位，比较特殊，看下面</td>
</tr>
</tbody></table>
<h4 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h4><p>标志寄存器中记录了多个标志位的属性，而各标志位则表示CPU在运行程序的过程中的一些状态，标志位均由CPU自动生成，在DOS DEBUG命令中使用R命令可以看到末尾输出了若干标志位的值，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-R</span><br><span class="line"></span><br><span class="line">AX=0000	BX=0000	CX=0000	DX=0000	SP=FFEE	BP=0000	SI=0000	DI=0000	</span><br><span class="line">DS=2B4A	ES=2B4A	SS=2B4A	CS=2B4A	IP=0000	NV NP EI PL NZ NA PO NC</span><br><span class="line">;NV NP EI PL NZ NA PO NC 就是标志位的值</span><br></pre></td></tr></table></figure>

<p>标志位具体作用如下:</p>
<table>
<thead>
<tr>
<th>标识名称</th>
<th>标识符描述</th>
<th>1(缩写)</th>
<th>1(描述)</th>
<th>0(缩写)</th>
<th>0(描述)</th>
</tr>
</thead>
<tbody><tr>
<td>OF:溢出标志</td>
<td>表运算结果是否超出机器表达能力</td>
<td>OV</td>
<td>overflowValue<br>溢出</td>
<td>NV</td>
<td>noOverflow<br>未溢出</td>
</tr>
<tr>
<td>DF:方向标志</td>
<td>表串操作的地址的方向变化</td>
<td>DN</td>
<td>down<br>每次串操作后DI和SI递减，即由高向低变化</td>
<td>UP</td>
<td>up<br>每次串操作后DI和SI递增，即由低向高变化</td>
</tr>
<tr>
<td>IF:中断标志</td>
<td>Interrupt Enable Flag<br>表可处理器是否屏蔽中断请求</td>
<td>DI</td>
<td>disable<br>处理器响应中断请求</td>
<td>EI</td>
<td>enable<br>处理器屏蔽中断请求</td>
</tr>
<tr>
<td>SF:符号标志</td>
<td>表运算结果的正负</td>
<td>NG</td>
<td>negative<br>结构为负</td>
<td>PL</td>
<td>plus<br>结果为正</td>
</tr>
<tr>
<td>ZF:零标志</td>
<td>表运算结果是否为0</td>
<td>ZR</td>
<td>zero<br>运算结果为0</td>
<td>NZ</td>
<td>noZero<br>运算结果不为0</td>
</tr>
<tr>
<td>AF:辅助进位标志</td>
<td>表在字节运算是D3位是否项D4位进&#x2F;借位</td>
<td>AC</td>
<td>auxiliaryCarry<br>产生借&#x2F;进位</td>
<td>NA</td>
<td>noAuxiliaryCarry<br>未产生借&#x2F;进位</td>
</tr>
<tr>
<td>PF:奇偶标志</td>
<td>表执行指令的操作数的低8位中<code>1的个数</code>是偶数个还是奇数个</td>
<td>PE</td>
<td>parityEven<br>低8位中1个数位偶数</td>
<td>PO</td>
<td>parityOdd<br>低8位中1个数位奇数</td>
</tr>
<tr>
<td>CF:进位标志</td>
<td>表字节运算是D7位是否向D8位借&#x2F;进位<br>或在字运算时D15是否向D16位借&#x2F;进位</td>
<td>CY</td>
<td>carry<br>产生借&#x2F;进位</td>
<td>CF</td>
<td>noCarry<br>未产生借&#x2F;进位</td>
</tr>
<tr>
<td>TF:陷阱标志</td>
<td>Trap Flag<br>是否工作在单步调试中断下,需IF&#x3D;1时才会生效，TF在DEBUG命令中不可见</td>
<td>?</td>
<td>每执行一步都会产生一个中断请求</td>
<td>?</td>
<td>不要产生中断请求</td>
</tr>
</tbody></table>
<blockquote>
<p>Dn:表示二进制字节数据从右往左数第n位数</p>
</blockquote>
<blockquote>
<p>英文名有些是我猜的，英语不好，可能有错。</p>
</blockquote>
<h2 id="i386处理器"><a href="#i386处理器" class="headerlink" title="i386处理器"></a>i386处理器</h2><p>X86时代，CPU内部的部分寄存器被扩展到32位，并且将之前80X86时代的指正寄存器和变址寄存器页归类到通用寄存器</p>
<p>而这些被扩展的寄存器都在原有名字前加上了E，也就是extension的缩写</p>
<p>如下：</p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/i386%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="i386寄存器"></p>
<h3 id="通用寄存器-32Bit"><a href="#通用寄存器-32Bit" class="headerlink" title="通用寄存器(32Bit)"></a>通用寄存器(32Bit)</h3><p>通用寄存器的功能与之前8086相差不大，主要还是被扩展到了32位</p>
<p>为兼容之前的程序，被扩展到32位的通用寄存器依旧可以将其低16位拆出单独使用，其命名也和8086时一样，且AX、BX、CX、DX，通过依旧可再继续分别拆分成两个8位寄存器。</p>
<h3 id="指令指针寄存器-32Bit"><a href="#指令指针寄存器-32Bit" class="headerlink" title="指令指针寄存器(32Bit)"></a>指令指针寄存器(32Bit)</h3><p>指令指针寄存器也被扩展到32位，依旧表示在指令地址在代码段中的偏移量，EIP的低16位可单独拿出来使用，即和原来的IP一样</p>
<h3 id="标志寄存器-32Bit"><a href="#标志寄存器-32Bit" class="headerlink" title="标志寄存器(32Bit)"></a>标志寄存器(32Bit)</h3><p>标志寄存器(EFLAGS)用于存放命令在运行过程中产生的一些特征。在X86中也被扩展到32位，并在其原先的基础上也增加了标志位,如下<a href="https://blog.csdn.net/weixin_39524247/article/details/112107720">图片来源</a>:</p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/32%E4%BD%8D%E6%A0%87%E5%BF%97%E4%BD%8D%E5%9B%BE.jpg" alt="32位标志位图"></p>
<p>在之前的基础上，X86主要新增了如下寄存器</p>
<table>
<thead>
<tr>
<th>标识名称</th>
<th>标识符描述</th>
<th>1(缩写)</th>
<th>1(描述)</th>
<th>0(缩写)</th>
<th>0(描述)</th>
</tr>
</thead>
<tbody><tr>
<td>IOPL: I&#x2F;O特权标志</td>
<td>比较特别，用2Bit表示，表一个阈值，只有进程的特权级小于阈值时该IO指令才被允许执行</td>
<td>？</td>
<td>&#x2F;</td>
<td>？</td>
<td>&#x2F;</td>
</tr>
<tr>
<td>NT: 嵌套任务标志</td>
<td>表当前任务是否嵌套在其他任务中</td>
<td>？</td>
<td>被嵌套</td>
<td>？</td>
<td>未被嵌套</td>
</tr>
<tr>
<td>RF: 重启动标志</td>
<td>表当遇到异常时，是否发生中断</td>
<td>？</td>
<td>不会产生中断</td>
<td>？</td>
<td>会产生中断</td>
</tr>
<tr>
<td>VM: 虚拟8086模式标志</td>
<td>表是否将该任务切换到虚拟8086模式下运行</td>
<td>？</td>
<td>任务在虚拟8086模式中运行</td>
<td>？</td>
<td>任务在保护模式运行</td>
</tr>
</tbody></table>
<p>VIF和VIP貌似和IF标志有关，资料较少，且80386处理器还没有该标志，貌似是在某代奔腾处理器后才出现。</p>
<p>ID标志只在奔腾处理器上才有，表示该处理器是否支持CPUID命令。</p>
<h3 id="控制寄存器-X86"><a href="#控制寄存器-X86" class="headerlink" title="控制寄存器(X86)"></a>控制寄存器(X86)</h3><p>X86的控制寄存器概念上和80X86不一样，准确说是80X86那时候没有现在意义上控制寄存器的概念。此时的控制寄存器是一个个独立的个体，控制寄存器中可以分出若干个控制位，用于控制和确定处理器的一些特性。</p>
<p>X86控制寄存器有4个控制寄存器(某代奔腾与80486后为5个)，都为32位，如下:</p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/X86%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8%E7%BB%93%E6%9E%84.jpg" alt="X86控制寄存器结构"></p>
<h4 id="CR0"><a href="#CR0" class="headerlink" title="CR0"></a>CR0</h4><p>CR0主要记录一些CPU重要的特性的状态。</p>
<table>
<thead>
<tr>
<th>控制位名称</th>
<th>位置</th>
<th>描述</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>PE: Protedted Enable</td>
<td>0</td>
<td>启用保护</td>
<td>运行在实模式</td>
<td>运行在保护模式</td>
</tr>
<tr>
<td>MP: Moniter coprocessor</td>
<td>1</td>
<td>协处理器是否可供任务使用</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>EM: Emulate coprocessor</td>
<td>2</td>
<td>当协处理器不存在时，是否仿真协处理器</td>
<td>抛出设备不存在异常</td>
<td>将由软件模拟</td>
</tr>
<tr>
<td>TS: Task Switched</td>
<td>3</td>
<td>协处理器状态是否以保存</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>ET: Extension Type</td>
<td>4</td>
<td>处理器扩展信息，表示协处理器类型</td>
<td>使用80287协处理器</td>
<td>使用80387(80X87)协处理器</td>
</tr>
<tr>
<td>NE: Numeric Error</td>
<td>5</td>
<td>80486及以上CPU：选择何种协处理器错误机制</td>
<td>启用80X87内部错误报告基址</td>
<td>启用PC形式的80X87内部错误报告基址</td>
</tr>
<tr>
<td>WP: Write Protect</td>
<td>16</td>
<td>80486后才有，是否开启写保护，阻止超级用户程序向用户级只读页面的写入</td>
<td>禁用(放行)</td>
<td>开启(阻止)</td>
</tr>
<tr>
<td>AM: Alignment Mask</td>
<td>18</td>
<td>是否启用线性地址对其检查</td>
<td>否(允许任意地址访问)</td>
<td>是(不对齐报错)</td>
</tr>
<tr>
<td>NW: Not Writethrough</td>
<td>29</td>
<td>指定CPU缓存写策略</td>
<td>Write-through策略(写缓存时更新内存)</td>
<td>Write-back策略(写缓存时不更新内存)</td>
</tr>
<tr>
<td>CD: Cache Disable</td>
<td>30</td>
<td>启用缓存</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>PG: Paging</td>
<td>31</td>
<td>启用分页机制</td>
<td>否(分页相关控制位可能会失效)</td>
<td>是</td>
</tr>
</tbody></table>
<blockquote>
<p>ET在后期CPU中的意义待研究，这里是80386(i386)处理器的。</p>
</blockquote>
<blockquote>
<p>NE资料比较乱，目前使用百度百科中在80486上的定义</p>
</blockquote>
<h4 id="CR1"><a href="#CR1" class="headerlink" title="CR1"></a>CR1</h4><blockquote>
<p>CR1被保留备用，暂无意义。当然、也有可能是没对外公布。</p>
</blockquote>
<h4 id="CR2"><a href="#CR2" class="headerlink" title="CR2"></a>CR2</h4><p>CR2和分页机制有关，它很特别，整个寄存器存放一个线性地址(也就是和分页机制去找物理地址的那个)，用于保存最近一次出现页异常时所使用的那个线性地址，以便操作系统处理异常。</p>
<h4 id="CR3"><a href="#CR3" class="headerlink" title="CR3"></a>CR3</h4><p>CR3也是和分页机制有关，在之前[线性地址](&#x2F;#线性地址(linear address))中提到，当TLB未命中时，将通过CR3取寻找页目录(Page Directory)的位置。正因如此，CR3也被称为PDBR。</p>
<p>在CR3中，高20位保存着也目录基址的高20位，而页目录基址的低12位假定为0，这就构成了当前活跃进程的页目录基址。因此每个页目录基址正好是4KB对齐，且每个页目录大小为4KB。由于页目录项大小为4B，故一个页目录可存放1024个项。</p>
<p>在80386中CR3大小为32位，也目录基址仅占据20位，故仍有空间用于控制位，如下:</p>
<table>
<thead>
<tr>
<th>控制位名称</th>
<th>位置</th>
<th>描述</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>PWT</td>
<td>3</td>
<td>页在被缓存时是否页写入内存</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>PCD</td>
<td>4</td>
<td>页是否不可被缓存</td>
<td>可</td>
<td>不可</td>
</tr>
</tbody></table>
<blockquote>
<p>其实这两个控制位和在页目录项中的同名控制位意思一样</p>
</blockquote>
<h4 id="CR4"><a href="#CR4" class="headerlink" title="CR4"></a>CR4</h4><p>CR4好像是80486以及某代奔腾处理器后出现的，用于表示一些后期的扩展标识，如下:</p>
<table>
<thead>
<tr>
<th>控制位名称</th>
<th>位置</th>
<th>描述</th>
<th>0</th>
<th>1</th>
</tr>
</thead>
<tbody><tr>
<td>VME</td>
<td>0</td>
<td>是否在虚拟8086模式下启用中断和异常处理扩展</td>
<td>否</td>
<td>将异常和中断回调给8086程序，能够提高性能</td>
</tr>
<tr>
<td>PVI</td>
<td>1</td>
<td>是否启用保护模式下虚拟中断</td>
<td>在保护模式下禁用VIF(virtual interrupt flag)</td>
<td>在保护模式下启用VIF(virtual interrupt flag)</td>
</tr>
<tr>
<td>TSD</td>
<td>2</td>
<td>禁用特权级为0之外的程序获取处理器时间戳</td>
<td>允许任何特权级上执行RDTSC指令</td>
<td>仅允许特权级为0的进程执行RDTSC指令</td>
</tr>
<tr>
<td>DE</td>
<td>3</td>
<td>启用调试扩展</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>PSE</td>
<td>4</td>
<td>是否开启4MB大分页模式</td>
<td>否、使用经典模式</td>
<td>是</td>
</tr>
<tr>
<td>PAE</td>
<td>5</td>
<td>是否开启物理地址扩展(PEA)</td>
<td>使用32位物理地址</td>
<td>扩展到36位</td>
</tr>
<tr>
<td>MCE</td>
<td>6</td>
<td>是否启用某种异常检测(没看懂文档)</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>PGE</td>
<td>7</td>
<td>是否启用全局页面(将常用或共享内容放到公共页内，貌似能优化TBL)</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>PCE</td>
<td>8</td>
<td>禁用特权级为0之外的程序获取处理器性能计数器信息</td>
<td>允许任意特权级的进程执行RDPMC命令</td>
<td>仅允许特权级为0的进程执行RDPMC命令</td>
</tr>
<tr>
<td>OSFXSR</td>
<td>9</td>
<td>操作系统是否能够支FXSAVE和FXRSTOR指令</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>OSXMMEXCPT</td>
<td>10</td>
<td>操作系统是否能够支持无掩码的SIMD异常</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>VMXE</td>
<td>13</td>
<td>是否启用VMX操作(和因特尔虚拟化有关)</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>SMXE</td>
<td>14</td>
<td>是否启用SMX(Safer Mode Extensions，某种安全模式)</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>PCIDE</td>
<td>17</td>
<td>是否启用进程上下文标识符(process-context identifiers)</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>OSXSMXE</td>
<td>18</td>
<td>操作系统是否能够支持SMX(Safer Mode Extensions)</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>SMEP</td>
<td>20</td>
<td>是否启用SMPE(Supervisor Mode Execution Protection,可以防止一些不受信任的程序访问到内核空间)</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<blockquote>
<p>PAE(Physical Address Extension, 物理地址扩展),4GB寻址范围无法满足部分服务器需求故通过某些方法将物理地址扩展到36位，使得寻址空间为2^36&#x3D;64GB</p>
</blockquote>
<h1 id="寻址模式"><a href="#寻址模式" class="headerlink" title="寻址模式"></a>寻址模式</h1><blockquote>
<p>摘抄维基百科的一句提示:</p>
<p>各种寻址模式都没有一个被普遍接受的的名称。不同的作者和计算机制造商可以为相同的寻址模式赋予不同的名称，或者为不同的寻址模式赋予相同的名称。</p>
</blockquote>
<p>寻址模式(Addressing modes)是CPU设计中<a href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B">指令集架构</a>的一部分，是CPU通过缓存的数据或特定常数计算出内存地址的一种模式。</p>
<p>早期8086与后期X86(例如i386)之间存在差别，i386寻址能力由1MB突破到4GB、指令的操作数提高到32位</p>
<h2 id="直接寻址"><a href="#直接寻址" class="headerlink" title="直接寻址"></a>直接寻址</h2><p>直接寻址又称为绝对寻址，正如字面意思一样，直接寻址的指令中的立即数就是操作数的有效地址，直接寻址就是直接通过一个给定的地址跳到目标数据所在位置，找到目标数据。</p>
<p>在8086CPU中，寻址指令中的操作数地址<code>只是该操作数地址的16位偏移量</code>，还需要去DS(数据段寄存器)中拿到16位段基值，相结合才是真正的操作数地址</p>
<p>MOV AX [2000H]</p>
<p>在没特殊说明的情况下，直接寻址的操作数一般在内存的数据段中。也就是放在DS里面，所以就隐含了段寄存器是DS，但在8086&#x2F;8088中，因为其设计特殊，允许段超越，即允许CS，SS，ES作为段寄存器，测试需要在指令中标注，并在地址参数前加上“:”;</p>
<p>MOV AX EX ：[2000H]</p>
<h2 id="相对寻址"><a href="#相对寻址" class="headerlink" title="相对寻址"></a>相对寻址</h2><p>相对寻址，相对是对自己而言，通常当前指令地址就是相对地址，而相对地址一般存放在PC(程序计数器)中，然后加上偏移量，而偏移量一般是指令中的立即数，通过两者相加得到有效地址。</p>
<p>相对寻址与基址+偏移量寻址有所不同，相对寻址只能通过当前指令地址作为相对地址，而基址+偏移量寻址的相对地址可变。百度百科的这张图就很直观。</p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80%E7%A4%BA%E4%BE%8B%E5%9B%BE.jpg" alt="相对寻址示例图"></p>
<h2 id="基址-偏移量寻址"><a href="#基址-偏移量寻址" class="headerlink" title="基址+偏移量寻址"></a>基址+偏移量寻址</h2><p>基址加偏移量寻址，就例如之前通过段基址加段内偏移量得到线性地址一样，由一个基址(也可以看做是一个相对地址)与偏移量相加得到有效地址。</p>
<p>其中基址和偏移量都可以来源于寄存器。其中基址来源于可以是基址寄存器BX(数据基址寄存器)；偏移量来自变址寄存器SI(源变址寄存器)、DI(目标变址寄存器)。</p>
<p>偏移量也可以是指令中的立即数或是某个计算结果。</p>
<h2 id="寄存器寻址"><a href="#寄存器寻址" class="headerlink" title="寄存器寻址"></a>寄存器寻址</h2><p>寄存器寻址本质上表示在指令参数中没有有效地址，且操作数的有效地址不在内存中，而是放在CPU的通用寄存器中。在某些计算机上寄存器寻址不被认为是寻址模式。</p>
<p>下面的寄存器间接寻址就是寄存器寻址与间接寻址的概念的结合，但寄存器寻址和间接寻址本身概念上是有点区别的。</p>
<h2 id="间接寻址"><a href="#间接寻址" class="headerlink" title="间接寻址"></a>间接寻址</h2><p>间接是相对的，间接寻址表示指令中给出的地址并不是操作数的有效地址，而是一个指针(也可以叫指示器)，所指位置存放着有效地址，若指示器指向一个寄存器中的某一位置，那就和前面的寄存器寻址的概念结合，变成寄存器间接寻址。</p>
<p>间接寻址是在直接寻址的基础上建立的，当执行若干次间接寻址得到有效地址后，会再进行一次直接寻址得到目标数据，间接寻址在百度百科上的图片也很直观，如下：</p>
<p><img data-src="/../image/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%A6%82%E8%BF%B0%E5%9B%BE.png" alt="间接寻址概述图"></p>
<h3 id="寄存器间接寻址"><a href="#寄存器间接寻址" class="headerlink" title="- 寄存器间接寻址"></a>- 寄存器间接寻址</h3><p>若指针指向的位置是某一寄存器中的某一位置，那么就是寄存器间接寻址，在寄存器间接寻址方式中，操作数的有效地址存放在SI、DI、BX、BP其中之一。</p>
<p>如果有效地址在SI、DI、BX中，则以DS段寄存器中的内容为段值。</p>
<p>如果有效地址在BP中，则以SS段寄存器中的内容为段值。</p>
<p>通常指令写作 MOV AX,[SI] ；其中[SI]表示寄存器SI中的地址。</p>
<p>在MCS-51单片机中，为了对寄存器寻址和寄存器间接寻址加以区别，在寄存器名称前加一个符号@来表示寄存器间接寻址，如MOV A,@R0。</p>
<h2 id="隐含寻址"><a href="#隐含寻址" class="headerlink" title="隐含寻址"></a>隐含寻址</h2><p>隐含寻址模式，在X86汇编语言中也称为隐式寻址模式</p>
<p>隐含寻址指令是一种可能没有在指令中明确源 和&#x2F;或 目标的一种指令，其指令的操作码可能就隐含了该指令操作时的源 和&#x2F;或 目标。</p>
<p><em>不知道这么说会不会好理解一点点</em></p>
<p>例如在执行ADD指令时，ADD指令本身就隐含了本次操作的目标地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">;---先赋值---</span><br><span class="line">MOV AX,18</span><br><span class="line">;---再去累加，累加的东西目标就是源自己---</span><br><span class="line">ADD AX,5</span><br><span class="line"></span><br><span class="line">;-----------------------</span><br><span class="line">;AX=001D  ...</span><br></pre></td></tr></table></figure>







<p><br><br><br><br><br><br></p>
<p style="text-align:center">>------参考文献------<</p>

<blockquote>
<p><a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98?fromModule=lemma_search-box#1">百度百科-内存</a></p>
<p><a href="https://zh.wikipedia.org/wiki/Intel_8086">维基百科-Intel 8086</a></p>
<p><a href="https://blog.csdn.net/wdqqbyt4321/article/details/96978639">CSDN-呆呆觉得这事儿不简单-内存寻址(1，2)</a></p>
<p><a href="https://baike.baidu.com/item/%E5%AE%9E%E6%A8%A1%E5%BC%8F/7354531?fr=ge_ala">百度百科-实模式</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E7%9C%9F%E5%AF%A6%E6%A8%A1%E5%BC%8F">维基百科-实模式</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E4%BF%9D%E8%AD%B7%E6%A8%A1%E5%BC%8F">维基百科-保护模式</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E9%95%BF%E6%A8%A1%E5%BC%8F">维基百科-长模式</a></p>
<p><a href="http://en.cnki.com.cn/Article_en/CJFDTotal-HDZR200001012.htm">Jing_Sen L .The Memory Address of Intel X86 Processor in 16 bit Protected Mode[J].JOURNAL OF HENAN UNIVERSITY (NATURAL SCIENCE), 2000.</a></p>
<p><a href="https://www.cnblogs.com/SuperGreen/p/15490472.html">博客园-内存管理——段描述符</a></p>
<p><a href="https://www.intel.cn/content/www/cn/zh/developer/articles/technical/intel-sdm.html?iid=tech_vt_tech+64-32_manuals">Intel® 64 and IA-32 Architectures Software Developer Manuals</a></p>
<p><a href="https://baike.baidu.com/item/%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80/3283849?fr=ge_ala">百度百科-逻辑地址</a></p>
<p><a href="https://baike.baidu.com/item/%E6%AE%B5%E5%9F%BA%E5%9D%80/7339630?fr=ge_ala">百度百科-段基址</a></p>
<p><a href="https://doc.taixueshu.com/journal/20020098cqdxxb.html">湛辉来.X86体系中保护模式下的内存访问机制[J].重庆大学学报(自然科学版),2002,(6):67-70.</a></p>
<p><a href="https://blog.csdn.net/csdn_gddf102384398/article/details/100089178">CSDN-x86架构之实模式和保护模式的简单分析</a></p>
<p><a href="https://blog.csdn.net/OOFFrankDura/article/details/84403741">CSDN-操作系统OS-分段式内存管理为什么不会产生内碎片</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/444272105">知乎-操作系统期末复习-分页存储管理</a></p>
<p><a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80/9013682?fr=ge_ala">百度百科-线性地址</a></p>
<p><a href="https://blog.csdn.net/weixin_42052102/article/details/83063614">CSDN-PWT、PCD（填坑篇）</a></p>
<p><a href="https://zh.wikipedia.org/zh-hans/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80">维基百科-物理地址</a></p>
<p><a href="https://baike.baidu.com/item/%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80/2901583?fromModule=lemma_search-box">百度百科-物理地址</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F">维基百科-寻址模式</a></p>
<p><a href="https://blog.csdn.net/weixin_45745854/article/details/127310343">CSDN-8086CPU的寻址方式：浅谈8种寻址方式</a></p>
<p><a href="https://baike.baidu.com/item/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4/9979890?fr=ge_ala">百度百科-汇编指令</a></p>
<p><a href="https://baike.baidu.com/item/%E7%AB%8B%E5%8D%B3%E6%95%B0/3062020?fr=ge_ala">百度百科-立即数</a></p>
<p><a href="https://baike.baidu.com/item/%E7%9B%B4%E6%8E%A5%E5%AF%BB%E5%9D%80/302009?fr=ge_ala">百度百科-直接寻址</a></p>
<p><a href="https://baike.baidu.com/item/%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80?fromModule=lemma_search-box">百度百科-相对寻址</a></p>
<p><a href="https://baike.baidu.com/item/%E5%9F%BA%E5%9D%80%E5%8A%A0%E5%8F%98%E5%9D%80%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F/6686487?fr=ge_ala">百度百科-基址加变址寻址方式</a></p>
<p><a href="https://baike.baidu.com/item/%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80/10335629?fr=ge_ala">百度百科-简介寻址</a></p>
<p><a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8/187682">百度百科-寄存器</a></p>
<p><a href="https://baike.baidu.com/item/%E9%80%9A%E7%94%A8%E5%AF%84%E5%AD%98%E5%99%A8/283978">百度百科-通用寄存器</a></p>
<p><a href="https://baike.baidu.com/item/%E5%9F%BA%E5%9C%B0%E5%9D%80%E5%AF%84%E5%AD%98%E5%99%A8/12752082?fr=ge_ala">百度百科-基地址寄存器</a></p>
<p><a href="https://baike.baidu.com/item/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8/6616912?fr=ge_ala">百度百科-段寄存器</a></p>
<p><a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8/9335215?fr=ge_ala">百度百科-控制寄存器</a></p>
<p><a href="https://blog.csdn.net/m0_51303687/article/details/120794806">CSDN-2021-10-16 8086FLAGS寄存器及其状态说明</a></p>
<p><a href="https://blog.csdn.net/qq_41872042/article/details/88792313">CSDN-微机接口与汇编语言——dosbox中debug下的标志位解释</a></p>
<p>INTEL 80386 PROGRAMMER’S REFERENCE MANUAL 1986</p>
<p>一些由AI生成的资料以及来自AI的见解</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记分享</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark流计算</title>
    <url>/article/Spark%E6%B5%81%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h1 id="什么是SparkStreaming"><a href="#什么是SparkStreaming" class="headerlink" title="什么是SparkStreaming"></a>什么是SparkStreaming</h1><blockquote>
<p>用于快速上手，有很多细节，后面有时间单独出</p>
</blockquote>
<p>Spark Streaming 是Spark提供的一个<code>流计算</code>框架  <a href="https://spark.apache.org/docs/latest/streaming-programming-guide.html#initializing-streamingcontext">点击跳转官方文档</a></p>
<p>与Flink类似，Spark Streaming也可从Kafka。Flume，TCP套接字等众多途径获取数据，也有map(),reduce(),windows()等等一系列的算子</p>
<p><em><span id="more"></span></em></p>
<p>Spark Streaming是基于Spark RDD Api（Spark Core Api）的扩展，最终的执行者还是Spark Core API，所以，与Flink不一样，Spark的流计算其实是使用微批实现的，所以在流计算过程可以使用RDD近乎相同的代码编写</p>
<p>具体在工作时，Spark Streaming会将收到的原数据以<code>秒</code>为单位切片成多个RDD序列，该序列被成为<code>DStream</code>(Discretized Stream | 离散流)，DStream是Spark Streaming的一个高级抽象，用于表示类似Flink DataStream的哪种<code>连续不断</code>的数据，对一个DStream进行相应的算子计算，相当于对里面<code>所有的RDD</code>分别进行算子计算</p>
<p>与Flink一样，每个Application的执行是一个<code>长期持久化</code>的运行任务，所以，每个应用程序都会被分配并<code>长期占用</code>一个集群的核心(本地运行则为线程)，所以，在运行较大项目时，请确保集群资源足够</p>
<h1 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h1><p>如果你是初学者，先快速跟着我体验下Spark流计算</p>
<p>首先我们要对POM文件添加相应的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spark streaming 流式计算库--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-streaming_$&#123;scala.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spark.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>简单颜色下，使用Spark去监听9999端口的套接字数据，并做词频统计</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.dstream.&#123;<span class="type">DStream</span>, <span class="type">ReceiverInputDStream</span>&#125;</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.&#123;<span class="type">Seconds</span>, <span class="type">StreamingContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//创建配置对象</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">    conf.setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">    conf.setAppName(<span class="string">&quot;Test01&quot;</span>)</span><br><span class="line">    <span class="comment">//创建Spark Streaming Context</span></span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf,<span class="type">Seconds</span>(<span class="number">10</span>))</span><br><span class="line">    <span class="comment">//你要在创建上下文是显性的告诉Spark DStream的数据时按几秒分割的,这我后面会讲</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stream:<span class="type">ReceiverInputDStream</span>[<span class="type">String</span>] = ssc.socketTextStream(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line">    stream</span><br><span class="line">      .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      .map((_,<span class="number">1</span>))</span><br><span class="line">      .reduceByKey(_+_)</span><br><span class="line">      .print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    ssc.start()               <span class="comment">//开始计算</span></span><br><span class="line">    ssc.awaitTermination()    <span class="comment">//等待计算结果出来</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用netcat，创建个服务端的套接字接口,随后发两条数据过去</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@master ~]# nc -lk 9999</span><br><span class="line">aaa bbb</span><br><span class="line">aaa ccc</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-------------------------------------------</span><br><span class="line">Time: 1666512480000 ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(bbb,1)</span><br><span class="line">(ccc,1)</span><br><span class="line">(aaa,2)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，在设置了微批间隔为10秒后，相单于每10秒开一个滚动窗口，不过严格来说不能叫窗口，这仅是各个微批的批大小罢了</p>
<p>当然，为了好理解，前期直接将其看成时间窗口就行</p>
</blockquote>
<h1 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h1><p>基本上每个DStream 输入都会创建一个Receiver用于持久化监听数据(除了来自文件的流，其他都要)，每个Receiver会<code>独占</code>一个集群核心(本地运行则是线程)</p>
<h2 id="文件流"><a href="#文件流" class="headerlink" title="文件流"></a>文件流</h2><p>文件流不仅仅可以是本地文件系统，也可是分布式文件系统，例如HDFS</p>
<p>textFileStream会去检查文件夹内<code>新增</code>的内容</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.dstream.<span class="type">DStream</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.&#123;<span class="type">Seconds</span>, <span class="type">StreamingContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//创建配置对象</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">    conf.setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">    conf.setAppName(<span class="string">&quot;Test01&quot;</span>)</span><br><span class="line">    <span class="comment">//创建Spark Streaming Context</span></span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf,<span class="type">Seconds</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stream:<span class="type">DStream</span>[<span class="type">String</span>] = ssc.textFileStream(<span class="string">&quot;file:///D:/SparkProject/word/&quot;</span>)</span><br><span class="line"></span><br><span class="line">    stream</span><br><span class="line">      .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      .map((_,<span class="number">1</span>))</span><br><span class="line">      .reduceByKey(_+_)</span><br><span class="line">      .print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在word文件夹创建一个文件 内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aaa bbb</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">-------------------------------------------</span><br><span class="line"><span class="type">Time</span>: <span class="number">1666514150000</span> ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(aaa,<span class="number">1</span>)</span><br><span class="line">(bbb,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h2><p>监听本地9999端口，上面小试牛刀演示过了</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> stream:<span class="type">ReceiverInputDStream</span>[<span class="type">String</span>] = ssc.socketTextStream(<span class="string">&quot;localhost&quot;</span>,<span class="number">9999</span>)</span><br></pre></td></tr></table></figure>

<h2 id="RDD队列"><a href="#RDD队列" class="headerlink" title="RDD队列"></a>RDD队列</h2><p>queueStream会监听RDD序列中新增内容</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.dstream.<span class="type">DStream</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.&#123;<span class="type">Seconds</span>, <span class="type">StreamingContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//创建配置对象</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">    conf.setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">    conf.setAppName(<span class="string">&quot;Test01&quot;</span>)</span><br><span class="line">    <span class="comment">//创建Spark Streaming Context</span></span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf,<span class="type">Seconds</span>(<span class="number">10</span>))    <span class="comment">//你要在创建上下文是显性的告诉Spark DStream的数据时按几秒分割的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sc = ssc.sparkContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> myRDDs = <span class="keyword">new</span> mutable.<span class="type">Queue</span>[<span class="type">RDD</span>[<span class="type">Int</span>]]()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stream = ssc.queueStream(myRDDs)</span><br><span class="line"></span><br><span class="line">    stream</span><br><span class="line">      .map((<span class="number">1</span>,_))</span><br><span class="line">      .reduce((a,b) =&gt; (a._1 + b._1 , a._2 + b._2))    <span class="comment">//(count,sum)</span></span><br><span class="line">      .map(d =&gt; <span class="string">&quot;数据条数%d；和为%d&quot;</span>.format(d._1,d._2))</span><br><span class="line">      .print()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    ssc.start()               <span class="comment">//开始计算</span></span><br><span class="line"><span class="comment">//    ssc.awaitTermination()    //不等，继续执行</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i &lt;- <span class="number">1</span> to <span class="number">30</span>)&#123;     <span class="comment">//循环30次</span></span><br><span class="line">      myRDDs += sc.makeRDD(<span class="type">Array</span>(i,i+<span class="number">1</span>,i+<span class="number">2</span>))   <span class="comment">//向序列中新增RDD</span></span><br><span class="line">      <span class="type">Thread</span>.sleep(<span class="number">1000</span>)    <span class="comment">//间隔1秒，全部跑完要30秒</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ssc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">-------------------------------------------</span><br><span class="line"><span class="type">Time</span>: <span class="number">1666515630000</span> ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">数据条数<span class="number">3</span>；和为<span class="number">6</span></span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="type">Time</span>: <span class="number">1666515640000</span> ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">数据条数<span class="number">3</span>；和为<span class="number">9</span></span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="type">Time</span>: <span class="number">1666515650000</span> ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">数据条数<span class="number">3</span>；和为<span class="number">12</span></span><br></pre></td></tr></table></figure>

<h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><blockquote>
<p>这个实战中比较常见，多讲几句</p>
</blockquote>
<p>Spark提供了两套Kafka整合方案，<strong>spark-streaming-kafka-0-8</strong>和<strong>spark-streaming-kafka-0-10</strong>，前者已经在Spark2.3.0后弃用，所以下面我<code>仅针对0-10</code></p>
<p>所以我们要在POM文件添加这个依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spark 连接kafka--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-streaming-kafka-0-10_$&#123;scala.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>

<p>我们可以通过调用<code>KafkaUtils</code>对象的<code>createDirectStream</code>方法来创建输入流</p>
<p>createDirectStream有三个参数</p>
<ul>
<li><p>ssc 就是当前的流环境上下文</p>
</li>
<li><p>locationStrategy <code>位置策略</code>,Saprk Streaming提供了三种，具体还在研究，分别是</p>
</li>
<li><ul>
<li><em>PreferConsistent</em>  它将在所有的 Executors 上均匀分配分区；</li>
<li><em>PreferBrokers</em>     当 Spark 的 Executor 与 Kafka Broker 在同一机器上时可以选择该选项，它优先将该 Broker 上的首领分区分配给该机器上的 Executor；</li>
<li><em>PreferFixed</em>       可以指定主题分区与特定主机的映射关系，显示地将分区分配到特定的主机</li>
</ul>
</li>
<li><p>consumerStrategy <code>消费者策略</code>，分为如下两种</p>
</li>
<li><ul>
<li><p>Subscribe[K,V]  		根据主题集合订阅</p>
<p>Subscribe有两个参数</p>
<p>​	<em>topic</em>             传入一个字符串集合           将订阅集合内所有的Topic</p>
<p>​	<em>kafkaParams</em>		Map[String,Object]        用于定义Kafka消费者的参数</p>
</li>
<li><p>SubscribePattern[K,V]   根据正则订阅</p>
<p>SubscribePattern也有两个参数</p>
<p>​	pattern			 java.util.regex.Pattern   正则表达式</p>
<p>​	<em>kafkaParams</em>		Map[String,Object]        用于定义Kafka消费者的参数</p>
</li>
</ul>
</li>
</ul>
<hr>

<p>监听到的流中的每个数据都是一个<code>ConsumerRecord[K, V]</code> 的实例，其中包含如下内容,通常我们只需要拿到值就行，如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="type">ConsumerRecord</span>(</span><br><span class="line">     topic = test,                                                <span class="comment">/*主题*/</span></span><br><span class="line">     partition = <span class="number">0</span>,                                               <span class="comment">/*分区号*/</span></span><br><span class="line">     offset = <span class="number">15</span>,                                                 <span class="comment">/*偏移量*/</span></span><br><span class="line">     <span class="type">CreateTime</span> = <span class="number">1666527833877</span>,                                  <span class="comment">/*消息创建的时间戳*/</span></span><br><span class="line">     serialized key size = <span class="number">-1</span>,                                    <span class="comment">/*键序列化器长度*/</span></span><br><span class="line">     serialized value size = <span class="number">5</span>,                                   <span class="comment">/*值序列化器长度*/</span></span><br><span class="line">     headers = <span class="type">RecordHeaders</span>(headers = [], isReadOnly = <span class="literal">false</span>),   <span class="comment">/*头部数据*/</span></span><br><span class="line">     key = <span class="literal">null</span>,                                                  <span class="comment">/*键*/</span></span><br><span class="line">     value = aaaaa                                                <span class="comment">/*值*/</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>来，我们简单实操一下</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.kafka.common.serialization.<span class="type">StringDeserializer</span></span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.<span class="type">Level</span>._</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.<span class="type">Logger</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.kafka010.<span class="type">KafkaUtils</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.kafka010.<span class="type">ConsumerStrategies</span>.<span class="type">Subscribe</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.kafka010.<span class="type">LocationStrategies</span>.<span class="type">PreferConsistent</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.&#123;<span class="type">Seconds</span>, <span class="type">StreamingContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//调下日志，看的不爽</span></span><br><span class="line">    <span class="type">Logger</span>.getLogger(<span class="string">&quot;org&quot;</span>).setLevel(<span class="type">ERROR</span>)</span><br><span class="line">    <span class="comment">//创建配置对象</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">    conf.setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">    conf.setAppName(<span class="string">&quot;Test01&quot;</span>)</span><br><span class="line">    <span class="comment">//Spark 出于性能的考虑，Spark2.0 开始支持另外一种 Kryo 序列化机制。速度约是Java自带的10 倍。</span></span><br><span class="line">    <span class="comment">//这里必须要指定序列化器，不然将会出现Kafka中的消息无法被序列化的情况</span></span><br><span class="line">    conf.set(<span class="string">&quot;spark.serializer&quot;</span>, <span class="string">&quot;org.apache.spark.serializer.KryoSerializer&quot;</span>)</span><br><span class="line">    <span class="comment">//创建Spark Streaming Context</span></span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf,<span class="type">Seconds</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义消费的Topic，支持多个，通过返回值中的topic属性区分</span></span><br><span class="line">    <span class="keyword">val</span> topics = <span class="type">Array</span>(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置Kafka消费者的属性</span></span><br><span class="line">    <span class="keyword">val</span> kafkaParams = <span class="type">Map</span>[<span class="type">String</span>,<span class="type">Object</span>] (</span><br><span class="line">      <span class="comment">//服务器地址</span></span><br><span class="line">      <span class="string">&quot;bootstrap.servers&quot;</span> -&gt; <span class="string">&quot;192.168.1.2:9092&quot;</span>,</span><br><span class="line">      <span class="comment">//Key的反序列化类</span></span><br><span class="line">      <span class="string">&quot;key.deserializer&quot;</span> -&gt; classOf[<span class="type">StringDeserializer</span>],</span><br><span class="line">      <span class="comment">//Value的反序列化类</span></span><br><span class="line">      <span class="string">&quot;value.deserializer&quot;</span> -&gt; classOf[<span class="type">StringDeserializer</span>],</span><br><span class="line">      <span class="comment">//消费者组ID</span></span><br><span class="line">      <span class="string">&quot;group.id&quot;</span> -&gt; <span class="string">&quot;1&quot;</span>,</span><br><span class="line">      <span class="comment">//不让Kafka自动提交偏移量，由Spark提交</span></span><br><span class="line">      <span class="string">&quot;enable.auto.commit&quot;</span> -&gt; (<span class="literal">false</span>:java.lang.<span class="type">Boolean</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建DStream</span></span><br><span class="line">    <span class="keyword">val</span> stream = <span class="type">KafkaUtils</span>.createDirectStream(</span><br><span class="line">      ssc,                                                 <span class="comment">//指定是流上下文</span></span><br><span class="line">      <span class="type">PreferConsistent</span>,                                    <span class="comment">//位置策略(详情看上面的理论)</span></span><br><span class="line">      <span class="type">Subscribe</span>[<span class="type">String</span>,<span class="type">String</span>](topics,kafkaParams)         <span class="comment">//消费者策略(详情看上面的理论)</span></span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">//刚刚的消息在value中，所以，我们要拿出value中的值进行下一步操作</span></span><br><span class="line">    <span class="comment">//剩下的，就是熟悉的计数操作</span></span><br><span class="line">    stream</span><br><span class="line">      .map(_.value)</span><br><span class="line">      .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      .map((_,<span class="number">1</span>))</span><br><span class="line">      .reduceByKey(_+_)</span><br><span class="line">      .print()</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">-------------------------------------------</span><br><span class="line"><span class="type">Time</span>: <span class="number">1666528560000</span> ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(aa,<span class="number">2</span>)</span><br><span class="line">(bb,<span class="number">1</span>)</span><br><span class="line">(cc,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h2><p>这里是特指因项目奇葩需求，需要直接使用Flume Sink到Spark 而不像常规的方法去依赖Kafka</p>
<p>不过官方已经<code>Spark2.3.0弃用了该方法</code>，我做实验用的2.1.1，还是可以再玩玩</p>
<p>让Flume直接Sink到Kafka有两种方式可以实现</p>
<p>准备让Flume去监听服务器端9999端口，然后通过两种sink尝试将数据下沉到Spark</p>
<h3 id="avro"><a href="#avro" class="headerlink" title="avro"></a>avro</h3><p>尝试过将多个Flume连接在一起的一定对他不陌生，该Sink是Flume原生自带的</p>
<p>先编写FLume配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">a1.sources</span> = <span class="string">r1</span></span><br><span class="line"><span class="attr">a1.channels</span> = <span class="string">c1</span></span><br><span class="line"><span class="attr">a1.sinks</span> = <span class="string">k1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">a1.sources.r1.type</span> = <span class="string">netcat</span></span><br><span class="line"><span class="attr">a1.sources.r1.bind</span> = <span class="string">master</span></span><br><span class="line"><span class="attr">a1.sources.r1.port</span> = <span class="string">9999</span></span><br><span class="line"><span class="attr">a1.sources.r1.channels</span> = <span class="string">c1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">a1.channels.c1.type</span> = <span class="string">memory</span></span><br><span class="line"></span><br><span class="line"><span class="attr">a1.sinks.k1.type</span> = <span class="string">avro</span></span><br><span class="line"><span class="attr">a1.sinks.k1.hostname</span> = <span class="string">192.168.159.136</span></span><br><span class="line"><span class="attr">a1.sinks.k1.port</span> = <span class="string">9998</span></span><br><span class="line"><span class="attr">a1.sinks.k1.channel</span> = <span class="string">c1</span></span><br></pre></td></tr></table></figure>



<p>导入环境</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spark 连接 flume--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-streaming-flume_$&#123;scala.version&#125;<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>直接使用</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> stream = <span class="type">FlumeUtils</span>.createStream(</span><br><span class="line">      ssc,</span><br><span class="line">      <span class="string">&quot;192.168.159.136&quot;</span>,        <span class="comment">//绑定avro的主机名</span></span><br><span class="line">      <span class="number">8888</span>                          <span class="comment">//端口</span></span><br><span class="line">    )</span><br><span class="line">      .map(d =&gt; <span class="keyword">new</span> <span class="type">String</span>(d.event.getBody.array()))</span><br><span class="line"></span><br><span class="line">stream</span><br><span class="line">  .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">  .map((_,<span class="number">1</span>))</span><br><span class="line">  .reduceByKey(_+_)</span><br><span class="line">  .print()</span><br></pre></td></tr></table></figure>

<h3 id="SparkSink"><a href="#SparkSink" class="headerlink" title="SparkSink"></a>SparkSink</h3><p>先放着，我还在研究</p>
<p>Flume安装路径下要放入对应依赖</p>
<p>sink的type &#x3D; org.apache.spark.streaming.flume.sink.SparkSink</p>
<h2 id="自定义输入源"><a href="#自定义输入源" class="headerlink" title="自定义输入源"></a>自定义输入源</h2><p>实现一个自定义数据源，需要实现一个Receiver类</p>
<p>直接来看源码比较直观，我把源码精简了下，想要往深处了解的可以直接翻源码，<code>源码建议小白好好看，不然不知道我接下来在干嘛</code></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传入一个存储级别，这属于RDD持久化的知识点，我有空整理下发</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span>[<span class="type">T</span>](<span class="params">val storageLevel: <span class="type">StorageLevel</span></span>) <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当Receiver启动时，系统会调用此方法。（需要实现）</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onStart</span></span>(): <span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//当Receiver停止时，系统调用此方法。在onStart()中设置的所有资源(线程、缓冲区等)必须在此方法中清除。 （需要实现）</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onStop</span></span>(): <span class="type">Unit</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 覆盖它以指定一个首选主机名</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">preferredLocation</span></span>: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将接受的数据聚合在一起，然后放入Spark的内存中</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">store</span></span>(dataItem: <span class="type">T</span>) &#123;</span><br><span class="line">    supervisor.pushSingle(dataItem)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//报告接收数据的异常。</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">reportError</span></span>(message: <span class="type">String</span>, throwable: <span class="type">Throwable</span>) &#123;</span><br><span class="line">    supervisor.reportError(message, throwable)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通过调用onStop()和onStart()重启Receiver，关闭与启动的间隔可在Spark配置文件Spark.streaming.receiverrestartdelay中定义</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">restart</span></span>(message: <span class="type">String</span>) &#123;</span><br><span class="line">    supervisor.restartReceiver(message)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 终止Receiver</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">stop</span></span>(message: <span class="type">String</span>) &#123;</span><br><span class="line">    supervisor.stop(message, <span class="type">None</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回Receiver是否启动</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isStarted</span></span>(): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    supervisor.isReceiverStarted()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回Receiver是否关闭</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isStopped</span></span>(): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    supervisor.isReceiverStopped()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回Receiver的输入流的ID</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">streamId</span></span>: <span class="type">Int</span> = id</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Identifier of the stream this receiver is associated with. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> id: <span class="type">Int</span> = <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Handler object that runs the receiver. This is instantiated lazily in the worker. */</span></span><br><span class="line">  <span class="meta">@transient</span> <span class="keyword">private</span> <span class="keyword">var</span> _supervisor: <span class="type">ReceiverSupervisor</span> = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Set the ID of the DStream that this receiver is associated with. */</span></span><br><span class="line">  <span class="keyword">private</span>[streaming] <span class="function"><span class="keyword">def</span> <span class="title">setReceiverId</span></span>(_id: <span class="type">Int</span>) &#123;</span><br><span class="line">    id = _id</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Attach Network Receiver executor to this receiver. */</span></span><br><span class="line">  <span class="keyword">private</span>[streaming] <span class="function"><span class="keyword">def</span> <span class="title">attachSupervisor</span></span>(exec: <span class="type">ReceiverSupervisor</span>) &#123;</span><br><span class="line">    assert(_supervisor == <span class="literal">null</span>)</span><br><span class="line">    _supervisor = exec</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Get the attached supervisor. */</span></span><br><span class="line">  <span class="keyword">private</span>[streaming] <span class="function"><span class="keyword">def</span> <span class="title">supervisor</span></span>: <span class="type">ReceiverSupervisor</span> = &#123;</span><br><span class="line">    assert(_supervisor != <span class="literal">null</span>,</span><br><span class="line">      <span class="string">&quot;A ReceiverSupervisor has not been attached to the receiver yet. Maybe you are starting &quot;</span> +</span><br><span class="line">        <span class="string">&quot;some computation in the receiver before the Receiver.onStart() has been called.&quot;</span>)</span><br><span class="line">    _supervisor</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来，实操，自定义一个Receiver用于监听套接字</p>
<p>我们需要实现其中的onStart()与onStop()方法</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.<span class="type">Level</span>._</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.<span class="type">Logger</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.storage.<span class="type">StorageLevel</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.receiver.<span class="type">Receiver</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.&#123;<span class="type">Seconds</span>, <span class="type">StreamingContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.&#123;<span class="type">BufferedReader</span>, <span class="type">InputStreamReader</span>&#125;</span><br><span class="line"><span class="keyword">import</span> java.net.<span class="type">Socket</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//调下日志，看的不舒服</span></span><br><span class="line">    <span class="type">Logger</span>.getLogger(<span class="string">&quot;org&quot;</span>).setLevel(<span class="type">ERROR</span>)</span><br><span class="line">    <span class="comment">//创建配置对象</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">    conf.setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">    conf.setAppName(<span class="string">&quot;Test01&quot;</span>)</span><br><span class="line">    <span class="comment">//创建Spark Streaming Context</span></span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf,<span class="type">Seconds</span>(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stream = ssc             <span class="comment">//直接传入实例化对象</span></span><br><span class="line">      .receiverStream(<span class="keyword">new</span> <span class="type">MySocketReceiver</span>(<span class="string">&quot;192.168.159.136&quot;</span>,<span class="number">9999</span>))</span><br><span class="line"></span><br><span class="line">    stream</span><br><span class="line">      .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      .map((_,<span class="number">1</span>))</span><br><span class="line">      .reduceByKey(_+_)</span><br><span class="line">      .print()</span><br><span class="line">    </span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义Receiver</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySocketReceiver</span>(<span class="params">host:<span class="type">String</span>,port:<span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Receiver</span>[<span class="type">String</span>](<span class="params"><span class="type">StorageLevel</span>.<span class="type">MEMORY_ONLY</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//先定义一个方法，用于连接Socket并接收数据</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">receiver</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">    <span class="keyword">var</span> socket:<span class="type">Socket</span> = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">var</span> input:<span class="type">String</span> = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      socket = <span class="keyword">new</span> <span class="type">Socket</span>(host,port)</span><br><span class="line">      <span class="comment">//读数据</span></span><br><span class="line">      <span class="keyword">val</span> reader = <span class="keyword">new</span> <span class="type">BufferedReader</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="type">InputStreamReader</span>(socket.getInputStream,<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">      )</span><br><span class="line">      input = reader.readLine()</span><br><span class="line">      <span class="keyword">while</span> (isStarted &amp;&amp; input != <span class="literal">null</span>)&#123;     <span class="comment">//Receiver启动且输入非空</span></span><br><span class="line">        store(input)               <span class="comment">//放入Spark的内存中</span></span><br><span class="line">        input = reader.readLine()  <span class="comment">//下一条</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//释放资源</span></span><br><span class="line">      reader.close()</span><br><span class="line">      socket.close()</span><br><span class="line">      <span class="comment">//重启Receiver，在套接字服务器再次启动时还能继续连接</span></span><br><span class="line">      restart(<span class="string">&quot;Try connect again and restart receiver...&quot;</span>)</span><br><span class="line">    &#125;<span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="comment">//连接异常</span></span><br><span class="line">      <span class="keyword">case</span> ex1:java.net.<span class="type">ConnectException</span> =&gt; &#123;</span><br><span class="line">        <span class="comment">//尝试重新连接</span></span><br><span class="line">        restart(<span class="string">&quot;As error occurred while connecting to [%s:%d] ,Try connect again now...&quot;</span>.format(host,port))</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="comment">//未知异常，停止Receiver</span></span><br><span class="line">      <span class="keyword">case</span> ex02:<span class="type">Exception</span> =&gt; &#123;</span><br><span class="line">        stop(<span class="string">&quot;Unknown error,receiver stopped...&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onStart</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">//定义一个线程，帮我开启刚刚写的连接器</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">Thread</span>(<span class="string">&quot;Socket Receiver&quot;</span>)&#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">        receiver()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.start()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onStop</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">Logger</span>.getRootLogger.info(<span class="string">&quot;Receiver Stopped Now...&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">-------------------------------------------</span><br><span class="line"><span class="type">Time</span>: <span class="number">1666593630000</span> ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(bbb,<span class="number">1</span>)</span><br><span class="line">(ddd,<span class="number">1</span>)</span><br><span class="line">(ccc,<span class="number">1</span>)</span><br><span class="line">(aaa,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>我个人将数据转换、窗口计算，合并至操作中</p>
<h2 id="转换操作"><a href="#转换操作" class="headerlink" title="转换操作"></a>转换操作</h2><p>使用起来和RDD算子类似，我不多赘述,</p>
<table>
<thead>
<tr>
<th>转换</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td>map(<em>func</em>)</td>
<td>通过函数<em>func</em>传递源DStream的每个元素，返回一个新的DStream。</td>
</tr>
<tr>
<td>flatMap(<em>func</em>)</td>
<td>类似于map，但是每个输入项都可以映射到0个或多个输出项。</td>
</tr>
<tr>
<td>filter(<em>func</em>)</td>
<td>通过<em>func</em>的返回，保留true的记录，返回一个新的DStream。</td>
</tr>
<tr>
<td>repartition(<em>numPartitions</em>)</td>
<td>通过创建更多或更少的分区来改变此DStream中的并行级别。</td>
</tr>
<tr>
<td>union(<em>otherStream</em>)</td>
<td>返回一个新的DStream，其中包含源DStream和<em>otherDStream</em>中的元素的并集。</td>
</tr>
<tr>
<td>count()</td>
<td>通过计算源DStream的每个RDD中的元素数量，返回一个单元素RDD的新DStream。</td>
</tr>
<tr>
<td>reduce(<em>func</em>)</td>
<td>通过使用函数<em>func</em>(接受两个参数并返回一个参数)聚合源DStream的每个RDD中的元素，返回一个由单元素RDD组成的新DStream。函数应该是结合律和交换律，这样才能并行计算。</td>
</tr>
<tr>
<td>countByValue()</td>
<td>当对类型为K的元素的DStream调用时，返回一个由(K, Long)对组成的新DStream，其中每个键的值是它在源DStream的每个RDD中的频率。</td>
</tr>
<tr>
<td>reduceByKey(<em>func</em>, [<em>numTasks</em>])</td>
<td>当在(K, V)对DStream上调用时，返回一个新的(K, V)对DStream，其中每个键的值使用给定的reduce函数聚合。**注意:**默认情况下，这使用Spark的默认并行任务数(本地模式为2，集群模式下由配置属性’ Spark .default.parallelism ‘决定)来进行分组。你可以通过一个可选的<code>numTasks</code>参数来设置不同数量的任务。</td>
</tr>
<tr>
<td>join(<em>otherStream</em>, [<em>numTasks</em>])</td>
<td>当调用两个(K, V)和(K, W)对的DStream时，返回一个新的(K， (V, W))对的DStream，其中包含每个键的所有元素对。</td>
</tr>
<tr>
<td>cogroup(<em>otherStream</em>, [<em>numTasks</em>])</td>
<td>当调用(K, V)和(K, W)对的DStream时，返回一个新的(K, Seq[V]， Seq[W])元组的DStream。</td>
</tr>
<tr>
<td>transform(<em>func</em>)</td>
<td>通过对源DStream的每个RDD应用RDD-to-RDD函数，返回一个新的DStream。这可以用于在DStream上执行任意的RDD操作。</td>
</tr>
<tr>
<td>updateStateByKey(<em>func</em>)</td>
<td>返回一个带新的“状态”的DStream，其中每个键的状态通过在键的前一个状态和键的新值上应用给定函数来更新。这可用于维护每个键的任意状态数据。</td>
</tr>
</tbody></table>
<blockquote>
<p>这里面有个特别的算子[updateStateByKey]</p>
<p>其他算子都仅计算当前微批的数据，这类算子被称为<code>无状态算子</code></p>
<p>updateStateByKey在计算是会保留key的状态，下次计算会根据前一次的key继续转换，这被成为<code>有状态算子</code></p>
</blockquote>
<h2 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h2><p>Spark仅支持滑动窗口(滚动是特殊的滑动)</p>
<p><img data-src="/../image/Spark%E6%B5%81%E8%AE%A1%E7%AE%97/%E7%AA%97%E5%8F%A3%E6%93%8D%E4%BD%9C.png" alt="窗口操作"></p>
<p>Spark的开窗与Flink不一样，Spark开窗前后的数据类型不变，只是将DStream中的各个窗口的RDD集合成一个新的RDD，Spark的开窗也是直接将开窗与转换的动作合并到一个算子</p>
<table>
<thead>
<tr>
<th>转换</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>window(<em>windowLength</em>, <em>slideInterval</em>)</td>
<td>返回一个基于源DStream的窗口批次计算后得到新的DStream。(单纯的RDD合并)</td>
</tr>
<tr>
<td>countByWindow(<em>windowLength</em>,<em>slideInterval</em>)</td>
<td>返回基于滑动窗口的DStream中的元素的数量。</td>
</tr>
<tr>
<td>reduceByWindow(<em>func</em>, <em>windowLength</em>,<em>slideInterval</em>)</td>
<td>基于滑动窗口对源DStream中的元素进行聚合操作，得到一个新的DStream。</td>
</tr>
<tr>
<td>reduceByKeyAndWindow(<em>func</em>,<em>windowLength</em>,<em>slideInterval</em>, [<em>numTasks</em>])</td>
<td>基于滑动窗口对（K，V）键值对类型的DStream中的值按K使用聚合函数func进行聚合操作，得到一个新的DStream。</td>
</tr>
<tr>
<td>reduceByKeyAndWindow(<em>func</em>,<em>invFunc</em>,<em>windowLength</em>, <em>slideInterval</em>, [<em>numTasks</em>])</td>
<td>一个更高效的reduceByKeyAndWindow()的实现版本，先对滑动窗口中新的时间间隔内数据增量聚合并移去最早的与新增数据量的时间间隔内的数据统计量。例如，计算t+4秒这个时刻过去5秒窗口的WordCount，那么我们可以将t+3时刻过去5秒的统计量加上[t+3，t+4]的统计量，在减去[t-2，t-1]的统计量，这种方法可以复用中间三秒的统计量，提高统计的效率。</td>
</tr>
<tr>
<td>countByValueAndWindow(<em>windowLength</em>,<em>slideInterval</em>, [<em>numTasks</em>])</td>
<td>基于滑动窗口计算源DStream中每个RDD内每个元素出现的频次并返回DStream[(K,Long)]，其中K是RDD中元素的类型，Long是元素频次。与countByValue一样，reduce任务的数量可以通过一个可选参数进行配置。</td>
</tr>
</tbody></table>
<blockquote>
<p>由于Spark Streaming天生微批的特性，所以，定义窗口长度(windowLength)与窗口间隔(slideInterval)时，<code>必须是微批时间间隔的倍数</code></p>
<p>一般我习惯将微批间隔调偏小。可以方便我开窗，也能提升计算的时效性，不过这也不是百利无害，过度缩小微批间隔会导致应用程序的吞吐量下降</p>
</blockquote>
<p>实操一下，用窗口每隔5秒统计最经15秒的数据，对数据进行词频统计</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.<span class="type">Level</span>._</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.<span class="type">Logger</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.&#123;<span class="type">Seconds</span>, <span class="type">StreamingContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">Logger</span>.getLogger(<span class="string">&quot;org&quot;</span>).setLevel(<span class="type">ERROR</span>)</span><br><span class="line">    <span class="comment">//创建配置对象</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">    conf.setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">    conf.setAppName(<span class="string">&quot;Test01&quot;</span>)</span><br><span class="line">    <span class="comment">//创建Spark Streaming Context</span></span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf,<span class="type">Seconds</span>(<span class="number">5</span>))    <span class="comment">//取最大公因数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stream = ssc.socketTextStream(<span class="string">&quot;192.168.159.136&quot;</span>,<span class="number">9999</span>)</span><br><span class="line"></span><br><span class="line">    stream</span><br><span class="line">      .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      .map((_,<span class="number">1</span>))</span><br><span class="line">      .groupByKeyAndWindow(<span class="type">Seconds</span>(<span class="number">15</span>),<span class="type">Seconds</span>(<span class="number">5</span>))    <span class="comment">//又ByKey 又ByWindow</span></span><br><span class="line">      .map(d =&gt; (d._1,d._2.sum))        <span class="comment">//(aa,ArrayBuffer(1, 1, 1, 1))  =&gt; (aa,4)</span></span><br><span class="line">      .print()</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">-------------------------------------------</span><br><span class="line"><span class="type">Time</span>: <span class="number">1666596635000</span> ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(cc,<span class="number">1</span>)</span><br><span class="line">(bb,<span class="number">1</span>)</span><br><span class="line">(aa,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="type">Time</span>: <span class="number">1666596640000</span> ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(cc,<span class="number">1</span>)</span><br><span class="line">(bb,<span class="number">1</span>)</span><br><span class="line">(aa,<span class="number">3</span>)</span><br><span class="line">(dd,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="type">Time</span>: <span class="number">1666596645000</span> ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(ff,<span class="number">1</span>)</span><br><span class="line">(cc,<span class="number">1</span>)</span><br><span class="line">(ee,<span class="number">1</span>)</span><br><span class="line">(bb,<span class="number">1</span>)</span><br><span class="line">(aa,<span class="number">6</span>)</span><br><span class="line">(gg,<span class="number">1</span>)</span><br><span class="line">(dd,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="type">Time</span>: <span class="number">1666596650000</span> ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(ff,<span class="number">1</span>)</span><br><span class="line">(ee,<span class="number">1</span>)</span><br><span class="line">(aa,<span class="number">4</span>)</span><br><span class="line">(gg,<span class="number">1</span>)</span><br><span class="line">(dd,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">-------------------------------------------</span><br><span class="line"><span class="type">Time</span>: <span class="number">1666596655000</span> ms</span><br><span class="line">-------------------------------------------</span><br><span class="line">(ff,<span class="number">1</span>)</span><br><span class="line">(ee,<span class="number">1</span>)</span><br><span class="line">(aa,<span class="number">3</span>)</span><br><span class="line">(gg,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>话说，有没有哪个小天才求出我这几秒的输入内容</p>
<h3 id="事件时间窗口"><a href="#事件时间窗口" class="headerlink" title="事件时间窗口"></a>事件时间窗口</h3><p>上面演示的是基于处理时间段窗口</p>
<p>在处理事件时间前，先快速了解些概念</p>
<hr>

<p>三大时间语义</p>
<p><img data-src="/../image/Spark%E6%B5%81%E8%AE%A1%E7%AE%97/%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89.png" alt="时间语义"></p>
<p>例如你在打网络游戏，当你按下技能键时，这个时间就是事件时间，而当这个指令传输到服务器时就是进入时间，服务器处理这个命令的时间就是处理时间，在代码中，往往更加关系事件时间。</p>
<hr>

<p><a href="https://spark.apache.org/docs/2.4.5/structured-streaming-programming-guide.html#window-operations-on-event-time">官方文档</a></p>
<p>使用起来也简单，官方解释说因为这种窗口和分组相似，所以我们可以使用<em>Spark SQL API</em>的*groupBy()<em>结合</em>window()*实现</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> spark.implicits._</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> words = ... <span class="comment">// 流数据的Schema &#123; timestamp: Timestamp, word: String &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将数据按窗口和单词分组，并计算每组的计数</span></span><br><span class="line"><span class="keyword">val</span> windowedCounts = words.groupBy(</span><br><span class="line">  window($<span class="string">&quot;timestamp&quot;</span>, <span class="string">&quot;10 minutes&quot;</span>, <span class="string">&quot;5 minutes&quot;</span>),</span><br><span class="line">  $<span class="string">&quot;word&quot;</span></span><br><span class="line">).count()</span><br></pre></td></tr></table></figure>

<h2 id="输出操作"><a href="#输出操作" class="headerlink" title="输出操作"></a>输出操作</h2><p>类似RDD，DStream也可输出到外部系统</p>
<table>
<thead>
<tr>
<th>输出选项</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>print()</td>
<td>在运行流应用程序的驱动节点上打印DStream中每批数据的前十个元素。官方认为这对于开发和调试非常有用。<br><em>Python API中不可用</em></td>
</tr>
<tr>
<td>saveAsTextFiles(<em>prefix</em>, [<em>suffix</em>])</td>
<td>将此DStream的内容保存为文本文件</td>
</tr>
<tr>
<td>saveAsObjectFiles(<em>prefix</em>, [<em>suffix</em>])</td>
<td>将这个DStream的内容保存为序列化Java对象的<code>SequenceFiles</code>。<br><em>Python API中不可用</em></td>
</tr>
<tr>
<td>saveAsHadoopFiles(<em>prefix</em>, [<em>suffix</em>])</td>
<td>将这个DStream的内容保存为Hadoop文件。<br><em>Python API中不可用</em></td>
</tr>
<tr>
<td>foreachRDD(<em>func</em>)</td>
<td>通用的输出操作，将<em>func</em>用于于DStream中所有的RDD。该功能应将每个RDD中的数据推入外部系统，例如将RDD保存到文件中，或通过网络将其写入数据库。注意，函数<em>func</em>是在运行流应用程序的驱动进程中执行的</td>
</tr>
</tbody></table>
<p>前面好几个例子中用到的print()就是一个简单的输出操作</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">ssc</span><br><span class="line">	.socketTextStream(<span class="string">&quot;192.168.159.136&quot;</span>,<span class="number">9999</span>)</span><br><span class="line">	.print()</span><br></pre></td></tr></table></figure>



<p>官方认为foreachRDD(<em>func</em>)是一个非常强大的算子，如何正确且有效的使用它非常重要</p>
<p>原句，不是我瞎说</p>
<p><code>dstream.foreachRDD</code> is a powerful primitive that allows data to be sent out to external systems. However, it is important to understand how to use this primitive correctly and efficiently</p>
<p>所以让我们看一遍官方的案例</p>
<p>通常，向外部系统写入数据通常需要创建一个连接对象(例如，到远程服务器的TCP连接)，并使用它向远程系统发送数据。为此，开发人员可能会无意中尝试在Spark driver中创建一个连接对象，然后尝试在Spark worker中使用它来保存rdd中的记录。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">dstream.foreachRDD &#123; rdd =&gt;</span><br><span class="line">  <span class="keyword">val</span> connection = createNewConnection()  <span class="comment">// driver段创建连接对象</span></span><br><span class="line">  rdd.foreach &#123; record =&gt;</span><br><span class="line">    connection.send(record) <span class="comment">// worker端使用连接对象保存数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是不正确的，因为这需要连接对象被序列化，并从driver端发送到worker端。这样的连接对象很少可以跨机器转移。所以可能会出现序列化错误(连接对象不可序列化)、初始化错误(连接对象需要在工作者处初始化)等。正确的解决方案是在工作者处创建连接对象。</p>
<p>然而，这可能会导致另一个常见的错误——为每条记录创建一个新连接，如下</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">dstream.foreachRDD &#123; rdd =&gt;</span><br><span class="line">  rdd.foreach &#123; record =&gt;</span><br><span class="line">    <span class="keyword">val</span> connection = createNewConnection()   <span class="comment">// driver段创建连接对象</span></span><br><span class="line">    connection.send(record)     <span class="comment">// worker端使用连接对象保存数据</span></span><br><span class="line">    connection.close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建连接对象需要花费时间和资源。因此，为每个记录创建和销毁一个连接对象可能会产生不必要的高开销，并会显著降低系统的总体吞吐量。更好的解决方案是使用<em>rdd.foreachPartition</em>创建一个连接对象，并使用该连接发送RDD分区中的所有记录。如下：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">dstream.foreachRDD &#123; rdd =&gt;</span><br><span class="line">  rdd.foreachPartition &#123; partitionOfRecords =&gt;</span><br><span class="line">    <span class="keyword">val</span> connection = createNewConnection()</span><br><span class="line">    partitionOfRecords.foreach(record =&gt; connection.send(record))</span><br><span class="line">    connection.close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这将在许多记录上分摊创建连接的开销。</p>
<p>最后，可以通过跨多个rdd&#x2F;批重用连接对象来进一步优化。可以维护一个静态的连接对象池，当多个批的rdd被推到外部系统时，可以重用该连接对象池，从而进一步减少开销。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">dstream.foreachRDD &#123; rdd =&gt;</span><br><span class="line">  rdd.foreachPartition &#123; partitionOfRecords =&gt;</span><br><span class="line">    <span class="comment">// ConnectionPool是一个静态的、惰性初始化的连接池</span></span><br><span class="line">    <span class="keyword">val</span> connection = <span class="type">ConnectionPool</span>.getConnection()</span><br><span class="line">    partitionOfRecords.foreach(record =&gt; connection.send(record))</span><br><span class="line">    <span class="type">ConnectionPool</span>.returnConnection(connection)  <span class="comment">// 返回到池中以便将来重用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，池中的连接应该按需惰性创建，如果一段时间不使用，则会超时。这实现了将数据最有效地发送到外部系统。</p>
<h1 id="DStream-持久化"><a href="#DStream-持久化" class="headerlink" title="DStream 持久化"></a>DStream 持久化</h1><p>DStream与RDD一样，也允许开发人员将其数据(里面的所有RDD)持久化</p>
<p>方法也很简单，只需要使用persist()方法就行</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> stream = ssc.socketTextStream(<span class="string">&quot;master&quot;</span>,<span class="number">9999</span>)</span><br><span class="line">  .persist(</span><br><span class="line">    <span class="type">StorageLevel</span>.<span class="type">MEMORY_ONLY</span>    <span class="comment">//我们可以在此定义持久化的存储级别，默认将数据持久化到内存</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>在涉及<code>开窗</code>以及<code>有状态</code>操作后，Spark Streaming会<code>自动执行</code>persist</p>
<h1 id="DStream-检测点"><a href="#DStream-检测点" class="headerlink" title="DStream 检测点"></a>DStream 检测点</h1><p>Spark Streaming应用程序通常7*24小时持续运行，一下非应用程序开发逻辑导致的错误(例如系统故障，JVM故障)不应该影响应用程序的运行</p>
<p>这时检查点机制就很重要，就先游戏中的检查点，它会记录当前的状态，保存到容错系统中，以便随时恢复某一时间段状态</p>
<ul>
<li>元数据检查点</li>
</ul>
<p>​	将定义流计算的信息保存到HDFS等容错存储中。这用于从运行流应用程序驱动程序的节点的故障中恢复(稍后将详细讨论)。元数据包括:</p>
<p>​	- 应用程序配置  ——&gt;    用于创建流应用程序的配置。</p>
<p>​	- DStream操作  ——&gt;   定义流应用程序的DStream操作集。</p>
<p>​	- 未完成批次    ——&gt;   在排队中但尚未完成的作业批次。</p>
<ul>
<li>数据检查点</li>
</ul>
<p>将生成的RDD保存到可靠的存储中。</p>
<p>这在一些跨多个批组合数据的有状态转换中是必要的。在这样的转换中，生成的RDD依赖于前一批的RDD，这导致依赖链的长度随着时间不断增加。为了避免恢复时间的无限增加，有状态转换的中间RDD会定期设置检查点到可靠的存储(如HDFS)，以切断依赖链。</p>
<hr>

<p>在以下场景必须要启用检查点:</p>
<ul>
<li>在计算过程中有涉及有状态转换：<ul>
<li>如果在应用程序中使用了<em>updateStateByKey</em>或<em>reduceByKeyAndWindow</em>(有状态算子)，那么必须提供检查点目录以允许定期的RDD检查点。</li>
<li>从运行应用程序的Driver故障中恢复，使用元数据检查点来海恢复进度信息。</li>
</ul>
</li>
</ul>
<p>若你的应用程序未涉及有状态计算，可以允许一些被接受但未被处理的数据丢失，那可以不用配置检查点</p>
<h2 id="如何配置检查点"><a href="#如何配置检查点" class="headerlink" title="如何配置检查点"></a>如何配置检查点</h2><p>我们可以通过*streamingContext.checkpoint(一个路径:String)*启用检查点，通常来说，检查点放在一个容错、可靠的文件系统(如HDFS)中</p>
<p>用官方案例改改</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.log4j.<span class="type">Level</span>._</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.<span class="type">Logger</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">SparkConf</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.streaming.&#123;<span class="type">Seconds</span>, <span class="type">StreamingContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test01</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">Logger</span>.getLogger(<span class="string">&quot;org&quot;</span>).setLevel(<span class="type">ERROR</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到SparkStreamingContext</span></span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="type">StreamingContext</span></span><br><span class="line">      .getOrCreate(</span><br><span class="line">        <span class="keyword">this</span>.checkpointPath,</span><br><span class="line">        createContext _         <span class="comment">//比较坑，只能吃() =&gt; StreamingContext</span></span><br><span class="line">      )           <span class="comment">//从创建函数获取</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> stream = ssc.socketTextStream(<span class="string">&quot;master&quot;</span>,<span class="number">9999</span>)</span><br><span class="line">    stream</span><br><span class="line">      .flatMap(_.split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">      .map((_,<span class="number">1</span>))</span><br><span class="line">      .reduceByKey(_+_)</span><br><span class="line">      .print()</span><br><span class="line"></span><br><span class="line">    ssc.start()</span><br><span class="line">    ssc.awaitTermination()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//检查点路径</span></span><br><span class="line">  <span class="keyword">val</span> checkpointPath = <span class="string">&quot;hdfs://master:9999/sparkCheckpoint&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//定义个函数，用于从检查点获取SparkStreamingContext</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">createContext</span></span>(): <span class="type">StreamingContext</span> = &#123;</span><br><span class="line">    <span class="comment">//创建配置对象</span></span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>()</span><br><span class="line">    conf.setMaster(<span class="string">&quot;local[*]&quot;</span>)</span><br><span class="line">    conf.setAppName(<span class="string">&quot;Test01&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Spark Streaming Context</span></span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="keyword">new</span> <span class="type">StreamingContext</span>(conf,<span class="type">Seconds</span>(<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过流上下文设置检查点，将其储存在HDFS</span></span><br><span class="line">    ssc.checkpoint(<span class="keyword">this</span>.checkpointPath)</span><br><span class="line"></span><br><span class="line">    ssc</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记分享</category>
      </categories>
      <tags>
        <tag>Spark</tag>
        <tag>Spark Streaming</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机在开机时发生了什么</title>
    <url>/article/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9C%A8%E5%BC%80%E6%9C%BA%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<blockquote>
<p>本章内容涉及较深，自认为我比较菜，可能我的描述有误，望指出，感谢</p>
</blockquote>
<p>这篇笔记的目的很简单，每次装系统的时候都会遇到类似于UEFI、BootLoader这种词，很好奇，干脆去研究下。</p>
<h1 id="计算机启动过程"><a href="#计算机启动过程" class="headerlink" title="计算机启动过程"></a>计算机启动过程</h1><p>计算机的启动过程大致可以分为以下4个阶段：</p>
<ul>
<li><p><a href="#%E4%B8%8A%E7%94%B5">上电</a></p>
<p>接通电源，主板上电，CPU的RESET引脚会产生一个逻辑值来复位CPU, CPU唤醒后, CPU将执行一跳转指令, 跳转到BIOS。</p>
</li>
<li><p><a href="#BIOS%E8%87%AA%E6%A3%80">BIOS自检</a></p>
<p>BIOS程序对系统关键硬件进行自检，这个其中包括CPU、内存、存储介质等等….硬件自检不通过则无法启动系统，若硬件自检通过则开始查找系统中的引导设备。</p>
</li>
<li><p><a href="#%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC">系统引导</a></p>
<p>BIOS将引导代码复制到内存中，BIOS退出，将控制权交由刚刚加载到内存中的引导代码，也就是<a href="https://baike.baidu.com/item/BootLoader/8733520?fr=ge_ala">BootLoader</a>,BootLoader将负责操作系统的加载以及启动的动作</p>
</li>
<li><p><a href="#BIOS%E8%87%AA%E6%A3%80%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96">操作系统初始化</a></p>
<p>操作系统系启动，控制权交由操作系统，内核载入内存，并开始各模块初始化工作</p>
</li>
</ul>
<p><em><span id="more"></span></em></p>
<h1 id="上电"><a href="#上电" class="headerlink" title="上电"></a>上电</h1><h2 id="RTC"><a href="#RTC" class="headerlink" title="RTC"></a>RTC</h2><p>RTC(Real_Time Clock)，称为 实时时钟，通常家用电脑由一块CR-2032电池供电，RTC主要为确保主板处于G3(AC掉电)状态下，时钟的准确性，具体实现非本节重点。</p>
<h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><p>电源主要是将市电转换为计算机内部所使用的5V、12V、24V的电源的一种硬件设备，常见的家用计算机电源为ATX电源，通常安装于机箱角落。</p>
<p>ATX电源需与主板相连，通常为20Pin&#x2F;24Pin的引脚，如下</p>
<p><img data-src="/../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9C%A8%E5%BC%80%E6%9C%BA%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/atx%E5%BC%95%E8%84%9A.png" alt="atx引脚"></p>
<p>24Pin针脚定义如下：</p>
<table>
<thead>
<tr>
<th>引脚编号</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>3.3V</td>
<td>提供 +3.3V 电源</td>
</tr>
<tr>
<td>2</td>
<td>3.3V</td>
<td>提供 +3.3V 电源</td>
</tr>
<tr>
<td>3</td>
<td>GND</td>
<td>地线</td>
</tr>
<tr>
<td>4</td>
<td>+5V</td>
<td>提供 +5V 电源</td>
</tr>
<tr>
<td>5</td>
<td>GND</td>
<td>地线</td>
</tr>
<tr>
<td>6</td>
<td>+5V</td>
<td>提供 +5V 电源</td>
</tr>
<tr>
<td>7</td>
<td>GND</td>
<td>地线</td>
</tr>
<tr>
<td>8</td>
<td>Power Good</td>
<td>Power OK，指示电源正常工作</td>
</tr>
<tr>
<td>9</td>
<td>5V SB(stand by +5V)</td>
<td>提供 +5V Stand by电源，供电源启动电路用</td>
</tr>
<tr>
<td>10</td>
<td>+12V</td>
<td>提供 +12V 电源</td>
</tr>
<tr>
<td>11</td>
<td>+12V (Only for 2x12-pin ATX)</td>
<td>提供 +12V电源</td>
</tr>
<tr>
<td>12</td>
<td>3.3V (Only for 2x12-pin ATX)</td>
<td>2*12连接器侦察</td>
</tr>
<tr>
<td>13</td>
<td>3.3V</td>
<td>提供 3.3V 电源</td>
</tr>
<tr>
<td>14</td>
<td>-12V</td>
<td>提供 -12V 电源</td>
</tr>
<tr>
<td>15</td>
<td>GND</td>
<td>地线</td>
</tr>
<tr>
<td>16</td>
<td>PS_ON(soft On&#x2F;Off)</td>
<td>PS-ON（电源供应远程开关）</td>
</tr>
<tr>
<td>17</td>
<td>GND</td>
<td>地线</td>
</tr>
<tr>
<td>18</td>
<td>GND</td>
<td>地线</td>
</tr>
<tr>
<td>19</td>
<td>GND</td>
<td>地线</td>
</tr>
<tr>
<td>20</td>
<td>-5V</td>
<td>提供 -5V 电源</td>
</tr>
<tr>
<td>21</td>
<td>+5V</td>
<td>提供 +5V 电源</td>
</tr>
<tr>
<td>22</td>
<td>+5V</td>
<td>提供 +5V 电源</td>
</tr>
<tr>
<td>23</td>
<td>+5V (Only for 2x12-pin ATX)</td>
<td>提供 +5V 电源</td>
</tr>
<tr>
<td>24</td>
<td>GND (Only for 2x12-pin ATX)</td>
<td>地线</td>
</tr>
</tbody></table>
<p>20Pin针脚定义如下：</p>
<table>
<thead>
<tr>
<th>引脚编号</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>3.3V</td>
<td>提供 +3.3V 电源</td>
</tr>
<tr>
<td>2</td>
<td>3.3V</td>
<td>提供 +3.3V 电源</td>
</tr>
<tr>
<td>3</td>
<td>GND</td>
<td>地线</td>
</tr>
<tr>
<td>4</td>
<td>5V</td>
<td>提供 +5V 电源</td>
</tr>
<tr>
<td>5</td>
<td>GND</td>
<td>地线</td>
</tr>
<tr>
<td>6</td>
<td>5V</td>
<td>提供 +5V 电源</td>
</tr>
<tr>
<td>7</td>
<td>GND</td>
<td>地线</td>
</tr>
<tr>
<td>8</td>
<td>PW-OK</td>
<td>Power OK，指示电源正常工作</td>
</tr>
<tr>
<td>9</td>
<td>5VSB</td>
<td>提供 +5V Stand by电源，供电源启动电路用</td>
</tr>
<tr>
<td>10</td>
<td>12V</td>
<td>提供 +12V 电源</td>
</tr>
<tr>
<td>11</td>
<td>3.3V</td>
<td>提供 +3.3V 电源</td>
</tr>
<tr>
<td>12</td>
<td>-12V</td>
<td>提供 -12V 电源</td>
</tr>
<tr>
<td>13</td>
<td>GND</td>
<td>地线</td>
</tr>
<tr>
<td>14</td>
<td>PS-ON</td>
<td>电源启动信号，低电平-电源开启，高电平-电源关闭</td>
</tr>
<tr>
<td>15</td>
<td>GND</td>
<td>地线</td>
</tr>
<tr>
<td>16</td>
<td>GND</td>
<td>地线</td>
</tr>
<tr>
<td>17</td>
<td>GND</td>
<td>地线</td>
</tr>
<tr>
<td>18</td>
<td>-5V</td>
<td>提供 -5V 电源</td>
</tr>
<tr>
<td>19</td>
<td>5V</td>
<td>提供 +5V 电源</td>
</tr>
<tr>
<td>20</td>
<td>5V</td>
<td>提供 +5V 电源</td>
</tr>
</tbody></table>
<p>根据定义，在电源接市电时，9脚+5VSB向主板供电，此时主板处于G2_S5状态(也就是俗称的关机状态)，EC(嵌入式主控)评估电源可靠性，通过则向南桥发送PM_RSMRST#信号，南桥复位，向启动电路、<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E5%94%A4%E9%86%92/6911574?fr=ge_ala">WOL</a>(Wake-up On Lan)等供电，此时电源PS_ON#电平置高。</p>
<blockquote>
<p>虽然此时COU等硬件未供电，且并未开机，但在对计算机硬件进行操作时，请务必断开市电并释放主板残留电量。</p>
</blockquote>
<p>用户按下电源键(或是其他方式),PS-ON#电平被拉低，相当于主板通知电源我要启动了，此时针脚+12VDC、+5VDC、+3.3VDC、-12VDC开始为主板供电，+5VSB保持原状。</p>
<p>如果一切顺利，电源将拉高8脚(Power Good &#x2F; Power OK)电平，通知主板电源稳定，这时会撤销CPU的复位信号(下面细说)。</p>
<h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><blockquote>
<p>硬件我是小白，以下是常见的流程，具体流程因各主板设计差异会有所出入。</p>
</blockquote>
<p>主板 -&gt; 一块拥有计算机主要电路以及硬件的电路板</p>
<h3 id="EC"><a href="#EC" class="headerlink" title="EC"></a>EC</h3><p>EC(Embedded Controller)即嵌入式控制器，是挂在CPU的<a href="https://baike.baidu.com/item/LPC%E6%80%BB%E7%BA%BF/4179319?fr=ge_ala">LPC</a>（Low Pin Count）总线下的一颗嵌入主控芯片，主要作用是控制计算机主板上下电时序、管理电池充放电，提供键盘矩阵接口、智能风扇接口、串口、GPIO、PS&#x2F;2等常规IO功能。</p>
<p>下列对刚刚主板与电源的交互进行补充：</p>
<p>在进入S5状态时，用户按下电源按钮后，PWR_SW#信号将被拉低，EC收到拉低的PWR_SW#后通过拉低PM_PWRBTN#信号通知南桥下达开机指令，南桥收到指令后，拉高SLP_S5#(退出S5(关机)状态)、SLP_S4#(退出S4(休眠)状态)、SLP_S3#(退出S3(睡眠)状态)电平并通知EC</p>
<p>再此同时应该还有一些硬件的检测</p>
<p>EC收到由其他硬件返回的特定信号后，代表当前电源初始化完成，拉低PS-ON#通知ATX电源，ATX收到低电平的PS-ON#开始工作，开始提供其他电压。</p>
<p>同时若北桥存在，南桥发送PLT_RST#信号给北桥，北桥在收到PLT_RST#后，若自身工作正常，则一秒钟后向CPU发送并保持CPU_RST#，使得CPU开始复位；若北桥不不存在，CPU_RST#信号将由南桥发出。</p>
<p>当电源拉高PWR_OK#通知给南桥时(要是有北桥也会通知到北桥)，开始发出PWR_GOOD#信号通知CPU电源已稳定正常，撤销CPU_RST#，执行BIOS启动代码。</p>
<h2 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h2><p>当CPU收到高电平的CPU_RST#信号时(一般是通过CPU上某一特定引脚)，CPU将复位所有的状态，待CPU_RST#回到低电平(解除状态)时，CPU开始执行地址0XFFFF0H处的跳转指令，执行跳转到的BIOS的启动代码，随后将控制权交由BIOS。</p>
<p>至此，应该上电阶段就算完成了</p>
<h1 id="BIOS自检"><a href="#BIOS自检" class="headerlink" title="BIOS自检"></a>BIOS自检</h1><p>控制权： 硬件 –&gt; BIOS</p>
<p>BIOS(Basic Input Output System)即基本输入输出系统，它是一个写在主板某一存储芯片上的一套非常重要的系统</p>
<p>为什么是某一存储芯片，因为早期BIOS写在ROM(Read Only Memory，<a href="https://baike.baidu.com/item/%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8/2399075?fromModule=lemma_inlink">只读存储器</a>)中，ROM的特点就是，一旦内容被写入后，就无法再进行修改，若想更新BIOS程序，只能更换BIOS芯片；后续BIOS存储在<a href="https://baike.baidu.com/item/EPROM/1690813?fromModule=lemma_inlink">EPROM</a>（Erasable Programmable ROM，可<a href="https://baike.baidu.com/item/%E6%93%A6%E9%99%A4/9521357?fromModule=lemma_inlink">擦除</a>可编程ROM）&#x2F; <a href="https://baike.baidu.com/item/EEPROM/1690980?fromModule=lemma_inlink">EEPROM</a>（Electrically Erasable Programmable ROM，电可擦除可编程ROM）&#x2F; NORFlash中，它们的特点就是可修改，方便了BIOS的升级。</p>
<p>诶，那早期BIOS的设置存放在哪里呢？</p>
<p>不仅仅是早期，现在的BIOS参数设置依旧存放在CMOS中，就是相机传感器那个CMOS(Complementary Metal Oxide Semiconductor,互补金属氧化物半导体),他不仅仅作为感光元件，其被作为<a href="https://baike.baidu.com/item/RAM/144481?fromModule=lemma_inlink">RAM</a>的历史也很悠久。</p>
<p>而刚刚的CMOS芯片是个RAM(Random Access Memory,随机存取存储器),他的特点就是可读写，但具有易失性，所以很多人发现，一旦电脑用久了后，CMOS电池没电了，BIOS设置就会丢失的原因。</p>
<blockquote>
<p>吭，说多了，回归正题</p>
</blockquote>
<h2 id="硬件自检"><a href="#硬件自检" class="headerlink" title="硬件自检"></a>硬件自检</h2><p>CPU复位后，开始执行BIOS启动代码，其中第一句指令就是jump star，在执行指令之后，BIOS自检阶段通常会进行一系列的硬件上电检测，这被称为POST(Power-On Self-Test)，包括但不限于对CPU、内存、ROM、主板、CMOS存储器、串并口、显卡的检测。并将检测的结果与微机中的CMOS-RAM参数进行对比。</p>
<p>具体应该是这样，系统(主板)BIOS查找其他设备的BIOS，对其进行校验，然后将控制权交于设备BIOS，开始设备初始化以及装载，随后将控制权交回系统BIOS。</p>
<p>如果这些步骤中有任何问题被发现，系统可能会给出相应的提示或鸣笛警告。如果没有发现问题，系统会将硬件设置为备用状态，然后着手准备系统的引导。</p>
<p>若一切顺利，且与上次启动时相比发生设备变更，BIOS将更新ESCD(Extended System Configuration Data,扩展系统配置数据)的数据,这是一张设备资源分配表，用于和操作系统交换硬件配置信息。在后续的系统引导以及其他环节中，操作系统也会读取ESCD，从而加载硬件驱动、设置相应参数以及其他东西。</p>
<h2 id="查找引导设备"><a href="#查找引导设备" class="headerlink" title="查找引导设备"></a>查找引导设备</h2><p>若签名硬件自检顺利，BIOS则开始查找引导设备，引导设备通常是硬盘，但又不全是。</p>
<p>在硬件自检的过程中，BIOS会读取CMOS中的用户数据并结合刚刚的硬件信息，生成Boot Sequence，正如字面意思，他记入了开机启动顺序。</p>
<p>BIOS会依次按照Boot Sequence中的顺序，测试其可否用于引导，一旦找到可引导设备，则不再向下查找，开始引导该设备。</p>
<h1 id="系统引导"><a href="#系统引导" class="headerlink" title="系统引导"></a>系统引导</h1><p>控制权: BIOS –&gt; 启动设备</p>
<p>BIOS确定启动项，会执行该设备的引导程序，并退下，剩下交由引导程序进行处理。</p>
<p>引导方式分为两种:</p>
<ul>
<li>legacy BIOS + MBR</li>
<li>UEFI + GPT</li>
</ul>
<p>BIOS会根据顺序，判断各设备是否可启动，若可，则将控制权交由该设备。</p>
<blockquote>
<p>拿硬盘举例</p>
</blockquote>
<h2 id="BIOS-MBR"><a href="#BIOS-MBR" class="headerlink" title="BIOS + MBR"></a>BIOS + MBR</h2><p>MBR(Master Boot Record,主引导记录、主引导扇区)，这是一种比较老的方法，将主引导程序、磁盘签名、分区表都写在0柱0道1区(LBA 0 ，共512字节)，其中引导程序占用前446字节</p>
<blockquote>
<p>MBR<code>中的引导程序</code>是这种引导方式的第一个BootLoader</p>
</blockquote>
<blockquote>
<p>MBR有个很鲜明的特点，就是只能分4个主分区，这是受分区表长度限制的，想要更多的分区就需要用到拓展分区。</p>
</blockquote>
<p><img data-src="/../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9C%A8%E5%BC%80%E6%9C%BA%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/MBR.png" alt="MBR"></p>
<p>BIOS会将硬盘的LBA 0整个读入内存中地址为0x7c00的地方，随后判断该扇区结尾是否为0X55AA(引导记录的固定结尾，图有错)，若有，则表名该分区可用于启动，否则将延续到下一个启动项。</p>
<p>BIOS将控制权交由LBA 0开头的主引导程序，主引导程序(Master Boot Record)将对分区表进行一次自检，自检通过则将控制权交激活分区引导记录(Partition Boot Record,分区引导记录)，由它完成剩下的系统引导。如下：</p>
<blockquote>
<p>何为激活分区，激活分区说白了就是操作系统在的分区，理论上4个主分区中只能有一个激活分区。</p>
</blockquote>
<p>此时，计算机将激活分区的第一扇区，即:VBR(Volume Boot Record，卷引导记录)，或叫做PBR(Partition Boot Record,分区引导记录)读到内存，执行引导记录中的引导程序，由它去寻找激活分区根目录下的引导加载程序(Boot loader)，例如分区内安装了Windows系统，那么PBR就会加载bootmgr或ntldr文件；如果分区内安装了Linux系统，那么PBR就会加载grub或lilo等引导程序，剩下就交给Boot loader去加载配置、驱动、内核、引导操作系统。</p>
<blockquote>
<p>细说一句，引导记录(MBR、VBR、PBR)都只是个特殊的区域，是<code>里面存放着</code>BootLoader</p>
<p>所以，引导记录 ≠ 引导程序，引导记录包含引导程序</p>
</blockquote>
<h2 id="UEFI-GPT"><a href="#UEFI-GPT" class="headerlink" title="UEFI + GPT"></a>UEFI + GPT</h2><p>GPT（GUID Partition Table,全局唯一标识磁盘分区表）</p>
<p>先把GUID放一边，理解为一种唯一标识ID就行，而GPT就<code>使用GUID标识磁盘分区</code></p>
<p>GPT分区具体结构如下</p>
<p><img data-src="/../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9C%A8%E5%BC%80%E6%9C%BA%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/GPT%E7%BB%93%E6%9E%84.png" alt="GPT结构"></p>
<p>虽然GPT的第一个扇区也是MBR，但，仔细看：</p>
<p><img data-src="/../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9C%A8%E5%BC%80%E6%9C%BA%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/GPT0%E6%89%87%E5%8C%BA.png" alt="GPT0扇区"></p>
<p>他开头是空的 ！！引导程序呢，怎么就留一个分区表？</p>
<p>其实这只是GPT分区故意预留了一个扇区(LBA 0)，用于防止X86程序误破环。分区表记录中只有一个标识为0xEE的分区，以此来表示这块硬盘使用GPT分区表。而GPT真正的头在第二个扇区(LBA 1)中。</p>
<p>在GPT中，分区表储存在GPT头后。GPT头包含了一个逻辑块地址（LBA），用于替代早期MBR的CHS寻址方式，具体作用就是用于指定位区表在磁盘上的位置。</p>
<p>而引导程序被放置在ESP(EFI system partition,EFI系统分区)中，ESP虽然是一个 FAT16 或 FAT32 格式的物理分区，但是其分区标识是 0XEF 而非常规的 0X0E 或 0X0C。</p>
<p>而EFI是因特尔提供的一种可扩展固件接口,一些上古BIOS并不支持该接口，EFI的概念整体上更像是一个低阶操作系统，他可以实现软硬件交互，从而用于替代BIOS的功能，而GPT是其标准的一部分，可用于替代MBR。</p>
<p>现在用的基本都是UEFI(Unified Extensible Firmware Interface,统一可扩展固件接口),它由EFI发展而来，在其兼容性、可拓展性、安全性上做了提升。其主要目的就是用于取代传统BIOS固定的、缺乏文档的、完全基于经验和晦涩约定的一个事实标准。</p>
<p>但UEFI固件加载完毕后，他会先对硬件进行检测，随后通过GTP分区表，去找ID为<em>C12A7328-F81F-11D2-BA4B-00A0C93EC93B</em>的分区。这个ID是事先约定俗成的，用来表示ESP分区。</p>
<p>BIOS找的是ESP中的.efi文件，.efi文件就比MBR(LBA 0)中的引导程序丰富的多，里面就包含了引导加载程序(Boot loader)、一些驱动程序、操作系统内核、还有一些配置文件和其他的程序，BIOS将控制权交由引导加载程序，由它去加载操作系统。</p>
<blockquote>
<p>好像有个标准，.efi文件通常叫bootx64.efi，可用于引导各种操作系统，但还有一个bootmgfw.efi，他只能用于引导Windows系统。</p>
<p>且.efi文件不仅仅只是用于引导系统，例如我在\EFI\Microsoft\Boot中还找到了memtest.efi这个文件，而它是用于做内存诊断的。</p>
</blockquote>
<blockquote>
<p>ESP 中的一个重要组件是 BootManager（BootMgr.efi），它负责加载和管理不同的 BootLoader</p>
</blockquote>
<blockquote>
<p>在UEFI+GPT这种引导方式中，分区引导记录中的引导程序不是必须的，通常直接由ESP中的程序加载系统内核。</p>
</blockquote>
<h3 id="UEFI安全启动"><a href="#UEFI安全启动" class="headerlink" title="UEFI安全启动"></a>UEFI安全启动</h3><p>UEFI安全启动在BIOS设置中常叫做Secure Boot，具体为：UEFI固件会在启动时对自身以及自己加载的所有组件进行验证，判断签名和证书是否可信，以防止恶意代码的运行。</p>
<h1 id="BIOS自检操作系统初始化"><a href="#BIOS自检操作系统初始化" class="headerlink" title="BIOS自检操作系统初始化"></a>BIOS自检操作系统初始化</h1><p>控制权: 启动设备 –&gt; 操作系统</p>
<h2 id="BootLoader"><a href="#BootLoader" class="headerlink" title="BootLoader"></a>BootLoader</h2><p>BootLoader(引导加载程序)主要存在与启动设备中，它主要负责为操作系统的运行提供环境引导操作系统内核，具体大致如下：</p>
<ul>
<li>安装与初始化物理内存</li>
<li>安装设备树</li>
<li>解压并启动内核镜像</li>
</ul>
<p>BootLoader有两种加载模式，分别对应常规的有盘系统和无盘系统</p>
<ol>
<li><p>本地加载模式</p>
<p>他对应的是常规的有盘系统，系统的BootLader在本地存储介质中，BootLader将本地存储介质上的操作系统加载到RAM中，然后进行系统的引导。</p>
</li>
<li><p>远程下载模式</p>
<p>这主要是对应无盘系统，以及一些自动化部署，这需要网卡支持PXE Client，BIOS将PXE Client载入内存并运行，PXE Client将在远程服务器上下载BootLoader，并加载在内存中运行，而BootLoader将通过远程服务器把内核镜像以及文件系统下载并载入到内存中。</p>
<p>无盘系统主要是针对一些工作站、网吧，应该是通过ipxe技术实现，该技术支持从盘启动，原理大概是这样，ipxe通过远程服务器得到第一个BootLoader并加载运行，然后第一个BootLoader将通过特定协议将装有系统的启动盘挂载在服务器中。然后加载服务器中的那个启动盘的第二个BootLoader，剩下的就类似本地加载模式。</p>
</li>
</ol>
<blockquote>
<p>在一次系统引导过程中，不一定只会遇到一个BootLoader，通常情况下会遇到多个！一个连着一个。</p>
</blockquote>
<h2 id="Windows的初始化"><a href="#Windows的初始化" class="headerlink" title="Windows的初始化"></a>Windows的初始化</h2><blockquote>
<p>下面是Microsoft的BootLoader</p>
</blockquote>
<h3 id="Windows-Boot-Manager"><a href="#Windows-Boot-Manager" class="headerlink" title="Windows Boot Manager"></a>Windows Boot Manager</h3><p>又叫bootmgr，它是一种GRUB(GRand Unified Bootloader,多操作系统启动程序)，是Windows Vista ~ Windows 11系统的BootLoader，当bootmgr得到执行权后，将读取BCD(Boot Configuration Data,启动配置数据)文件</p>
<p>BCD文件是一个包含操作系统启动菜单和启动配置信息的XML文件，它包含了操作系统、启动菜单选项、启动顺序和启动参数等信息。</p>
<p>bootmgr在读取bcd文件后，若存在多个Windows系统，则加载\EFI\Microsoft\Boot\[对应语言] 下的菜单文件(如图)，并展示引导菜单，后根据用户的选择调用相应的BootLoader(例如Winload.exe)，若就一个，那就跳过用户选择这一步。</p>
<p><img data-src="/../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9C%A8%E5%BC%80%E6%9C%BA%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%E7%9A%84%E8%8F%9C%E5%8D%95%E6%96%87%E4%BB%B6.png" alt="简体中文的菜单文件"></p>
<p><img data-src="/../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9C%A8%E5%BC%80%E6%9C%BA%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/%E9%80%89%E6%8B%A9Windows%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png" alt="选择Windows操作系统"></p>
<p>Winload.exe获得执行权后，他会加载并初始化内核环境、加载硬件驱动、用户配置，随后将控制权交由ntoskrnl.exe。这是一个Windows内核文件，主要负责Windows的调度，接下来将由他完成Windows系统启动的最后步骤。</p>
<p><img data-src="/../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9C%A8%E5%BC%80%E6%9C%BA%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/ntoskrnl.exe.png" alt="ntoskrnl.exe"></p>
<p><strong>至此，你的电脑就开机了</strong></p>
<h3 id="NTLDR"><a href="#NTLDR" class="headerlink" title="NTLDR"></a>NTLDR</h3><p>NTLDR,全称：Windows NT Loader，是windows nt 4.0、2000、xp、Server2003的BootLoader，存放于C盘根目录下，是一个隐藏且只读的文件</p>
<p>与bootmgr不一样，他通过读取Boot.ini获取可选的操作系统，这是一个存放在C盘根目录下的一个隐藏、只读的文件，这是XP系统下的文件，类容如下:</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[boot loader]</span></span><br><span class="line"><span class="attr">timeout</span>=<span class="number">5</span></span><br><span class="line"><span class="attr">default</span>=multi(<span class="number">0</span>)disk(<span class="number">0</span>)rdisk(<span class="number">0</span>)partition(<span class="number">1</span>)\WINDOWS</span><br><span class="line"><span class="section">[operating systems]</span></span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)\<span class="attr">WINDOWS</span>=<span class="string">&quot;Microsoft Windows XP Professional&quot;</span> /noexecute=optin /fastdetect</span><br></pre></td></tr></table></figure>

<p>[operating systems]中是操作系统选择列表，当里面的选项大于1时，系统将默认[boot loader]-defaul中指定的路径的系统为默认操作系统，若用户在[boot loader]-timeout中设置的时间内未进行操作，则启动默认操作系统。若就一个，则跳过用户选择。</p>
<p>如果在系统根目录下发现有Hiberfil.sys文件且该文件有效,这代表这次启动是前系统并未关机，而是进入休眠状态，那么NTLDR将读取Hiberfil.sys文件里的信息并让系统恢复到休眠以前的状态，而不处理Boot.ini文件。</p>
<p>随后将进入内核调用阶段，bootmg调用ntoskrnl.exe文件，这是一个Windows内核文件，主要负责Windows的调度，接下来将由他完成Windows系统启动的最后步骤。截图是我Win10电脑的</p>
<p><img data-src="/../image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9C%A8%E5%BC%80%E6%9C%BA%E6%97%B6%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/ntoskrnl.exe.png" alt="ntoskrnl.exe"></p>
<p><strong>至此，你的电脑就又开机了</strong></p>
<h2 id="Linux系统的初始化"><a href="#Linux系统的初始化" class="headerlink" title="Linux系统的初始化"></a>Linux系统的初始化</h2><blockquote>
<p>以下是常见的可用于引导Linux的BootLoader</p>
</blockquote>
<h3 id="GNU-GRUB"><a href="#GNU-GRUB" class="headerlink" title="GNU GRUB"></a>GNU GRUB</h3><p>GNU GRUB是一个来自GNU项目的引导加载程序，它支持Linux、Windows等众多操作系统。并会识别文件系统以及内核的可执行文件的格式，从而便于用户使用其引导系统，他支持多系统选择，不仅限于Windows、Linux系统。</p>
<p>GRUB引导过程可以分为以下几个步骤：</p>
<ul>
<li><p>第一阶段(stage1):这个阶段是存储在主引导记录（MBR）或分区引导记录（PBR）中的小程序，它的主要工作就是查找并加载第二阶段（stage2）的程序。在GRUB中由于MBR或PBR的空间很有限，stage1通常不能直接识别stage2所在的文件系统，因此可能需要一个中间阶段（stage1.5）来连接stage1和stage2。而GRUB2已经将stage1.5的功能融入stage2，则没有这步。</p>
</li>
<li><p>承上启下阶段(stage1.5):stage1.5存在于0柱0道3扇区(LBA2)以及其后大概10几KB的空间中(受要引导的文件系统有关)，这是一块特殊的区域，他不属于任何一个分区，且也没有分区表会写入到该区域，这就确保了stage1.5与其他东西之间互补干扰。stage1.5主要负责将stage2的位置告诉给stage1并向stage1提供文件系统驱动，而stage2的位置是被硬编码在stage1.5中的，</p>
</li>
<li><p>第二阶段(stage2):该阶段是GRUB的核心，GRUB的主要功能都写在这里面，stage2通常位于<code>/boot/grub</code>目录下，他会读取配置文件<code>/boot/grub/grub.cfg</code>并显示引导菜单，并依据用户的选择加载相应系统的内核文件，随后将控制权交由操作系统。</p>
</li>
</ul>
<p><strong>至此，你的电脑又开机了</strong></p>
<p><br><br><br><br><br><br></p>
<p style="text-align:center">>------参考资料------<</p>

<blockquote>
<p><a href="https://baike.baidu.com/item/BootLoader/8733520?fr=ge_ala">百度百科-BootLoader</a></p>
<p><a href="https://baike.baidu.com/item/ATX%E7%94%B5%E6%BA%90/919516?fr=ge_ala">百度百科-ATX电源</a></p>
<p><a href="https://baike.baidu.com/item/%E5%AE%9E%E6%97%B6%E6%97%B6%E9%92%9F/5563907?fr=ge_ala">百度百科-实时时钟</a></p>
<p><a href="https://baike.baidu.com/item/bios/91424?fr=ge_ala">百度百科-BIOS</a></p>
<p><a href="https://baike.baidu.com/item/CMOS/428167?fromModule=lemma_inlink">百度百科-CMOS</a></p>
<p><a href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8/4099402?fromModule=lemma_inlink&fromtitle=RAM&fromid=144481">百度百科-ARM</a></p>
<p><a href="https://baike.baidu.com/item/EFI/2025809?fromModule=lemma_search-box">百度百科-EFI</a></p>
<p><a href="https://baike.baidu.com/item/%E7%BB%9F%E4%B8%80%E5%8F%AF%E6%89%A9%E5%B1%95%E5%9B%BA%E4%BB%B6%E6%8E%A5%E5%8F%A3/22786233?fromtitle=UEFI&fromid=3556240&fr=aladdin">百度百科-UEFI</a></p>
<p><a href="https://baike.baidu.com/item/EFI%E7%B3%BB%E7%BB%9F%E5%88%86%E5%8C%BA?fromModule=lemma_search-box">百度百科-EFI系统分区</a></p>
<p><a href="https://upimg.baike.so.com/doc/6827699-7044894.html">360百科-bootmgr</a></p>
<p><a href="https://baike.baidu.com/item/NTLDR/2909882?fr=ge_ala">百度百科-NTLDR</a></p>
<p><a href="https://baike.baidu.com/item/boot.ini?fromModule=lemma_search-box#2_2">百度百科-boot.ini</a></p>
<p><a href="https://baike.baidu.com/item/ntoskrnl.exe/8196033?fr=ge_ala">百度百科-ntoskrnl.exe</a></p>
<p><a href="https://www.cnblogs.com/liuzhenbo/p/10806119.html">博客园-GRUB&amp;MBR引导</a></p>
<p><a href="https://www.gnu.org/software/grub/manual/grub/">GNU GRUB Manual 2.06</a></p>
<p><a href="https://blog.csdn.net/weixin_44702017/article/details/90405380">CSDN-有关UEFI,GPT分区以及系统引导等问题的了解</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/31180815">知乎-按下电源键后发生了什么？电脑是如何优雅地开机的</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/610227271">知乎-浅谈BootLoader</a></p>
<p>一些由AI整理出的资料</p>
</blockquote>
]]></content>
      <categories>
        <category>笔记分享</category>
      </categories>
      <tags>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
</search>
