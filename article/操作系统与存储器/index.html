<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><meta name="theme-color" content="#555" media="(prefers-color-scheme: light)"><meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0"><link rel="preconnect" href="https://cdn.bootcdn.net" crossorigin><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#555"><meta name="msvalidate.01" content="A785C89C0562F81A78EC2B5B46029C8A"><meta name="baidu-site-verification" content="codeva-3QuUg959rd"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha256-wiz7ZSCn/btzhjKDQBms9Hx4sSeUYsDrTLg7roPstac=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.33/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/pace/1.2.4/themes/silver/pace-theme-flash.css"><script src="https://cdn.bootcdn.net/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous"></script><script class="next-config" data-name="main" type="application/json">{"hostname":"blog.canyue.top","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.19.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":17,"offset":12},"copycode":{"enable":true,"style":"default"},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#555","save":"auto"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":true,"transition":{"menu_item":"fadeInLeft","post_block":"fadeInUp","post_header":"fadeInTop","post_body":"fadeIn","coll_header":null,"sidebar":"fadeInUp","All available transition variants":"https://theme-next.js.org/animate/"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":true,"preload":false}}</script><script src="/js/config.js"></script><meta name="description" content="以下内容涉及知识点较深，可能有误，望指出。参考时建议再次查证内容的准确性。 本篇是以OS的视角，研究分页和分段存储优先看这篇  冯诺依曼型计算机是由运算器、存储器、控制器、输入设备和输出设备五大部件组成，现存计算机都遵循该设计 存储器是一种用于存储程序和数据信息的部件，是一种时序电路 存储器的层次结构在计算机执行指令时，基本上都会涉及到存储器的访问，故存储器的性能影响到计算机的运行效率。 但如今"><meta property="og:type" content="article"><meta property="og:title" content="操作系统与存储器管理"><meta property="og:url" content="https://blog.canyue.top/article/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/index.html"><meta property="og:site_name" content="Canyue&#39;s house"><meta property="og:description" content="以下内容涉及知识点较深，可能有误，望指出。参考时建议再次查证内容的准确性。 本篇是以OS的视角，研究分页和分段存储优先看这篇  冯诺依曼型计算机是由运算器、存储器、控制器、输入设备和输出设备五大部件组成，现存计算机都遵循该设计 存储器是一种用于存储程序和数据信息的部件，是一种时序电路 存储器的层次结构在计算机执行指令时，基本上都会涉及到存储器的访问，故存储器的性能影响到计算机的运行效率。 但如今"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E9%AB%98%E6%95%B0%E7%BC%93%E5%AD%98%E4%B8%8E%E4%B8%BB%E5%AD%98%E7%9A%84%E5%B1%82%E6%AC%A1.png"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E5%B1%82%E6%AC%A1.png"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%8F%8C%E7%A8%B3%E6%80%81%E6%80%A7.png"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/EROM.jpg"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4.jpg"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E7%94%A8%E6%88%B7%E5%8C%BA%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%8C%BA.jpg"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F%E5%88%92%E5%88%86_%E5%8A%A8%E6%80%81%E6%88%96%E9%9D%99%E6%80%81.jpg"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D_%E5%88%86%E5%8C%BA%E8%A1%A8.jpg"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.jpg"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E7%A9%BA%E9%97%B2%E5%88%86%E5%8C%BA%E8%A1%A8.jpg"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E7%A9%BA%E9%97%B2%E5%88%86%E5%8C%BA%E9%93%BE.jpg"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.jpg"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.jpg"><meta property="og:image" content="https://blog.canyue.top/image/%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98_%E6%B5%81%E7%A8%8B.png"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E4%B8%80%E4%B8%AA%E7%9B%B8%E9%82%BB%E5%88%86%E5%8C%BA%E6%97%B6_%E5%9B%9E%E6%94%B6.png"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E4%B8%A4%E4%B8%AA%E7%9B%B8%E9%82%BB%E5%88%86%E5%8C%BA%E6%97%B6_%E5%9B%9E%E6%94%B6.png"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E4%B8%8D%E7%9B%B8%E9%82%BB%E5%88%86%E5%8C%BA%E5%9B%9E%E6%94%B6.png"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%88%86%E9%A1%B5%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E9%A1%B5%E9%9D%A2%E5%9C%B0%E5%9D%80%E5%8F%98%E5%9D%80.png"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.png"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%A4%BA%E4%BE%8B.png"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%88%86%E6%AE%B5%E5%9C%B0%E5%9D%80.png"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E6%AE%B5%E8%A1%A8.png"><meta property="og:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%88%86%E6%AE%B5%E5%8F%98%E5%9D%80.png"><meta property="article:published_time" content="2024-02-29T06:45:31.000Z"><meta property="article:modified_time" content="2024-03-16T08:46:24.124Z"><meta property="article:author" content="Canyue"><meta property="article:tag" content="计算机组成原理"><meta property="article:tag" content="操作系统"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blog.canyue.top/image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E9%AB%98%E6%95%B0%E7%BC%93%E5%AD%98%E4%B8%8E%E4%B8%BB%E5%AD%98%E7%9A%84%E5%B1%82%E6%AC%A1.png"><link rel="canonical" href="https://blog.canyue.top/article/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/"><script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://blog.canyue.top/article/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/","path":"article/操作系统与存储器/","title":"操作系统与存储器管理"}</script><script class="next-config" data-name="calendar" type="application/json">""</script><title>操作系统与存储器管理 | Canyue's house</title><noscript><link rel="stylesheet" href="/css/noscript.css"></noscript><link rel="alternate" href="/atom.xml" title="Canyue's house" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><div class="column"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏" role="button"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><p class="site-title">Canyue's house</p><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">welcome|欢迎来访</p></div><div class="site-nav-right"><div class="toggle popup-trigger" aria-label="搜索" role="button"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-博客"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>博客</a></li><li class="menu-item menu-item-主页"><a href="/home" rel="section"><i class="fa fa-address-card fa-fw"></i>主页</a></li><li class="menu-item menu-item-关键字"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>关键字</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">1</span></a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close" role="button"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></header><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="sidebar-panel-container"><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">存储器的层次结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF"><span class="nav-number">2.</span> <span class="nav-text">存储技术</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">随机访问存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SRAM"><span class="nav-number">2.1.1.</span> <span class="nav-text">SRAM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DRAM"><span class="nav-number">2.1.2.</span> <span class="nav-text">DRAM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%AD%98%E5%82%A8%E5%99%A8"><span class="nav-number">2.2.</span> <span class="nav-text">非易失性存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ROM"><span class="nav-number">2.2.1.</span> <span class="nav-text">ROM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PROM"><span class="nav-number">2.2.2.</span> <span class="nav-text">PROM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EPROM"><span class="nav-number">2.2.3.</span> <span class="nav-text">EPROM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EEPROM"><span class="nav-number">2.2.4.</span> <span class="nav-text">EEPROM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Flash"><span class="nav-number">2.2.5.</span> <span class="nav-text">Flash</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%A3%85%E5%85%A5%E4%B8%8E%E9%93%BE%E6%8E%A5"><span class="nav-number">3.</span> <span class="nav-text">程序的装入与链接</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E7%BB%91%E5%AE%9A"><span class="nav-number">3.1.</span> <span class="nav-text">地址绑定</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%BF%9D%E6%8A%A4"><span class="nav-number">3.2.</span> <span class="nav-text">内存保护</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91"><span class="nav-number">3.3.</span> <span class="nav-text">编译</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5"><span class="nav-number">3.4.</span> <span class="nav-text">链接</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">3.4.1.</span> <span class="nav-text">静态链接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">3.4.2.</span> <span class="nav-text">动态链接</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A3%85%E5%85%A5%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">装入时动态链接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">运行时动态链接</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A3%85%E5%85%A5"><span class="nav-number">3.5.</span> <span class="nav-text">装入</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%9D%E5%AF%B9%E8%A3%85%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">3.5.1.</span> <span class="nav-text">绝对装入方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E5%AE%9A%E5%90%91%E8%A3%85%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">3.5.2.</span> <span class="nav-text">可重定向装入方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%BF%90%E8%A1%8C%E6%97%B6%E8%A3%85%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="nav-number">3.5.3.</span> <span class="nav-text">动态运行时装入方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">存储分配方式</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F-%E5%88%86%E5%8C%BA"><span class="nav-number">4.1.</span> <span class="nav-text">连续分配存储方式(分区)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="nav-number">4.1.1.</span> <span class="nav-text">单一连续分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%BA%E5%AE%9A%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D"><span class="nav-number">4.1.2.</span> <span class="nav-text">固定连续分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E5%8C%BA%E7%9A%84%E5%88%92%E5%88%86"><span class="nav-number">4.1.2.1.</span> <span class="nav-text">分区的划分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-number">4.1.2.2.</span> <span class="nav-text">内存的分配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D"><span class="nav-number">4.1.3.</span> <span class="nav-text">动态分区分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%B0%E5%BD%95%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5"><span class="nav-number">4.1.3.1.</span> <span class="nav-text">使用数据结构记录使用情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.3.2.</span> <span class="nav-text">动态分区分配算法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E9%A1%BA%E5%BA%8F%E6%90%9C%E7%B4%A2"><span class="nav-number">4.1.3.2.1.</span> <span class="nav-text">基于顺序搜索</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E7%B4%A2%E5%BC%95%E6%90%9C%E7%B4%A2"><span class="nav-number">4.1.3.2.2.</span> <span class="nav-text">基于索引搜索</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E7%9A%84%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6"><span class="nav-number">4.1.3.3.</span> <span class="nav-text">可变分区的分配与回收</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E7%9A%84%E5%88%86%E9%85%8D"><span class="nav-number">4.1.3.3.1.</span> <span class="nav-text">可变分区的分配</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E5%8F%98%E5%88%86%E5%8C%BA%E7%9A%84%E5%9B%9E%E6%94%B6"><span class="nav-number">4.1.3.3.2.</span> <span class="nav-text">可变分区的回收</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E9%87%8D%E5%AE%9A%E5%90%91%E5%88%86%E9%85%8D"><span class="nav-number">4.1.4.</span> <span class="nav-text">动态重定向分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="nav-number">4.1.4.1.</span> <span class="nav-text">怎么解决</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">分页存储方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F%E4%B8%8E%E5%86%85%E7%A2%8E%E7%89%87"><span class="nav-number">4.2.1.</span> <span class="nav-text">页面大小与内碎片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="nav-number">4.2.2.</span> <span class="nav-text">分页地址结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%B5%E8%A1%A8"><span class="nav-number">4.2.3.</span> <span class="nav-text">页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%A1%B5%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8F%98%E5%9D%80"><span class="nav-number">4.2.4.</span> <span class="nav-text">分页地址的变址</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8F%98%E5%9D%80%E6%9C%BA%E6%9E%84"><span class="nav-number">4.2.4.1.</span> <span class="nav-text">基于地址的变址机构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84"><span class="nav-number">4.2.4.2.</span> <span class="nav-text">具有快表的地址变换机构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E5%BF%AB%E8%A1%A8%E5%90%8E%E7%9A%84%E5%86%85%E5%AD%98%E6%9C%89%E6%95%88%E8%AE%BF%E9%97%AE%E6%97%B6%E9%97%B4"><span class="nav-number">4.2.4.3.</span> <span class="nav-text">引入快表后的内存有效访问时间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="nav-number">4.2.5.</span> <span class="nav-text">多级页表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A864%E4%BD%8D%E7%8E%AF%E5%A2%83%E4%B8%8B"><span class="nav-number">4.2.5.1.</span> <span class="nav-text">在64位环境下</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">4.3.</span> <span class="nav-text">分段存储方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%AE%B5"><span class="nav-number">4.3.1.</span> <span class="nav-text">分段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AE%B5%E8%A1%A8"><span class="nav-number">4.3.2.</span> <span class="nav-text">段表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E6%AE%B5%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8F%98%E5%9D%80"><span class="nav-number">4.3.3.</span> <span class="nav-text">分段地址的变址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E5%92%8C%E4%BA%8C%E7%BB%B4%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.3.4.</span> <span class="nav-text">一维和二维的问题</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Canyue" src="/../image/avatar.jpg"><p class="site-author-name" itemprop="name">Canyue</p><div class="site-description" itemprop="description">梳理知识的同时,希望也能帮助到你</div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">10</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">1</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">13</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><a href="https://github.com/1024canyue" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;1024canyue" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://gitee.com/canyue2048" title="Gitee → https:&#x2F;&#x2F;gitee.com&#x2F;canyue2048" rel="noopener me" target="_blank"><i class="fa fa-code fa-fw"></i>Gitee</a> </span><span class="links-of-author-item"><a href="https://tuchong.com/20603255" title="图虫 → https:&#x2F;&#x2F;tuchong.com&#x2F;20603255" rel="noopener me" target="_blank"><i class="fa fa-camera fa-fw"></i>图虫</a> </span><span class="links-of-author-item"><a href="mailto:lintaisheng@outlook.com" title="E-Mail → mailto:lintaisheng@outlook.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a></span></div><div id="diyClock"><canvas id="canvas" style="width:60%;margin-top:9px;padding:0"></canvas></div><div style="font-size:1.2rem"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS订阅</span></a></div><div class="cc-license animated" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh_CN" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.bootcdn.net/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a></div><script async>!function(){var l,s=8,f=[[[0,0,1,1,1,0,0],[0,1,1,0,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,0,1,1,0],[0,0,1,1,1,0,0]],[[0,0,0,1,1,0,0],[0,1,1,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[1,1,1,1,1,1,1]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,0,0,1,1],[1,1,1,1,1,1,1]],[[1,1,1,1,1,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,1,1,1,0,0],[0,0,0,0,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,0,1,1,1,0],[0,0,1,1,1,1,0],[0,1,1,0,1,1,0],[1,1,0,0,1,1,0],[1,1,1,1,1,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,1,1]],[[1,1,1,1,1,1,1],[1,1,0,0,0,0,0],[1,1,0,0,0,0,0],[1,1,1,1,1,1,0],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,0,0,0,1,1,0],[0,0,1,1,0,0,0],[0,1,1,0,0,0,0],[1,1,0,0,0,0,0],[1,1,0,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[1,1,1,1,1,1,1],[1,1,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,0,0,1,1,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0],[0,0,1,1,0,0,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,1,1,0]],[[0,1,1,1,1,1,0],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[1,1,0,0,0,1,1],[0,1,1,1,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,0,1,1],[0,0,0,0,1,1,0],[0,0,0,1,1,0,0],[0,1,1,0,0,0,0]],[[0,0,0,0],[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0],[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]]];function n(n){var t=[],e=(l.fillStyle="#aaa",new Date),u=60,a=e.getHours(),h=Math.floor(a/10),a=a%10,o=(t.push({num:h}),t.push({num:a}),t.push({num:10}),e.getMinutes()),h=Math.floor(o/10),a=o%10,o=(t.push({num:h}),t.push({num:a}),t.push({num:10}),e.getSeconds()),h=Math.floor(o/10),a=o%10;t.push({num:h}),t.push({num:a});for(var r=0;r<t.length;r++)u=function(n,t,e,u){for(var a=f[e],h=0;h<a.length;h++)for(var o=0;o<a[h].length;o++)1==a[h][o]&&(u.beginPath(),u.arc(n+s+2*s*o,t+s+2*s*h,s,0,2*Math.PI),u.fill());return u.beginPath(),n+=a[0].length*s*2}(t[r].offsetX=u,30,t[r].num,n),r<t.length-1&&10!=t[r].num&&10!=t[r+1].num&&(u+=25)}var t=document.getElementById("canvas");t.width=950,t.height=200,l=t.getContext("2d"),new Date;setInterval(function(){l.clearRect(0,0,l.canvas.width,l.canvas.height),n(l)},50)}()</script></div></div></div></aside></div><div class="main-inner post posts-expand"><div class="post-block"><article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.canyue.top/article/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/../image/avatar.jpg"><meta itemprop="name" content="Canyue"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Canyue's house"><meta itemprop="description" content="梳理知识的同时,希望也能帮助到你"></span><span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork"><meta itemprop="name" content="操作系统与存储器管理 | Canyue's house"><meta itemprop="description" content=""></span><header class="post-header"><h1 class="post-title" itemprop="name headline">操作系统与存储器管理</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-02-29 14:45:31" itemprop="dateCreated datePublished" datetime="2024-02-29T14:45:31+08:00">2024-02-29</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-03-16 16:46:24" itemprop="dateModified" datetime="2024-03-16T16:46:24+08:00">2024-03-16</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%AC%94%E8%AE%B0%E5%88%86%E4%BA%AB/" itemprop="url" rel="index"><span itemprop="name">笔记分享</span></a> </span></span><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>11k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>36 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><blockquote><p>以下内容涉及知识点较深，可能有误，望指出。参考时建议再次查证内容的准确性。</p><p>本篇是以OS的视角，研究分页和分段存储优先看这篇</p></blockquote><p>冯诺依曼型计算机是由运算器、存储器、控制器、输入设备和输出设备五大部件组成，现存计算机都遵循该设计</p><p>存储器是一种用于存储程序和数据信息的部件，是一种时序电路</p><h1 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h1><p>在计算机执行指令时，基本上都会涉及到存储器的访问，故存储器的性能影响到计算机的运行效率。</p><p>但如今随着计算机技术的发展，对存储器的容量需求也越来越大，通常一种存储器无法同时满足快速与大容量甚至低廉的成本，故现在计算机均采用多层次的存储器设计。</p><span id="more"></span><p>对于通用计算机，通常将存储器分为三个层次，与中央处理器(CPU)的距离由近到远分为：</p><ul><li><p>寄存器</p><p>寄存器常封装在CPU内部，用于暂时存放指令、数据、运算结果，以便CPU能够更快速地访问和操作这些数据。</p><p>由于与核心相连，寄存器具必须有与CPU相同的执行速度，故寄存器的生产成本高。</p><p>为使CPU在执行指令时能够直接、高效的操作寄存器里的数据，<code>通常</code>寄存器的长度与CPU的位数一致，例如：在32位CPU中，寄存器的长度是32位，能够存储一个32位的数值。</p></li><li><p>主存储器</p><p>主存储器也被称为内存，也有人叫它可执行存储器，可由CPU直接随机存取。</p><p>主存储器在速度上逊色于寄存器，当主存储器的容量要比寄存器大得多</p><p>主存储器可用于缓存辅助存储器的数据，现代计算机设计，为了提高性能的同时兼顾价格，常常采用多级的主存储器设计。</p><ul><li><p>高速缓冲存储器</p><p>也被称为高数缓存，被封装在CPU内部。</p><p><code>与寄存器不同</code>，高速缓存被设计为CPU与其他主存之间，由静态存储芯片(SRAM)，其速度接近于与CPU的速度，容量小于其他主存但比寄存器要大得多，用于缓存其他主存的数据以加速CPU对主存的存取速度，可以显著减少CPU访问主存的延迟。</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E9%AB%98%E6%95%B0%E7%BC%93%E5%AD%98%E4%B8%8E%E4%B8%BB%E5%AD%98%E7%9A%84%E5%B1%82%E6%AC%A1.png" alt="高数缓存与主存的层次"></p><p>在现代CPU设计中，高速缓存也被设计成多级结构，通常分为三个级别，等级越高(数字越小)，速度越快、容量越小。</p><ul><li>L1缓存时计算机中最快的主存储器，当然一般也最小，普遍以KB为单位，部分高端CPU可达1M(例如AMD 7950X)甚至更高，L1缓存常被分割为指令缓存与数据缓存，通常用于存储CPU正在操作的内容。</li><li>L2缓存要比L1大不少，通常在256KB-16MB左右(2023年)，L2缓存通常存放着CPU下一步可能要执行的内容，通常与L1缓存一样，L2缓存也被封装在CPU核心内部，但不像L1缓存直接与核心相连。</li><li>L3缓存，在现在计算机设计中，L3缓存是CPU中最大的主存，通常被封在CPU中单独区域，由多个核心甚至是核显共享。</li></ul><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E7%9A%84%E5%B1%82%E6%AC%A1.png" alt="高速缓存的层次"></p><p align="center" style="font-size:x-small">图片来源见水印</p><p>CPU会优先在L1缓存中寻找，然后是L2、L3以及其他主存，若CPU在L1中找到指令或数据，则称之为缓存命中，缓存的命中率是高速缓存的一项重要性能指标</p></li><li><p>主存储器</p><p>这里的主存储器应该要理解为现在计算机中的内存条，在辅助存储器与高速缓存之间</p></li><li><p>磁盘缓存</p><p>由于当今磁盘的IO速度要明显低于主存储器，故在现代计算机设计中使用磁盘存储器暂存磁盘中频繁使用的数据，降低磁盘IO负载。</p><p>磁盘缓存可能是系统内存或由分装在磁盘PCB上独立的存储器如SRAM（静态随机存取存储器）负责</p><p>由于操作系统对磁盘的写入操作可能未能及时从磁盘缓存存储到磁盘中，故在磁盘意外断电时可能会导致应存入磁盘的数据发生丢失。</p></li></ul><blockquote><p>高速缓存与磁盘缓存，属于主存储器，而不是寄存器和辅助存储器</p></blockquote></li><li><p>辅助存储器</p><p>辅助存储器又被称为外存储器，此类储存器一般采用非易失的存储介质制成，通常断电后能保留数据，如磁盘、固态硬盘、光盘等。</p><p>辅助存储器不可由CPU直接寻址，通常在使用时由操作系统(OS)读取并缓存在主存储器中，这也是主存储器被称为可执行存储器的原因。</p></li></ul><p>不同层次的存储器会由OS进行统一管理</p><h1 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h1><h2 id="随机访问存储器"><a href="#随机访问存储器" class="headerlink" title="随机访问存储器"></a>随机访问存储器</h2><p>也被称为随机存取存储器(RAM)，被分为两类:SRAM(Static Random Access Memory,静态随机存储器)与DRAM(Dynamic Random Access Memory,动态随机存储器)，SRAM更快，成本也相对更高。</p><p>RAM工作时(刷新时除外)可以随时从任何一个指定的地址写入（存入）或读出（取出）信息</p><p>RAM的读写速度很快，但存储其中的数据是易失的，这就意味着一旦断电存储的说有数据将丢失，故常被用作临时的存储介质</p><h3 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h3><p>SRAM通常采用6管MOS制成，这种电路结构天生在通电时具有双稳态性（也就是图中，要么1，要么3，在其他状态都是不稳定的，会很快的恢复到一个稳定状态下）</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%8F%8C%E7%A8%B3%E6%80%81%E6%80%A7.png" alt="双稳态性"></p><p>正是由于双稳态性，SRAM<code>无需刷新即可保持在稳定值</code>，即使受到干扰，在干扰消除时也可很快恢复，这些特点使其特别适用于需要高速访问和可靠存储数据的场景，如CPU与主存之间的高速缓存、CPU内部的L1&#x2F;L2等</p><p>但由于SRAM集成密度小、芯片面积大、成本高，现如今DRAM仍是主流</p><h3 id="DRAM"><a href="#DRAM" class="headerlink" title="DRAM"></a>DRAM</h3><p>DRAM采用电容对数据位进行存储，正是由于采用电容来存储bit数据，由于存储在电容器上的电荷会随着时间的推移而泄漏，因此DRAM<code>需要定期刷新</code>以确保数据的完整性</p><p>DRAM存储器对干扰非常敏感，若电容的电压被扰乱就永远无法恢复</p><p>DRAM相较于SRAM拥有更高的密度，这也意味着成本更低，但速度要比SRAM慢</p><h2 id="非易失性存储器"><a href="#非易失性存储器" class="headerlink" title="非易失性存储器"></a>非易失性存储器</h2><p>非易失性存储器:即即使在断电后，仍能保持器数据的存储器</p><h3 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h3><p>只读存储器(Read-Only Memory，ROM)，原本是指一种以非破坏性读出方式工作，只能读出无法写入信息的存储器，但随着技术的发展，现如今部分ROM可以实现读写</p><p>在计算机主板PCB上封装着一块ROM，用于存放固件(firmware)，这块存储器也属于内存的一种，也可由CPU直接寻址，同样例如显卡、磁盘驱动器等复杂的设备，也需要由固件翻译来自CPU和I&#x2F;O设备的请求</p><h3 id="PROM"><a href="#PROM" class="headerlink" title="PROM"></a>PROM</h3><p>可编程只读存储器（Programmable ROM，PROM）允许用户通过专用的设备（编程器）一次性写入自己所需要的信息，这类存储器只可被编程一次，被编写的数据会被永久性保存。</p><p>PROM的每个单元时一种融丝，在出厂时，PROM中的数据全为1&#x2F;0，由用户使用时，再通过编程使PROM存储需要的数据，此时熔丝熔断，数据被写入，这也是只能被编程一次的原因</p><h3 id="EPROM"><a href="#EPROM" class="headerlink" title="EPROM"></a>EPROM</h3><p>可编程可擦除只读存储器（Erasable Programmable Read Only Memory，EPROM）可多次编程，是一种以读为主的可写可读的存储器，在写入新数据时，需要把原先的内容先擦除才能写入。</p><p>EPROM会留有一个透明的石英窗口，当紫外线透过窗口照射在EPROM单元上，该单元会被重置为0。故EPROM需要使用专用设备才能进行擦写。</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/EROM.jpg" alt="EROM"></p><p>RPROM采用MOS管，速度较慢</p><h3 id="EEPROM"><a href="#EEPROM" class="headerlink" title="EEPROM"></a>EEPROM</h3><p>电可擦可编程序只读存储器（Electrically Erasable Programmable Read-Only Memory，EEPROM）是一种可以随时写入而无需先擦除原先内容的存储器，在写入时，也无需使用专用设备。</p><p>EEPROM的写入往往要比读取的速度慢</p><h3 id="Flash"><a href="#Flash" class="headerlink" title="Flash"></a>Flash</h3><p>快擦除读写存储器( Flash Memory)是一种高密度、非易失性的读&#x2F;写半导体存储器。</p><p>其擦写速度要比EERPOM快得多，目前，闪存已广泛用于制作各种移动存储器，如U盘及数码相机&#x2F;摄像机所用的存储卡等。</p><h1 id="程序的装入与链接"><a href="#程序的装入与链接" class="headerlink" title="程序的装入与链接"></a>程序的装入与链接</h1><p>要在系统中运行用户程序，就必须将其由外存装入到内存中，并将其转化为一个可执行的程序，</p><p>在此过程中，会经历以下三步:</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%A4%84%E7%90%86%E7%94%A8%E6%88%B7%E7%A8%8B%E5%BA%8F%E7%9A%84%E4%B8%89%E4%B8%AA%E6%AD%A5%E9%AA%A4.jpg" alt="处理用户程序的三个步骤"></p><h2 id="地址绑定"><a href="#地址绑定" class="headerlink" title="地址绑定"></a>地址绑定</h2><p>以CPU的视角，生成的地址通常为<code>逻辑地址(Logic Address)</code>，也叫相对地址.<a href="../X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80-logical-address">另一篇文字细说</a></p><p>以内存单元的视角，能看到的地址为<code>物理地址(Physical Address)</code>，也叫绝对地址<a href="../X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80-physical-address">另一篇文字细说</a></p><p>在编译和装入的过程中，地址绑定会产生相同的逻辑地址和物理地址</p><p>在执行时，地址绑定会生成不同的逻辑地址和物理地址，此时成逻辑地址为<code>虚拟地址(Virtual Address)</code></p><p>由程序所生成的所有逻辑地址集合被称为<code>逻辑地址空间(Virtual Address Space)</code></p><p>由这些逻辑地址所对于的物理地址的集合被称为<code>物理地址空间(Physical Address Space)</code></p><h2 id="内存保护"><a href="#内存保护" class="headerlink" title="内存保护"></a>内存保护</h2><p>内存保护是操作系统对电脑上的内存进行访问权限管理的一个机制。其主要目的是防止某个进程去访问不是操作系统配置给它的寻址空间，从而防止该进程因某些程序错误或问题而有意或无意地影响到其他进程或是操作系统本身的运行状态和数据，保证进程之间不会相互影响。</p><p>这种保证通常时基于硬件实现的，因为一旦OS进行干预就会严重影响性能</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>一种由编译器(一种程序)将用户程序进行处理，并转换为若干模块的过程，这一过程就是编译</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>由链接程序将编译后产生的<code>一组目标模块</code>以及<code>所需的库函数</code>链接到一起，形成一个完整的装入模块的过程</p><p>根据进行装配的时机不同，分为一下三种</p><h3 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h3><p>在程序<code>运行前</code>，先将各目标模块以及其所需函数库链接成一个完整的装配模块，以后<code>不再拆开</code>,</p><p>静态链接有以下特点:</p><ul><li>代码装载速度快、执行速度略快与动态转载</li><li>只需保证开发者电脑上有正确的函数依赖库文件，再以二进制形式发布程序时无需考虑用户电脑上库文件是否存在或版本问题</li><li>生成的可执行文件大、可执行文件包含公共代码</li><li>每次需要更新其中的目标模块时，则需要重新打开装入模块，影响效率。</li></ul><p>在模块装配时，需解决以下问题:</p><blockquote><p>设有三个模块A、B、C，长度分别为L、M、N，A模块调用B模块；B模块调用C模块</p></blockquote><blockquote><p>这部分内容与书本有出入，待核实！！</p></blockquote><ul><li><p>修改相对地址</p><p>由于上一步编译所产生的目标模块(A、B、C)中所采用的都是相对地址，每个目标模块之间的起始地址都是0，而将其装转载为一个模块时，除原模块A外，被调用的B、C模块在装入模块中的起始位置将不再为0.</p><p>B模块的起始位置为L(0 + A模块长度)</p><p>C模块的起始位置为L+M(B模块的起始位置 + B模块的长度)</p><p>也就是在装入模块中，各目标按顺序相连</p></li><li><p>变换外部调用信号</p><p>由于模块的起始位置发生变化，则要将所用的外部调用符号改为装入模块中的相对位置</p><p>CALL B 指向的就是L</p><p>CALL C 指向的就是 L + M</p></li></ul><h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>动态链接则是不一口气将模块装入，而是按需装入</p><p>具有以下特点:</p><ul><li><p>生成的可执行文件较静态链接生成的可执行文件小；</p></li><li><p>适用于大规模的软件开发，使开发过程独立、耦合度小，便于不同开发者和开发组织之间进行开发和测试；</p></li><li><p>不同编程语言编写的程序只要按照函数调用约定就可以调用同一个DLL函数；</p></li><li><p>DLL文件与EXE文件独立，只要输出接口不变（即名称、参数、返回值类型和调用约定不变），更换DLL文件不会对EXE文件造成任何影响，因而极大地提高了可维护性和可扩展性；</p></li><li><p>使用动态链接库的应用程序不是自完备的，它依赖的DLL模块也要存在，如果使用载入时动态链接，程序启动时发现DLL不存在，系统将终止程序并给出错误信息；</p></li><li><p>速度比静态链接慢；</p></li></ul><h4 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h4><p>将用户源程序编译后得到的一组目标模块，<strong>在装入内存时</strong>，采用边装入边链接的方式。</p><p>当发生一个外部调用事件，则让装入程序去找到被调用的外部目标模块，并装入。</p><h4 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h4><p>对某些目标模块的链接，是在程序执行中需要该模块时才进行的。其优点是便于<strong>修改和更新，便于实现对目标模块的共享</strong>。</p><h2 id="装入"><a href="#装入" class="headerlink" title="装入"></a>装入</h2><p>也被称为加载：由装入程序 将装入模块 装入内存的过程</p><h3 id="绝对装入方式"><a href="#绝对装入方式" class="headerlink" title="绝对装入方式"></a>绝对装入方式</h3><p>当计算机系统很小，且仅能运行<code>单道程序</code>时(即:所有进程一个一个排对执行。若A阻塞，B只能等待的一种程序设计)，此时用户程序在编译后产生的目标模块会带有一个目标代码，代码中包含模块所要装载的位置，这个位置是个内存中的绝对地址。也可以理解为，此时编译产生的目标模块内，逻辑地址&#x3D;物理地址，程序中的所有内存引用都是基于这个绝对地址。</p><blockquote><p>绝对装入方式仅适用于单道程序环境，因为在多道程序环境中，编译器无法预知编译后的程序该放在内存中的何处</p></blockquote><h3 id="可重定向装入方式"><a href="#可重定向装入方式" class="headerlink" title="可重定向装入方式"></a>可重定向装入方式</h3><p>装入时对目标程序中指令和数据的修改过程称为<strong>重定位</strong>，因此可以将模块装载在内存的’’任何位置’’，地址变换通常实在装入时<strong>一次完成的</strong>，所以又称静态重定位</p><p>由于是一次性完成，故在装入内存时，需为装入模块分配全部的内存空间，这段空间应该是连续的。</p><p>若此时系统内存剩余容量不足以装载模块时，模块将不会被装载</p><p>若容量足够，但无连续空间装载模块时，OS可能会尝试移动其他模块，以空出合适的空间装载模块。</p><p>本方式在装载模块后<code>不允许程序运行时在内存中移动位置</code>，此时对模块的移动会影响模块中数据地址发生错误。</p><h3 id="动态运行时装入方式"><a href="#动态运行时装入方式" class="headerlink" title="动态运行时装入方式"></a>动态运行时装入方式</h3><p>装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转化为绝对地址，而是把这种地址转换<strong>推迟到程序真正要执行时才进行</strong>。因此装入内存后的所有地址均为逻辑地址，这种方式需要一个重定位寄存器的支持。</p><p>故这种装入方式，允许程序在内存中发生移动，且在程序运行前只装载部分代码，后续再陆续按需动态分配内存，故这种装入方式可将程序分配在不连续的内存中。</p><h1 id="存储分配方式"><a href="#存储分配方式" class="headerlink" title="存储分配方式"></a>存储分配方式</h1><p>为使用户程序装入内存，则必须为其分配一定大小的存储空间</p><h2 id="连续分配存储方式-分区"><a href="#连续分配存储方式-分区" class="headerlink" title="连续分配存储方式(分区)"></a>连续分配存储方式(分区)</h2><p>简称连续分配方式，被广泛用于20世纪60-80年代的OS</p><p>这种分配方式为用户程序只分配<code>一段连续的内存空间</code>，用户程序中的代码或数据被放置在<code>连续的内存空间</code>中</p><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>在早期单道批处理系统的小型机中，内存常被分为<code>系统内存区</code>和<code>用户内存区</code>，系统内存区被分配至低位，而高位的其他空间，也就是用户内存区中<code>仅有一道用户程序</code>，故整个用户内存区有一个用户程序独占，而这种存储分配方式称为单一内存分配。</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E7%94%A8%E6%88%B7%E5%8C%BA%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%8C%BA.jpg" alt="用户区与系统区"></p><p>正因如此，早期部分的单用户单任务的OS，并未采取存储器保护机制，这是因为单用户环境不存在用户之间互相干扰的问题，并且若OS部分内存遭受破坏，课程通过重启重新载入，相对影响较小，而不采取保护机制，可以节约硬件资源</p><h3 id="固定连续分配"><a href="#固定连续分配" class="headerlink" title="固定连续分配"></a>固定连续分配</h3><p>20世纪60年代出现了多道程序系统，为使得内存可以装入多道程序，且这些程序之间不会互相干扰，于是将用户用户内存区的空间划分为多个大小固定的区域，这些区域也被称为分区，每个分区只装入一个作业。这也是最早的、最简单的一种可以运行多道程序的分区式存储方式。</p><p>此时加入用户空间中有4个分区，那么现在便能允许4个程序并发运行并且互不干扰。当一个作业结束时，分区将空出，并从外存中后备作业列队中选择一个合适大小的作业装入。</p><p>虽然这种分配方式实现简单，但可能会出现当用户程序过于大，可能所有分区都无法满足需求，此时还需使用覆盖技术解决，影响性能</p><p>且分区技术虽不会产生外部碎片，但会产生内部碎片。</p><h4 id="分区的划分"><a href="#分区的划分" class="headerlink" title="分区的划分"></a>分区的划分</h4><p>分区的大小可以时相等或是不相等的</p><ul><li><p>分区大小相等</p><p>将用户空间内的分区划分为多个<code>等大的</code>分区</p><p>这种分区方式适合<code>一台计算机同时控制多个相同对象</code>的场合</p><p>但这种方法<code>缺少灵活性</code>，当程序太小时，会造成空间的浪费，若程序太大，一个分区将装不下该程序</p></li><li><p>分区大小不等</p><p>将存储器划分为多个<code>大小不等</code>的分区，分区大小视系统中作业大小决定</p><p>通常OS会创建较多的小分区，适量的中分区以及少量的大分区</p></li></ul><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F%E5%88%92%E5%88%86_%E5%8A%A8%E6%80%81%E6%88%96%E9%9D%99%E6%80%81.jpg" alt="分区大小划分——动态或静态"></p><h4 id="内存的分配"><a href="#内存的分配" class="headerlink" title="内存的分配"></a>内存的分配</h4><p>为方便内存分配，OS常将分区按照其大小进行排队，并建立一张分区表。</p><p>表通常使用数组或链表实现，记录有分区大小、起始地址、是否已被分配状态等信息。</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E8%BF%9E%E7%BB%AD%E5%88%86%E9%85%8D_%E5%88%86%E5%8C%BA%E8%A1%A8.jpg" alt="连续分配_分区表"></p><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><p>动态分区分配属于可变分区分配，它是<code>不会事先划分内存分区</code>，而是根据实际需求动态的对为用户程序<code>分配合适的内存空间</code>。</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E5%8C%BA.jpg" alt="动态内存分区"></p><h4 id="使用数据结构记录使用情况"><a href="#使用数据结构记录使用情况" class="headerlink" title="使用数据结构记录使用情况"></a>使用数据结构记录使用情况</h4><p>为实现动态分区分配，OS必须配置相应的数据结构，以描述分区的分配情况，进而为分区的分配提供依据。</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="示意图"></p><p>以这张内存分配情况示意图举例，常用的数据结构有以下两种：</p><ul><li><p>空闲分区表</p><p>OS将建立一张表，于之前的分区表类似，只不过用于记录<code>空闲分区</code>，表中每个条目表示一个空闲分区，条目包含分区号、分区大小、起始位置等数据，如下图所示。</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E7%A9%BA%E9%97%B2%E5%88%86%E5%8C%BA%E8%A1%A8.jpg" alt="空闲分区表"></p></li><li><p>空闲分区链</p><p>为实现空闲分区的分配和链接，在每个分区的头部设置一些用于表示分配信息的控制位以及一个向前的指针，并在每个分区尾部设置一个向后的指针。</p><p>这就使得空闲分区形成一个双向的连表，如下：</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E7%A9%BA%E9%97%B2%E5%88%86%E5%8C%BA%E9%93%BE.jpg" alt="空闲分区链"></p></li></ul><h4 id="动态分区分配算法"><a href="#动态分区分配算法" class="headerlink" title="动态分区分配算法"></a>动态分区分配算法</h4><p>若多个分区都满足需求，那作业应该装入到那个分区，这就有相应的动态分区分配算法决定。</p><p>由于分配算法往往对系统性能会产生较大影响，故人们发明了很多中算法，如下:</p><h5 id="基于顺序搜索"><a href="#基于顺序搜索" class="headerlink" title="基于顺序搜索"></a>基于顺序搜索</h5><ul><li><p>首次适应(First Fit,FF)算法</p><p>该算法由地址地位向上顺序查找，直到一个大小合适的分区为止。</p><p>若遍历整个链后任无法找到一个合适的分区，则表明目前系统只能没有合适大小的空闲分区，也就意味着内存分配失败。</p><p>该算法的特点是，在分配内存时，会更加<code>倾向使用低位空间</code>，而高位往往保留着大量空闲的空间，方便以后到达的大作业的使用，但由于频繁划分地位空间，会导致地位保留许多难以利用的小空闲分区，也就是碎片，这些碎片也会增大查找空闲分区的开销，如下：</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E9%A6%96%E6%AC%A1%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.jpg" alt="首次适应算法"></p></li><li><p>循环首次适应(Next Fit,NF)算法</p><p>循环首次适应算法于首先适应算法类似，只不过在查找空闲分区时，并不每次从链首开始查找，而是<code>基于上次查找到的空闲分区</code>的位置向上进行查找</p><p>这么做时可以有效避免过度倾向使用地位的空间，可以使空闲分区分布更加均匀，缓解一个地方堆积大量无法利用的碎片，但这么做会使得空间中连续的大块分区变少。</p><blockquote><p>应该看得懂，就不配图了</p></blockquote></li><li><p>最佳适应(Best Fit,BF)算法</p><p>最佳：指的是将最小可用的空闲分区分配给作业</p><p>最佳适应算法将所有可用空闲分区<code>由小到大</code>排序，形成空闲分区链。当需要装入作业时，由小至大遍历分区链，直到找到一个<code>可以容纳作业的最小空闲分区</code>，将作业装入该分区，由于倾向于使用小分区，则会更有可能保留大分区以应对大作业。如下：</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E6%9C%80%E4%BD%B3%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95.jpg" alt="最佳适应算法"></p><p>孤立的看，这种算法貌似是最好的，因为看上去每次浪费的空间是最小的，但长远来看，由于每次装入后产生的空闲分区也最小，着也导致后续会产生大量无法利用的碎片</p></li><li><p>最坏使用(Worst Fit,WF)算法</p><p>最坏：也就是和最好唱反调</p><p>最佳适应算法将所有可用空闲分区<code>由大到小</code>排序，形成空闲分区链。当需要装入作业时，由大至小遍历分区链。</p><p>由于更加倾向于使用大分区，故这种算法必然会导致存储器中缺乏大空闲分区，也就意味着当有大作业时，很有可能会因为没有合适的分区而导致内存分配失败。</p><p>但换个角度看，最坏使用算法每次被切割后产生的空闲分区并不小，被利用的概率要比最佳使用算法要好，故对小作业场景更有好，所以最坏也未必坏</p><blockquote><p>应该看得懂，就不配图了</p></blockquote></li></ul><h5 id="基于索引搜索"><a href="#基于索引搜索" class="headerlink" title="基于索引搜索"></a>基于索引搜索</h5><ul><li><p>快速适应算法</p><p>OS先依据常用的分区大小(大小由OS决定)，先将用户空间划分为<code>若种不同大小的分区</code>，分区<code>不再被二次分割</code>，再将<code>相同大小的分区建立单独的空闲分区链表</code>，然后再交友一张索引表管理。</p><p>当有作业需要装入时，系统会在索引表中找到最小可容纳的分区大小，然后去对应链表中拿一个分区用于装入作业。</p><p>可以看出，快速适应算法比较复杂，对于装入过程，查找效率高，且倾向于使用更小的空闲分区，但在分区回收时，由于算法复杂，对系统开销也大。</p><p>而且由于分区不再被二次分割，虽然不会产生外碎片，但会产生内碎片</p><blockquote><p>欸，要是小分区都用完了，这时还有很多小作业怎么办</p><p>还能怎么办，这时只能学迪拜土豪，拿大分区装小作业，这也是一种典型的拿空间换时间的做法</p></blockquote></li><li><p>伙伴系统</p><p>伙伴系统相对而言就没那么死板</p><p>伙伴系统规定，无论分区是否被分配，<code>所有分区都必须是2ᵏ(k为整数，n ≤ k ≤ m)</code>，2ⁿ为分配的最小分区大小，2ᵐ为可分配的最大分区大小，通常2ᵐ为整个可分配内存</p><p>系统启动初期，只有一个空闲分区，也就是整个内存</p><p>随着系统的运行，由于不断划分，会产生若干个不同大小的分区</p><p>对于相同的大小的所有空闲分区，会为其单独设立一个空闲分区链表，</p><p>若装载一个大小为k的作业，首先计算出一个值i，使得<code>2ⁱ⁻¹ &lt; k ≤ 2ⁱ</code></p><p>然后尝试去大小为2ⁱ的空闲分区链表中找到一个空闲分区，若能，则将该分区分配给该作业独享</p><p>若此时无可满足大小的分区，则尝试<code>向2ⁱ⁺¹大小的空闲分区链</code>表查找是否有空闲分区，若有，借用一个2ⁱ⁺¹大小的空闲分区，将其<code>拆分为两个2ⁱ大小的空闲分区</code>，并将其中一个分配给作业独享，剩余一个加入2ⁱ大小的空闲分区链表中备用</p><p>如此循环，直到遍历到最大的分区链表，若还找不到，则分配失败</p><p>被拆分的分区被称为’一对伙伴’，在回收分区时也将被合并</p><p>伙伴系统依旧存在内碎片，但要比快速适应算法好得多。</p></li><li><p>哈希算法</p><p>哈希(Hash)：一种散列函数，可以将任意长度的输入通过散列算法变换成固定长度的输出，该输出就是散列值。同一输入得到的哈希值是唯一的，哈希值很难被逆向。</p><p>哈希表作为一种高效的数据存储结构，可以使数据的存储位置与关键码之间建立一一映射的关系，从而加快元素的搜索速度，这里不细究原理。</p><p>基于哈希快速查找的优点，将空闲空间大小作为关键字，并将这些关键字经过计算得到哈希值，并再将这些哈希值存储到一个链表中，这就得到了一个哈希表。</p><p>在需要分配空间时，将按照需要分配的空间大小，提供哈希计算出相应空闲分区链表在哈希表中的位置，并取出一个空闲分区分配。</p><p>利用哈希主要还是利用其特性加速查找。</p></li></ul><h4 id="可变分区的分配与回收"><a href="#可变分区的分配与回收" class="headerlink" title="可变分区的分配与回收"></a>可变分区的分配与回收</h4><h5 id="可变分区的分配"><a href="#可变分区的分配" class="headerlink" title="可变分区的分配"></a>可变分区的分配</h5><p>设请求的分区大小为u.size，空闲分区表中每个空闲分区大小为m.size，事先规定的最小不可切分大小为size</p><ul><li><p>当当前空闲分区小于请求分区大小时，也就是<code>u.size &gt; m.size</code>，将继续向下一表项遍历</p></li><li><p>若当前空闲分区在分配后剩余的空间小于等于不可分割的大小，也就是<code>m.size - u.size ≤ size</code>，则将这个空闲分区<code>不切割</code>进行分配</p></li><li><p>若剩余大小大于不可分割的大小，则分配u.size大小的分区</p></li></ul><p><img data-src="/image/%E5%88%86%E9%85%8D%E5%86%85%E5%AD%98_%E6%B5%81%E7%A8%8B.png" alt="分配内存_流程"></p><h5 id="可变分区的回收"><a href="#可变分区的回收" class="headerlink" title="可变分区的回收"></a>可变分区的回收</h5><p>系统在回收分区时，会从当前链表中找到相应的插入点用于插入空闲分区信息，此时就存在以下3种情况</p><ul><li><p>回收区时插入点与一个分区相邻时，合并这两个分区</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E4%B8%80%E4%B8%AA%E7%9B%B8%E9%82%BB%E5%88%86%E5%8C%BA%E6%97%B6_%E5%9B%9E%E6%94%B6.png" alt="一个相邻分区时_回收"></p></li><li><p>回收区时插入点与前后各一个分区相邻时，合并这三个分区</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E4%B8%A4%E4%B8%AA%E7%9B%B8%E9%82%BB%E5%88%86%E5%8C%BA%E6%97%B6_%E5%9B%9E%E6%94%B6.png" alt="两个相邻分区时_回收"></p></li><li><p>回收区时插入点与前后两个分区都不相连时，此时单独新建一个表项，并将其按照回收区的起始位置插入到表中合适位置</p></li></ul><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E4%B8%8D%E7%9B%B8%E9%82%BB%E5%88%86%E5%8C%BA%E5%9B%9E%E6%94%B6.png" alt="不相邻分区回收"></p><h3 id="动态重定向分配"><a href="#动态重定向分配" class="headerlink" title="动态重定向分配"></a>动态重定向分配</h3><p>在连续分配存储方式中，随着计算机的运行，计算机内存中将产生很多<code>小而零散</code>的分区，这些小分区难以被利用，这些分区也就是外碎片</p><h4 id="怎么解决"><a href="#怎么解决" class="headerlink" title="怎么解决"></a>怎么解决</h4><p><code>紧凑</code>是将内存中的作业进行移动，将它们<code>移动到一起</code>，以<code>腾出一块大的空闲</code>空间的方法</p><p>紧凑有时也被称作:紧缩、拼接</p><p>由于紧凑操作对内存中的程序和数据进行移动，这就导致位置发生改变，此时就需要对移动后的程序和数据进行<code>重定位</code></p><p>OS会在一段时间对内存进行一次紧缩和重定位操作，以确保系统的内存利用率，但这些操作比较复杂，其实对系统性能影响很大，过于频繁的操作可能会严重影响系统的性能</p><h2 id="分页存储方式"><a href="#分页存储方式" class="headerlink" title="分页存储方式"></a>分页存储方式</h2><p>连续分配方式在计算机的运行过程中会产生很多碎片，虽然可以提供紧凑解决，但对系统性能开销较大，如果允许<code>单个作业零散的被分配到不相邻的区域中</code>，就能更加有效的利用内存空间</p><p>分页存储方式中，将用户程序地址空间划分为若干各<code>大小固定的区域</code>，这些区域就是<code>页</code>也叫页面</p><p>每个页都有对于的编号，也就是<code>页号</code>，从0开始编号</p><p>每个页在物理内存中就是一段段连续的空间块，这些空间被叫做<code>页框</code>，同样页框也会从0开始编号，也就是<code>页框号</code>，页框号和页号是两个东西<br>$$<br>页框号 &#x3D; INT[逻辑地址 &#x2F; 单个页框长度]<br>$$<br>页框的在物理地址中的起始位置就是<code>页基址</code>，在页框大小相同时<br>$$<br>页基址 &#x3D; 页框号 * 页框大小<br>$$<br>程序&#x2F;数据在页框中的位置，<code>基于页基址的偏移量</code>叫<code>页内偏移量</code>，也叫<code>页内地址</code><br>$$<br>物理地址 &#x3D; 页基址 + 页内偏移量<br>$$<br><a href="../X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/#%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80-linear-address">更多细节可以参考这个</a></p><h3 id="页面大小与内碎片"><a href="#页面大小与内碎片" class="headerlink" title="页面大小与内碎片"></a>页面大小与内碎片</h3><p>页面的大小不是越大&#x2F;越小就越好</p><p>由于一个作业常常占不满分配给该作业的最后一个页，这就势必会产生内碎片</p><p>通过设置更小的页可以提高内存的利用率，但更小的页也将会使一个作业分配到更多的页，这会使该进程的页表过长，不仅占用内存，也会降低页面换入&#x2F;换出的效率</p><h3 id="分页地址结构"><a href="#分页地址结构" class="headerlink" title="分页地址结构"></a>分页地址结构</h3><blockquote><p>以下只考虑纯分页管理的情况，不涉及<a href="../X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/#%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80">段页式混合管理</a>，且只考虑X86架构</p></blockquote><p>分页地址由 低位的12位页内偏移量 和处于 高位的20位的页号组成</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%88%86%E9%A1%B5%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84.png" alt="分页地址结构"></p><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>在分页系统中，各进程的各页可能零散的存放于物理内存空间中，位确保进程能够顺利运行，系统将为每个进程新建页面映射表，简称<code>页表</code></p><p>页表由操作系统进行维护，一般程序无权访问与修改，操作系统会定期维护页表</p><p>在进程地址空间中的所有页，都依次在页表中由一个页表项，页表中存放着页基址等信息，实现页号到物理地址(页框)之间的映射</p><h3 id="分页地址的变址"><a href="#分页地址的变址" class="headerlink" title="分页地址的变址"></a>分页地址的变址</h3><p>为使用户地址空间的逻辑地址转换为内存空间的物理地址，系统中必须设置地址的变换机构</p><h4 id="基于地址的变址机构"><a href="#基于地址的变址机构" class="headerlink" title="基于地址的变址机构"></a>基于地址的变址机构</h4><p>变址操作的频率非常高，故变址机构会利用硬件进行实现</p><p>例如页表就是利用一组专门的寄存器实现</p><p>由于寄存器制造成本高，故大多数页表存储在内存中</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E9%A1%B5%E9%9D%A2%E5%9C%B0%E5%9D%80%E5%8F%98%E5%9D%80.png" alt="页面地址变址"></p><p>在索引时，先将页号与页表长度进行比较，若大于页表长度，也就是越界，此时就会产生一个越界中断</p><p>若未越界，页号将在页表中得到页基址，将页基址对应的物理块号存放于物理地址寄存器中</p><p>再加上逻辑地址中的页内偏移量就得到数据的物理地址</p><h4 id="具有快表的地址变换机构"><a href="#具有快表的地址变换机构" class="headerlink" title="具有快表的地址变换机构"></a>具有快表的地址变换机构</h4><p>由于页表被存放于内存中，这就意味着当CPU每次存取数据时，就需要访问内存两次，着就降低了系统的运行效率</p><p>为提高变址效率，再变址机构中设立一个具有并行查能力的高速缓冲寄存器，也就是联想寄存器,也就是快表(TLB， translation lookaside buffer)</p><p>TLB页表不受操作系统维护，而是交由MMU硬件。MMU会不间断更改TLB页表的内容，例如在TLB miss(TLB 未命中)时，MMU会将未命中的页表项插入TLB页表。</p><p>在进行变址时，会优先去TBL中查找，若未命中，才去内存中找页表查找</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84.png" alt="具有快表的地址变换机构"></p><h4 id="引入快表后的内存有效访问时间"><a href="#引入快表后的内存有效访问时间" class="headerlink" title="引入快表后的内存有效访问时间"></a>引入快表后的内存有效访问时间</h4><p>从进程法术指定逻辑地址的访问请求，经过变址。再到内存中找到对应的物理地址，这一流程所花费的时间被称为<code>有效访问时间(Effective access time, EAT)</code></p><p>计算公式如下:<br>$$<br>EAT &#x3D; a * λ +(t + λ)(1 - a) + t \\<br>&#x3D; 2t + λ - t * a<br>$$<br>λ表示查找快表所需要的时间 | a表示命中率 | t表示访问一次内存所需要的时间</p><h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><blockquote><p>以下只考虑纯分页管理的情况，不涉及<a href="../X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/#%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80">段页式混合管理</a>，且只考虑X86架构</p></blockquote><p>页表存储虽然可以使一个作业分配在若干个零散的内存空间中，但<code>页表</code>必须连续存放，当一个页表很大时，就需要占用一段很大的连续空间。且链表必须常驻内存，大量表也会造成内存浪费</p><p>我们可以将链表进行分组，使一个内存块正好放下一个页表(这里以一个内存块4KB为例)</p><p>对离散的页表专门分配一张页表，这张页表就是<code>外页表</code>，也叫<code>页目录</code>&#x2F;<code>顶层页表</code></p><p>为方便实现地址转换，在变址机构中，需要增设一个外层页表寄存器，用于存放外城页表的起始位置</p><p>外页表中的每个页表向记录着各页表的物理块号，如下</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E4%BA%8C%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%A4%BA%E4%BE%8B.png" alt="二级页表示例"></p><p>当页面大小为4KB(12位)时，若采用一级页表结构则应具有20位(32-12)的页号，即此时页表项有1M个</p><p>当采用两级页表结构时，假设每个页表项占用4B，则每个页可包含2^10个页表项，最多有2^10个分页。</p><h4 id="在64位环境下"><a href="#在64位环境下" class="headerlink" title="在64位环境下"></a>在64位环境下</h4><p>对于32位计算机，采用二级页表结构很合适</p><p>但对于64位计算机就不一定，例如此时页面大小仍是4KB，即2^12B，每个页占用4B，地址还剩下52位(64-12)，假定物理块大小还是4KB，则还剩下42位(64-12-10)用于外层页号，也就是外层页表凯南有4096G个页表项，将占用4096GB的空间，很显然是不可接受的</p><p>此时必须将现在的外层页表在分成两层，也就是三层页表的结构</p><h2 id="分段存储方式"><a href="#分段存储方式" class="headerlink" title="分段存储方式"></a>分段存储方式</h2><p>分页存储主要是为了提高内存利用率，而分段存储主要目的则是为了更好地<code>满足用户的逻辑需求</code>，如数据共享、数据保护和动态链接等。因此，当今许多高级语言支持也使用分段存储方式。</p><p>分页存储是<code>以进程为单位</code>分配连续的空间，而分段存储将<code>以分段为单位</code>分配连续空间，而<code>一个进程可能由多个分段组成</code></p><blockquote><p>分段管理的诞生，最早是为了扩充8086处理器的寻址空间<a href="../X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/#%E5%88%86%E6%AE%B5%E7%AE%A1%E7%90%86%E7%9A%84%E8%AF%9E%E7%94%9F">另一篇文字细说</a></p></blockquote><h3 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h3><p>在分段管理方式中，作业地址空间被分为若干段，并用<code>段号表示不同段</code></p><p>每个段都从<code>0开始编址</code>，并采用一段<code>连续的地址空间</code>，且各个段之间<code>彼此独立</code></p><p>每个段都具有自己的<code>段基址</code>(段在物理地址中的起始位置)以及<code>长度</code>。</p><p>每个段可以<code>定义一组相对完整的逻辑信息</code>，如主程序段、子程序段、数据段等</p><p>段的<code>长度不固定</code>，而是由程序自身逻辑关系进行划分，一个进程可划分为多个段</p><p>分段地址由地位的段内地址以及高位的段号组成</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%88%86%E6%AE%B5%E5%9C%B0%E5%9D%80.png" alt="分段地址"></p><h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p>由于分段存储是将一个作业空间按照程序自身逻辑关系，划分为若干大小不等的段，这些段可以零散的存储在内存用户区或是分页中（段页结合管理方式)</p><p>由于段的位置不好确定，OS会维护一张段号和段基址之间对应关系的映射表，也就是段表。</p><p>段表中的每个项表示一个段，记录了段号、段基址、段长度等信息</p><p>段表可放置于寄存器中，以提高运行效率</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E6%AE%B5%E8%A1%A8.png" alt="段表"></p><h3 id="分段地址的变址"><a href="#分段地址的变址" class="headerlink" title="分段地址的变址"></a>分段地址的变址</h3><p>系统中通常会设置段表寄存器，段表寄存器中存储了段表的起始位置以及段表的长度(TL)</p><p>当分段地址需要变址时，会先将段号与段表起始位置进行累加，再与段表长度TL进行比较</p><p>若大于段表长度，也就越界了，此时将发出中断信号</p><p>若小于，则会尝试在段表中查找段表项，得到段基址于段长</p><p>此时利用累加器对段基址于段内偏移量进行相加</p><p>此时若大于段长，也是越界、发出中断</p><p>若小于则可得到段起始位置的物理地址，编制结束</p><p><img data-src="/../image/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/%E5%88%86%E6%AE%B5%E5%8F%98%E5%9D%80.png" alt="分段变址"></p><p>可以看出，和分页存储利用页表进行变址一样，访问一次数据，就需要读取两次内存</p><p>所以，分段存储也会使用“快表”对段表进行存储，和分页类似，就不多赘述了</p><h3 id="一维和二维的问题"><a href="#一维和二维的问题" class="headerlink" title="一维和二维的问题"></a>一维和二维的问题</h3><p>主要是怎么理解分页是一维的，而分段是二维的这一说法。</p><p>发现在网上有<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/601280472">争论</a>，我这里结合书中的讲解，赞成‘wfs’的说法</p><p>分页完全是系统行为，分页大小可预见，程序员只需利用一个页号就可以表示一个地址，这是一维</p><p>而分段是用户行为，分段大小由程序逻辑决定，故大小不好遇见，所以程序员既要给出段号，还要给出段内地址，这是二维</p><hr><blockquote><p>参考资料：</p><p>《计算机操作系统(慕课版)》 - 中国通信出版集团 人民邮电出版社</p><p>《深入理解计算机系统》 - 机械工业出版社</p><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8/1583185#5">存储器_百度百科 (baidu.com)</a></p><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8/187682">寄存器_百度百科 (baidu.com)</a></p><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8?fromModule=lemma_search-box">主存储器_百度百科 (baidu.com)</a></p><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A4%96%E5%AD%98%E5%82%A8%E5%99%A8">外存储器_百度百科 (baidu.com)</a></p><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8?fromtitle=RAM&fromid=144481&fromModule=lemma_search-box">随机存取存储器_百度百科 (baidu.com)</a></p><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/SRAM%E5%AD%98%E5%82%A8%E5%99%A8/18883998?fromModule=search-result_lemma-recommend">SRAM存储器_百度百科 (baidu.com)</a></p><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8/12717044">动态随机存取存储器_百度百科 (baidu.com)</a></p><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8/2399075">只读存储器_百度百科 (baidu.com)</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dawuga/article/details/104400171">操作系统-程序的装入和链接_怎么区分链接和装入-CSDN博客</a></p><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F/7379759#:~:text=%E5%8D%95%E4%B8%80%E8%BF%9E%E7%BB%AD%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D,%E7%94%A8%E8%BF%99%E7%A7%8D%E7%AE%A1%E7%90%86%E6%96%B9%E6%A1%88%E3%80%82">单一连续分区分配方式_百度百科 (baidu.com)</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45990326/article/details/119967080">连续分配管理方式（单一连续分配 固定分区分配 动态分区分配）-CSDN博客</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45990326/article/details/119968255">动态分区分配算法（1、首次适应算法 2、最佳适应算法 3、最坏适应算法 4、邻近适应算法）-CSDN博客</a></p><p><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/HASH/390310">Hash（散列函数）_百度百科 (baidu.com)</a></p><p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7126514613432090655">分页和分段有什区别？ - 掘金 (juejin.cn)</a></p><p>一些有关AI生成的内容</p></blockquote></div><footer class="post-footer"><div class="reward-container"><div>请我一杯咖啡吧！</div><button>赞赏</button><div class="post-reward"><div><img src="/../image/wechatpay.png" alt="Canyue 微信"> <span>微信</span></div><div><img src="/../image/alipay.png" alt="Canyue 支付宝"> <span>支付宝</span></div></div></div><div class="post-copyright"><ul><li class="post-copyright-author"><strong>本文作者： </strong>Canyue</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://blog.canyue.top/article/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8/" title="操作系统与存储器管理">https://blog.canyue.top/article/操作系统与存储器/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh_CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="post-tags"><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" rel="tag"># 计算机组成原理</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a></div><div class="post-nav"><div class="post-nav-item"><a href="/article/GO%E8%AF%AD%E8%A8%80%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/" rel="prev" title="GO语言快速上手"><i class="fa fa-angle-left"></i> GO语言快速上手</a></div><div class="post-nav-item"><a href="/article/X86%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B0%8F%E7%A0%94%E7%A9%B6/" rel="next" title="X86内存机制的小研究">X86内存机制的小研究 <i class="fa fa-angle-right"></i></a></div></div></footer></article></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2023 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="fa fa-code"></i> </span><span class="author" itemprop="copyrightHolder">Canyue</span></div>使用Cloudflare、BootCDN为本站加速 <span>博客已"稳定"运行 <span id="days" style="font-weight:800;color:#aaa">0</span>天</span><script>let s1="2023-6-18",days=(s1=new Date(s1.replace(/-/g,"/")),(s2=new Date).getTime()-s1.getTime()),number_of_days=parseInt(days/864e5);document.getElementById("days").innerHTML=number_of_days</script><script color="130,90,120" opacity="0.25" zindex="5" count="60" src="https://cdn.bootcdn.net/ajax/libs/canvas-nest.js/2.0.4/canvas-nest.js"></script></div></footer><div class="back-to-top" role="button" aria-label="返回顶部"><i class="fa fa-arrow-up fa-lg"></i> <span>0%</span></div><div class="reading-progress-bar"></div><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><script src="https://cdn.bootcdn.net/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script><script src="https://cdn.bootcdn.net/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous"></script><script src="https://cdn.bootcdn.net/ajax/libs/fancyapps-ui/5.0.33/fancybox/fancybox.umd.js" integrity="sha256-+2+qOqR8CKoHh/AsVR9k2qaDBKWjYNC2nozhYmv5j9k=" crossorigin="anonymous"></script><script src="https://cdn.bootcdn.net/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous"></script><script src="https://cdn.bootcdn.net/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script><script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/pjax.js"></script><script src="https://cdn.bootcdn.net/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script><script src="/js/third-party/search/local-search.js"></script><script src="/js/third-party/fancybox.js"></script><script src="/js/third-party/pace.js"></script><script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script><script src="/js/third-party/math/mathjax.js"></script></body></html>